{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/discord.png","path":"img/discord.png","modified":0,"renderable":0},{"_id":"source/img/icon.png","path":"img/icon.png","modified":0,"renderable":0},{"_id":"source/img/movebit_logo.png","path":"img/movebit_logo.png","modified":0,"renderable":0},{"_id":"source/img/movectf.jpeg","path":"img/movectf.jpeg","modified":0,"renderable":0},{"_id":"source/img/post3_1.png","path":"img/post3_1.png","modified":0,"renderable":0},{"_id":"source/img/post3_2.png","path":"img/post3_2.png","modified":0,"renderable":0},{"_id":"source/img/post3_3.png","path":"img/post3_3.png","modified":0,"renderable":0},{"_id":"source/img/sui_logo.png","path":"img/sui_logo.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-movebit/source/css/base.css","path":"css/base.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/common.css","path":"css/common.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/github-markdown.css","path":"css/github-markdown.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/index.css","path":"css/index.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/post.css","path":"css/post.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo.css","path":"iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo_index.html","path":"iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.css","path":"iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.js","path":"iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.json","path":"iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff2","path":"iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/js/backtotop.js","path":"js/backtotop.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"source/img/123.png","path":"img/123.png","modified":0,"renderable":0},{"_id":"source/img/1234.png","path":"img/1234.png","modified":0,"renderable":0},{"_id":"source/img/12345.png","path":"img/12345.png","modified":0,"renderable":0},{"_id":"source/img/123456.png","path":"img/123456.png","modified":0,"renderable":0},{"_id":"source/img/23.jpeg","path":"img/23.jpeg","modified":0,"renderable":0},{"_id":"source/img/24.png","path":"img/24.png","modified":0,"renderable":0},{"_id":"source/img/25.png","path":"img/25.png","modified":0,"renderable":0},{"_id":"source/img/26.png","path":"img/26.png","modified":0,"renderable":0},{"_id":"source/img/27.png","path":"img/27.png","modified":0,"renderable":0},{"_id":"source/img/28.png","path":"img/28.png","modified":0,"renderable":0},{"_id":"source/img/30.png","path":"img/30.png","modified":0,"renderable":0},{"_id":"source/img/31.png","path":"img/31.png","modified":0,"renderable":0},{"_id":"source/img/33.png","path":"img/33.png","modified":0,"renderable":0},{"_id":"source/img/300.png","path":"img/300.png","modified":0,"renderable":0},{"_id":"source/img/301.png","path":"img/301.png","modified":0,"renderable":0},{"_id":"source/img/302.png","path":"img/302.png","modified":0,"renderable":0},{"_id":"source/img/303.png","path":"img/303.png","modified":0,"renderable":0},{"_id":"source/img/304.png","path":"img/304.png","modified":0,"renderable":0},{"_id":"source/img/305.png","path":"img/305.png","modified":0,"renderable":0},{"_id":"source/img/306.png","path":"img/306.png","modified":0,"renderable":0},{"_id":"source/img/308.png","path":"img/308.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"e08d7e577111e41028e5adc3327d26bd87d9775e","modified":1670233923530},{"_id":"source/about/index.md","hash":"a5b280c8415bb43fae135e6d11f044e4c42bd049","modified":1670233923530},{"_id":"source/_posts/move-prover-tutorial-part-1.md","hash":"c4d435b42eb784d11f18152b68281a29d887220c","modified":1670233923530},{"_id":"source/_posts/the-first-movectf-summary.md","hash":"caf4171520e1c8359382928f41547de6d426bd14","modified":1670233923530},{"_id":"source/_posts/movectf.md","hash":"19e387c641906dbe7d0f46adfc16f5f3491a658d","modified":1670233923530},{"_id":"source/img/discord.png","hash":"5a6c95672d7ab8864959b58aca7aaea97f981d08","modified":1670233992152},{"_id":"source/.DS_Store","hash":"406834b0d7b1b1254393ba2f2c4ef678bb2bd10c","modified":1670233923530},{"_id":"source/img/icon.png","hash":"d9d8a92a43f9a9a45177e51e7666a93b1a80b73b","modified":1670233923531},{"_id":"source/img/movebit_logo.png","hash":"e9c8ea1ba562979d702a2d1a3332b77821aa75f5","modified":1670233923531},{"_id":"source/img/movectf.jpeg","hash":"0a50cd6800edecbc2fc7b5849ae512b8549e5561","modified":1670233923531},{"_id":"source/img/post3_2.png","hash":"019446fc29fcc0a3333dec0e58475051a1a39d89","modified":1670233923532},{"_id":"source/img/post3_3.png","hash":"1111a336ef4886beabba1023bc44e3029314ae94","modified":1670233923532},{"_id":"source/img/sui_logo.png","hash":"8e28db5c0e2bf50169a38aa351fdbcc842cd9673","modified":1670233923533},{"_id":"source/img/post3_1.png","hash":"02c1f6c63c1c4a54820c514158fa7298445471dd","modified":1670233923532},{"_id":"node_modules/hexo-theme-movebit/LICENSE","hash":"c780fac19902db7360b2bab8f3783c08d28c11da","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/README.md","hash":"6771ab7cd71f572ce385429248a1e9ea2bd6733b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/README.zh-CN.md","hash":"ca987cefc6c33b8035d4d238129928b54187ccec","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/_config.yml","hash":"c98f7ff2b0422bc5f2ddf9461df8367d74d9a2d4","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/package.json","hash":"7511368500be47817900d26427869329d580176d","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/es.yml","hash":"29cf37178f7596fe408cd3234d3addb880608287","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/de.yml","hash":"72cc121b4a9e18c55623cf8035d288e415841851","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/ja.yml","hash":"08c64794618945b5da0edcc5065e46577fbd5ff3","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/default.yml","hash":"c6ab47da3b1e3ec2098aee65cd5b3ee1fd4cc299","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/fr.yml","hash":"ac102613f8a7f10b32b6e38d99d5511034733a0d","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/ko.yml","hash":"98f150835d5b039cdfe1cf8b32df815d8d763231","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/nl.yml","hash":"e6f86d1bc16c916089057e8c8d354983ee839d21","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/no.yml","hash":"1c6fd53c378fdd00c2f84ef0af4f61c1f8ea4f8b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/pt.yml","hash":"0719f13aa9f5211400b129d310f517750f4a6e0b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/ru.yml","hash":"ada59b0713fef0e6617a12b20065ce9b24234521","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/zh-CN.yml","hash":"3a3b4ade3ffcf5ef330e31d3ce0d69804cfa7c26","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/zh-TW.yml","hash":"3d26316a125ea18c64658d4e028351e395e45756","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/archive.ejs","hash":"7fafb2111830763e65c3fef26c9063fdfd17e2a4","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/index.ejs","hash":"fd7067b5dcecb0c42580a760d26808e336964818","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/layout.ejs","hash":"28a32f4c9ec414e5e8f4f5054782ef26435071a1","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/post.ejs","hash":"3e709ffcc4e06d651c9aababfda7582ff484acb1","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/backtotop.ejs","hash":"a7dfc124629cb256adf26963bb393b89f09a3476","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/footer.ejs","hash":"63d582ba201f9e43fe7f93c627a7559b0269ed6e","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/header.ejs","hash":"776d6a10d9813ad36d4a99772733ba2c27b4bbbf","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/links.ejs","hash":"b143f142b3ab8b78d996c46814cd06ed6cf6a2df","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/name.ejs","hash":"bbfb751eddc8a6d22fe727d655eeb4a6a787511c","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/search.ejs","hash":"7e09f78f4f1c907076a0e82b500827fe017119cc","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/base.css","hash":"823cd020f9ab198105689f3aa02c0c0cbd60f5dc","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/common.css","hash":"5a3e4c477645aa8e557d3e680924b327a0a0f625","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/github-markdown.css","hash":"f78aa3fbbcc5cceab0ee67246b55db8b982c4634","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/highlight.css","hash":"22c32290b22589e69f53cbbd632c77bf398f2130","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/index.css","hash":"5d4d3b2b286ae9b45cd060698060cdbd0571eed9","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/post.css","hash":"02736e416b73bd0dbda7d2f8d22d31fb7a3386a1","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo_index.html","hash":"db375ad1f08ed3eeeb455771fca147838394551a","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.js","hash":"55c291a13445c03d566ac8436103a72806d212a5","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.json","hash":"c0eaad34b9e807d2227177d58ec784a5a5e7a89b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.css","hash":"bd5cee4f45e9e3803107ecc6add2d54387246c01","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.eot","hash":"ec8e59b46aee56ebd3fd4bc891fa89b141f8dd77","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.ttf","hash":"434a4874aca648921248884536c3bf3e15e8ff46","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.svg","hash":"39b05213c87755919dd16144be63e288c58d9e81","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff","hash":"97b0996a861db6fdbbc35f40319580273604404b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff2","hash":"7ef38c1ebe016f9431f1ef5e9ee7348b38a3a3a9","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/js/backtotop.js","hash":"7d31a9b613dcaa88e0f4154a62cd0fb2cfe598e8","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/images/avatar.png","hash":"ea85d371631b34984022817ab63449fb297a2a93","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/images/favicon.png","hash":"7ac208a08013a1dbfa19253602b05b84095310b0","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/js/fancybox.js","hash":"b217d56f8db94498d7e272d164abac6ab1c07ddd","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/js/search.js","hash":"21c1e736a60de5243742272a7009b47fa1a6ecee","modified":1670295417479},{"_id":"public/atom.xml","hash":"bba718b3fa1afa795b3e91290ef0c1ac1fedd171","modified":1672729606248},{"_id":"public/search.xml","hash":"419cca1bde47a512ad05d4c69714047a4d9e6e8f","modified":1672729176035},{"_id":"public/about/index.html","hash":"67867897bce469cd459300688a3725217e90350d","modified":1670295455446},{"_id":"public/post/the-first-movectf-summary.html","hash":"9653bcfec730860f3c0d3d172108ab6f2dcaedfc","modified":1672383974299},{"_id":"public/post/movectf.html","hash":"01c7e55edeb55c483763383f3ee5266e2545e0f1","modified":1670295455446},{"_id":"public/archives/index.html","hash":"89cd92337d2584bd5b248bd80870954cfc3d4ea9","modified":1672726627620},{"_id":"public/archives/2022/index.html","hash":"25ffb3fdcb8d4c5d98cf45e053af951bd5912c4a","modified":1672726627620},{"_id":"public/archives/2022/09/index.html","hash":"8ab7326ee809535c1a7d78f532cff063f809cb71","modified":1672726627620},{"_id":"public/archives/2022/10/index.html","hash":"9be43329f9f8ebf0c2edc560fdddd7fe8d27df34","modified":1672726627620},{"_id":"public/archives/2022/11/index.html","hash":"62409333098dad141317eca1ef066314e3930e8e","modified":1672726627620},{"_id":"public/index.html","hash":"1cce2e2ea0e9c747e9c8fac3303da69c67cb8428","modified":1672726627620},{"_id":"public/tags/move-prover-m/index.html","hash":"f06e44851b4a2a589e89ec2c45ea3f9f313e40b7","modified":1672726627620},{"_id":"public/post/move-prover-tutorial-part-1.html","hash":"0473366d7168ff5bcfef4b6e45be38ca92b221a5","modified":1670295455446},{"_id":"public/CNAME","hash":"e08d7e577111e41028e5adc3327d26bd87d9775e","modified":1670295455446},{"_id":"public/img/icon.png","hash":"d9d8a92a43f9a9a45177e51e7666a93b1a80b73b","modified":1670295455446},{"_id":"public/img/discord.png","hash":"5a6c95672d7ab8864959b58aca7aaea97f981d08","modified":1670295455446},{"_id":"public/img/movebit_logo.png","hash":"e9c8ea1ba562979d702a2d1a3332b77821aa75f5","modified":1670295455446},{"_id":"public/img/movectf.jpeg","hash":"0a50cd6800edecbc2fc7b5849ae512b8549e5561","modified":1670295455446},{"_id":"public/img/post3_2.png","hash":"019446fc29fcc0a3333dec0e58475051a1a39d89","modified":1670295455446},{"_id":"public/img/post3_3.png","hash":"1111a336ef4886beabba1023bc44e3029314ae94","modified":1670295455446},{"_id":"public/img/sui_logo.png","hash":"8e28db5c0e2bf50169a38aa351fdbcc842cd9673","modified":1670295455446},{"_id":"public/iconfont/iconfont.eot","hash":"ec8e59b46aee56ebd3fd4bc891fa89b141f8dd77","modified":1670295455446},{"_id":"public/iconfont/iconfont.svg","hash":"39b05213c87755919dd16144be63e288c58d9e81","modified":1670295455446},{"_id":"public/iconfont/iconfont.ttf","hash":"434a4874aca648921248884536c3bf3e15e8ff46","modified":1670295455446},{"_id":"public/iconfont/iconfont.woff","hash":"97b0996a861db6fdbbc35f40319580273604404b","modified":1670295455446},{"_id":"public/iconfont/iconfont.woff2","hash":"7ef38c1ebe016f9431f1ef5e9ee7348b38a3a3a9","modified":1670295455446},{"_id":"public/images/avatar.png","hash":"ea85d371631b34984022817ab63449fb297a2a93","modified":1670295455446},{"_id":"public/images/favicon.png","hash":"7ac208a08013a1dbfa19253602b05b84095310b0","modified":1670295455446},{"_id":"public/img/post3_1.png","hash":"02c1f6c63c1c4a54820c514158fa7298445471dd","modified":1670295455446},{"_id":"public/css/base.css","hash":"823cd020f9ab198105689f3aa02c0c0cbd60f5dc","modified":1670295455446},{"_id":"public/css/common.css","hash":"5a3e4c477645aa8e557d3e680924b327a0a0f625","modified":1670295455446},{"_id":"public/css/github-markdown.css","hash":"f78aa3fbbcc5cceab0ee67246b55db8b982c4634","modified":1670295455446},{"_id":"public/css/highlight.css","hash":"22c32290b22589e69f53cbbd632c77bf398f2130","modified":1670295455446},{"_id":"public/css/index.css","hash":"5d4d3b2b286ae9b45cd060698060cdbd0571eed9","modified":1670295455446},{"_id":"public/css/post.css","hash":"02736e416b73bd0dbda7d2f8d22d31fb7a3386a1","modified":1670295455446},{"_id":"public/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1670295455446},{"_id":"public/iconfont/iconfont.css","hash":"bd5cee4f45e9e3803107ecc6add2d54387246c01","modified":1670295455446},{"_id":"public/iconfont/iconfont.json","hash":"c4410acbaeba94ff0d48d1e2ccddf49213b40626","modified":1670295455446},{"_id":"public/js/backtotop.js","hash":"7d31a9b613dcaa88e0f4154a62cd0fb2cfe598e8","modified":1670295455446},{"_id":"public/js/fancybox.js","hash":"b217d56f8db94498d7e272d164abac6ab1c07ddd","modified":1670295455446},{"_id":"public/js/search.js","hash":"21c1e736a60de5243742272a7009b47fa1a6ecee","modified":1670295455446},{"_id":"public/iconfont/demo_index.html","hash":"db375ad1f08ed3eeeb455771fca147838394551a","modified":1670295455446},{"_id":"public/iconfont/iconfont.js","hash":"55c291a13445c03d566ac8436103a72806d212a5","modified":1670295455446},{"_id":"source/_posts/222.md","hash":"9756cb2ecbde649a1a2b3a5fe38dff8869da64da","modified":1672382702115},{"_id":"public/archives/2022/12/index.html","hash":"b4dd4d776aa8bdfd4a49938bfb3111dc05b222c8","modified":1672726627620},{"_id":"public/post/222.html","hash":"2854f5e662912ed08b8f6670fb6d5dc788b6df62","modified":1672382712448},{"_id":"source/img/123.png","hash":"7ce527ce0c45087929b3d8ddc3f8216f7f0f8c23","modified":1672381017710},{"_id":"public/img/123.png","hash":"7ce527ce0c45087929b3d8ddc3f8216f7f0f8c23","modified":1672381119856},{"_id":"source/img/23.jpeg","hash":"a12e9e4b5ed6d177ced8f0e5b77457f2f651c834","modified":1672382563708},{"_id":"source/img/24.png","hash":"d93e8f8cb41fdf6e66c3c6b4f4d169ead0011628","modified":1672382662158},{"_id":"source/img/123456.png","hash":"d9bbca76c3d8aa34712d9d7494d1afd54a8eeee8","modified":1672382503315},{"_id":"source/img/1234.png","hash":"107ddb55c7a73a43da9f9bbbc805e07524c77af1","modified":1672381845159},{"_id":"source/img/12345.png","hash":"c1fdab9896d096838a3916e7b72a5439008b3ce1","modified":1672382009100},{"_id":"public/img/23.jpeg","hash":"a12e9e4b5ed6d177ced8f0e5b77457f2f651c834","modified":1672382712448},{"_id":"public/img/123456.png","hash":"d9bbca76c3d8aa34712d9d7494d1afd54a8eeee8","modified":1672382712448},{"_id":"public/img/24.png","hash":"d93e8f8cb41fdf6e66c3c6b4f4d169ead0011628","modified":1672382712448},{"_id":"public/img/1234.png","hash":"107ddb55c7a73a43da9f9bbbc805e07524c77af1","modified":1672382712448},{"_id":"public/img/12345.png","hash":"c1fdab9896d096838a3916e7b72a5439008b3ce1","modified":1672382712448},{"_id":"source/_posts/Sui Concept and Testnet.md","hash":"0eb6c8b0a9ad2524e1120c4f32053967264cf4e3","modified":1672385204865},{"_id":"source/img/27.png","hash":"eab8d3d94cbd943c3c6f377330d1d105eb0e99c9","modified":1672382982360},{"_id":"source/img/28.png","hash":"1b117e61314ec2d9effc35d7ccc96ea4eda61974","modified":1672383311980},{"_id":"source/img/31.png","hash":"ec3469082a95eed4d56e5eddbb9d28421c1a64f1","modified":1672383491026},{"_id":"source/img/25.png","hash":"db806d4b8e038c3f915d672b5678f2d167c57671","modified":1672382782771},{"_id":"source/img/26.png","hash":"14f3d8827dc2d2418af9acac0d8e1044bcb5fa3c","modified":1672382921031},{"_id":"source/img/30.png","hash":"cba4945d65c3f5910bbadfea6c0168843dc4ca9d","modified":1672383435526},{"_id":"source/img/33.png","hash":"b2267e166183c1b7618ead9fdcad583e14556005","modified":1672383555651},{"_id":"public/post/Sui Concept and Testnet.html","hash":"3c59c518c8bbc2c245560c39bfb4417cc5e006bc","modified":1672726627620},{"_id":"public/img/27.png","hash":"eab8d3d94cbd943c3c6f377330d1d105eb0e99c9","modified":1672383974299},{"_id":"public/img/28.png","hash":"1b117e61314ec2d9effc35d7ccc96ea4eda61974","modified":1672383974299},{"_id":"public/img/31.png","hash":"ec3469082a95eed4d56e5eddbb9d28421c1a64f1","modified":1672383974299},{"_id":"public/img/25.png","hash":"db806d4b8e038c3f915d672b5678f2d167c57671","modified":1672383974299},{"_id":"public/img/26.png","hash":"14f3d8827dc2d2418af9acac0d8e1044bcb5fa3c","modified":1672383974299},{"_id":"public/img/30.png","hash":"cba4945d65c3f5910bbadfea6c0168843dc4ca9d","modified":1672383974299},{"_id":"public/img/33.png","hash":"b2267e166183c1b7618ead9fdcad583e14556005","modified":1672383974299},{"_id":"source/_posts/02-Bootstrap of Sui local testnet 7860ec878e8f42c98a7c754b3afd2d30.md","hash":"b785a31819e2615a77466c6f6d9640b1fbac7d7f","modified":1672729583320},{"_id":"source/img/300.jpeg","hash":"373c45b32d6586d6d14299615eda898cbf8312dc","modified":1672726388368},{"_id":"public/archives/2023/index.html","hash":"0e0fa125a9c1d817ba5330b735d3933dc39f76dd","modified":1672726627620},{"_id":"public/archives/2023/01/index.html","hash":"e14f4f5f401717a3ab68020bd002ae45344a39d5","modified":1672726627620},{"_id":"public/tags/Sui-blockchain-Sui-Move-Language/index.html","hash":"1876f3d2a5ae37696eb7fd63cf2d494acc037dae","modified":1672726627620},{"_id":"public/tags/SuiEcosystem-MoveLang/index.html","hash":"7f6633fdc99da607d79a79a36af14f78565ba2c7","modified":1672726627620},{"_id":"public/post/02-Bootstrap of Sui local testnet 7860ec878e8f42c98a7c754b3afd2d30.html","hash":"a6dbe19c79d520557ef6cc03e5e2b9996f491800","modified":1672729606248},{"_id":"public/img/300.jpeg","hash":"373c45b32d6586d6d14299615eda898cbf8312dc","modified":1672726627620},{"_id":"source/img/300.png","hash":"373c45b32d6586d6d14299615eda898cbf8312dc","modified":1672727006192},{"_id":"source/img/305.png","hash":"f89ea4a9cafad61022471f73efcc0acbd0032b7d","modified":1672728406889},{"_id":"source/img/302.png","hash":"71d60a9113e7ff147e6b332ae6ff30a12344e3dd","modified":1672727702635},{"_id":"source/img/301.png","hash":"d3288ccf6d83a9a15d68f3235ba0718bb01b05cf","modified":1672727315119},{"_id":"source/img/303.png","hash":"ce654c013fc02a2091898e2777b0f01dba4cffc0","modified":1672727880868},{"_id":"source/img/304.png","hash":"66bb16a4ee7c06cb4f9e78fa200f19ab764f33a4","modified":1672728227573},{"_id":"public/img/300.png","hash":"373c45b32d6586d6d14299615eda898cbf8312dc","modified":1672728479223},{"_id":"public/img/301.png","hash":"d3288ccf6d83a9a15d68f3235ba0718bb01b05cf","modified":1672728479223},{"_id":"public/img/305.png","hash":"f89ea4a9cafad61022471f73efcc0acbd0032b7d","modified":1672728479223},{"_id":"public/img/302.png","hash":"71d60a9113e7ff147e6b332ae6ff30a12344e3dd","modified":1672728479223},{"_id":"public/img/303.png","hash":"ce654c013fc02a2091898e2777b0f01dba4cffc0","modified":1672728479223},{"_id":"public/img/304.png","hash":"66bb16a4ee7c06cb4f9e78fa200f19ab764f33a4","modified":1672728479223},{"_id":"source/img/306.png","hash":"d3288ccf6d83a9a15d68f3235ba0718bb01b05cf","modified":1672728646375},{"_id":"source/img/308.png","hash":"de5d1ed5c38f84d64c5ae73252932d61eca3d24e","modified":1672728865997},{"_id":"public/img/306.png","hash":"d3288ccf6d83a9a15d68f3235ba0718bb01b05cf","modified":1672729176035},{"_id":"public/img/308.png","hash":"de5d1ed5c38f84d64c5ae73252932d61eca3d24e","modified":1672729176035}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2022-09-27T01:47:49.000Z","_content":"\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-09-27 09:47:49\n---\n\n","updated":"2022-12-05T09:52:03.530Z","path":"about/index.html","comments":1,"layout":"page","_id":"clbbmsdzb00006b7l8ol3gc8i","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Verify Smart Contracts in Aptos with the Move Prover Pt.1","date":"2022-09-27T08:53:50.000Z","description":"It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts","thumbnail":"/img/icon.png","_content":"\n*Xudong Wang  & 0xyi* 09-14-2022\n\n\nIt has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?\n\nWe will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. \n\nFor this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.\n\n\n## What is the Move Prover\n\nFormal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.\nNow it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.\n\nSmart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.\n**Move Prover (MVP)** is designed to prevent bugs in smart contracts written in the Move language.\n\nIn Aptos ( and Starcoin/Sui ), Users can specify functional properties of smart contracts using the **Move Specification Language (MSL)**, and then use the Move Prover to automatically and statically inspect them.\n\nSimply put, there can be two components in a Move file:\n\n- Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.\n\n- The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.\n\nWhen we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.\n\n## Install Prover dependencies in Aptos\n\nBefore using the Move Prover, let's install some of its external dependencies.\nIt is assumed that you already have [installed Aptos CLI](https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli).\nMake sure you did \"Step 3\" and installed the dependencies of the Move Prover:\n\n```bash\n./scripts/dev_setup.sh -yp\n. ~/.profile\n```\n\nWhen the above command is executed, enter `boogie /version`, if the output is similar to \"Boogie program verifier version X.X.X\", then the installation has been successful.\n\nNote that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).\nWindows users can run it by installing [WSL](https://docs.microsoft.com/en-us/windows/wsl/install).\n\n## Prepare an example for verification in \n\n### Project creation\n\nFirst, let's create a new empty Move package:\n\n```bash\nmkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin\n```\n\nYou can see that its directory structure is as follows:\n\n```\nbasic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    `---- sources   (Directory)\n```\n\n### Module code\n\nNow create `basic_coin/sources/BasicCoin.move`.\n\n<details>\n<summary> BasicCoin.move content</summary>\n\n```rust\n/// This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin {\n    use std::error;\n    use std::signer;\n\n    /// Error codes\n    const ENOT_MODULE_OWNER: u64 = 0;\n    const EINSUFFICIENT_BALANCE: u64 = 1;\n    const EALREADY_HAS_BALANCE: u64 = 2;\n\n    struct Coin<phantom CoinType> has store {\n        value: u64\n    }\n\n    struct Balance<phantom CoinType> has key {\n        coin: Coin<CoinType>\n    }\n\n    /// Publish an empty balance resource under `account`'s address. This function must be called before\n    /// minting or transferring to the account.\n    public fun publish_balance<CoinType>(account: &signer) {\n        let empty_coin = Coin<CoinType> { value: 0 };\n        assert!(!exists<Balance<CoinType>>(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance<CoinType> { coin:  empty_coin });\n    }\n\n    /// Mint `amount` tokens to `mint_addr`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can decide the minting policy.\n    public fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance {\n        // Deposit `total_value` amount of tokens to mint_addr's balance\n        deposit(mint_addr, Coin<CoinType> { value: amount });\n    }\n\n    public fun balance_of<CoinType>(owner: address): u64 acquires Balance {\n        borrow_global<Balance<CoinType>>(owner).coin.value\n    }\n\n    /// Transfers `amount` of tokens from `from` to `to`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can  decide the transferring policy.\n    public fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance {\n        let addr_from = signer::address_of(from);\n        let check = withdraw<CoinType>(addr_from, amount);\n        deposit<CoinType>(to, check);\n    }\n\n    fun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance {\n        let balance = balance_of<CoinType>(addr);\n        assert!(balance >= amount, EINSUFFICIENT_BALANCE);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        *balance_ref = balance - amount;\n        Coin<CoinType> { value: amount }\n    }\n    \n    fun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance{\n        let balance = balance_of<CoinType>(addr);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        let Coin { value } = check;\n        *balance_ref = balance + value;\n    }\n}\n```\n\n</details>\n\nHere we assume that you have a certain grasp of the Move language, and can understand the source code of `BasicCoin.move` above and know the function of each part.\n\n### TOML configuration\n\nBasicCoin uses some facilities of the Aptos standard library, and also needs to add `aptos-framework` to the dependencies. We also need to specify what numerical address it should be replaced with. \n\nTherefore, we modify Move.toml as follows:\n\n```toml\n[package]\nname = \"BasicCoin\"\nversion = \"0.0.0\"\n\n[dependencies]\nAptosFramework = { git = \"https://github.com/aptos-labs/aptos-core.git\", subdir = \"aptos-move/framework/aptos-framework/\", rev = \"main\" }\n\n[addresses]\nBasicCoin=\"Replace_It_With_Your_Numerical_Address\"  \n\n```\n\n## The first verification code\n\nTo give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n}\n```\n\nSyntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the `balance_of` function in order to clearly see the correspondence between the definition and the specification when reading the code.\n\nSimply put, the `spec balance_of {...}` block will contain our **property specification** for the `balance_of` function.\nThere are many types of property specifications, some common examples are:\n\n- Will this function abort? Under what circumstances does it abort?\n- What conditions must be met for the parameters to call this function?\n- What is the return value of this function?\n- After the function is executed, how will the state of the virtual machine be changed?\n- What invariants does this function maintain?\n\nFor example, the Move Prover allows all possible aborts by default when we don't give any abort conditions.\nAnd in the simple snippet above, we tell Prover with the directive `aborts_if_is_strict`:\n\n> I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.\n\nNow, we run the `prove` command in the `basic_coin` directory:\n\n```bash\naptos move prove\n```\nit will call the Move Prover to check the code in the package.\nThen we can see the Prover reporting the following error message:\n\n```\nerror: abort not covered by any of the `aborts_if` clauses\n   ┌─ ./sources/BasicCoin.move:38:5\n   │\n35 │           borrow_global<Balance<CoinType>>(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of {\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     }\n   │ ╰─────^\n   │\n   =     at ./sources/BasicCoin.move:34: balance_of\n   =         owner = 0x29\n   =     at ./sources/BasicCoin.move:35: balance_of\n   =         ABORTED\n\nFAILURE proving 1 modules from package `basic_coin` in 1.794s\n{\n  \"Error\": \"Move Prover failed: exiting with verification errors\"\n}\n```\n\nProver's output tells us that it found a situation where the `balance_of` function aborts, but we don't explicitly point out the possibility of such aborts.\nLooking at the code that triggers the abort, we can see that the exception is caused by calling the built-in `borrow_global` function when the `owner` does not own a resource of type `Balance<CoinType>`.\nFollowing the guidance of the error message, we can add the following `aborts_if` condition:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n    aborts_if !exists<Balance<CoinType>>(owner);\n}\n```\n\nAfter adding this condition, try calling Prover again and see that there are no more validation errors.\nNow we can confidently confirm that the `balance_of` function has one and only one possibility of abnormal termination, that is, the parameter `owner` does not own a resource of type `Balance<CoinType>`.\n\n## Verify withdraw function\n\nThe signature of the function `withdraw` is as follows:\n\n```rust\nfun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance\n```\n\nIts role is to withdraw the `amount` of coins from the address `addr` and return it.\n\n### Specify the abort condition for `withdraw`\n\nThere are two possibilities for `withdraw` to abort:\n\n1. No resource of type `Balance<CoinType>` in `addr`.\n2. The balance in `addr` is less than `amount`.\n\nFrom these, we can define the abort condition like this:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n}\n```\n\n- A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.\n`global<T>(addr): T` is a built-in function that returns a resource of type `T` at address `addr`.\nHere, we set balance to the number of tokens owned by addr via the let binding;\n- `exists<T>(address): bool` is a built-in function that returns true if resource `T` exists at address `addr`; otherwise returns false.\n\nThe two lines of `aborts_if` statements correspond to the two conditions mentioned above.\nIn general, if a function has multiple `aborts_if` conditions, the conditions are ORed together.\n\nAs mentioned earlier, if we don't specify any abort conditions, Prover will not impose any restrictions on aborts.\nBut once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction `pragma aborts_if_is_strict`.\nIf only some of the conditions for abnormal exit are listed, the Prover will report a validation error.\nHowever, if the `pragma aborts_if_is_partial` is defined in the spec block, this is equivalent to telling the Prover:\n\n> I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.\n\nIf you are interested, you can do such a set of experiments to verify:\n\n- When deleting any of the above two `aborts_if` conditions, Prover will report an error;\n- When all `aborts_if` conditions are deleted at the same time, Prover will not report an error;\n- When adding `pragma aborts_if_is_partial`, no matter how many `aborts_if` conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).\n\nSome readers may be curious about the order of the three statements in the spec block:\nWhy the definition of balance can be written after `aborts_if !exists<Balance<CoinType>>(addr)`.\nBecause, if the latter holds true, `balance` does not actually exist.\nWouldn't this order cause the Prover to fail?\nSimply put: no, the statements in the spec block are declarative and the order doesn't matter.\n\nFor a more detailed understanding, you can refer to the MSL documentation for more information.\n\n### Specify the functional nature of `withdraw`\n\nNext, we define functional properties.\nThe two `ensures` statements in the following spec block give us what we expect from the `withdraw` functionality:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n    ensures result == Coin<CoinType> { value: amount };\n}\n```\n\nIn this code, first by using `let post` binding, define `balance_post` as the balance of `addr` after the function is executed, it should be equal to `balance - amount`. Then, `result` is a special name that represents the return value, which should be the `amount` of tokens.\n\n## Verify the `deposit` function\n\nThe signature of the function deposit is as follows:\n\n```rust\nfun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance\n```\n\nIt deposits the token funds indicated by `check` into the address `addr`. Its canonical definition is as follows:\n\n```rust\nspec deposit {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    let check_value = check.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + check_value > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + check_value;\n}\n```\n\nHere, `balance` is defined as the balance in `addr` before the function is executed, and `check_value` is defined as the amount of tokens to be deposited. It will abort in two cases:\n\n1. There is no resource of type `Balance<CoinType>` in `addr`;\n2. Or the sum of `balance` and `check_value` is greater than the maximum value of type `u64`.\n\nThe `ensures` statement is used to let the Prover make sure that in any case, the balance in `addr` can be updated correctly after the function is executed.\n\nThe syntax mentioned earlier will not be repeated here.\nAstute readers may have noticed that it is worth noting that the expression `balance + check_value > MAX_U64` is problematic in the Move program.\nBecause the addition on the left may cause an overflow exception.\nIf we want to write a similar check in the Move program, we should use an expression like `balance > MAX_U64 - check_value` to avoid the overflow problem.\n\nHowever, this expression is perfectly fine in the Move Specification Language (MSL).\nSince the spec block uses the MSL language, its type system is different from that of Move.\nIn MSL, all integers are of type `num`, which is an integer in the mathematical sense. That is, it is signed and has no size limit.\nAll built-in integer types (`u8`, `u64`, etc.) are automatically converted to type `num` when referencing data in a Move program in MSL.\nA more detailed description of the type system can be found in the MSL documentation.\n\n## Verify the `transfer` function\n\nThe signature of the function `transfer` is as follows:\n\n```rust\npublic fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for the transfer `from` the account from to the address `to`, and the transfer amount is `amount`.\n\nLet's ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:\n\n```rust\nspec transfer {\n    let addr_from = signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n```\n\nHere `from` is of type `signer`, not a direct address.\nAlthough in the program we have created a local variable called `addr_from`, we cannot directly reference it in the spec block.\nAt the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to `addr_from` again.\nThen use `let` and `let post` to define several variables, corresponding to the balances in the two addresses `addr_from` and `to` before and after the function is executed.\nFinally, use the `ensures` statement to tell Prover that the balance in `from` should be subtracted by `amount`; the balance in `to` should be increased by `amount`.\n\nAt first glance, there seems to be no problem at all. But is it really so?\nLet's see if Prover thinks this is \"the correct description of the behavior of this function\".\nAfter typing `aptos move prove` you can see:\n\n```\nerror: post-condition does not hold\n   ┌─ ./sources/BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post == balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   =     at ./sources/BasicCoin.move:45: transfer\n   =     at ./sources/BasicCoin.move:51: transfer (spec)\n   =     at ./sources/BasicCoin.move:53: transfer (spec)\n   =     at ./sources/BasicCoin.move:54: transfer (spec)\n   =     at ./sources/BasicCoin.move:45: transfer\n   =         from = signer{0x0}\n   =         to = 0x0\n   =         amount = 1\n   =         _witness = <generic>\n```\n\nIt is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the `transfer` function.\nWhy is this so? Let's look down again: the parameters that make the postconditions not satisfied are `from = signer{0x0}` and `to = 0x0`. We should know the reason: when the account transfers money to itself, both `to` and `from` point to the same address, so the balance does not change.\n\nThere are two solutions now:\n\n**Plan A** does not modify the function definition, but changes the specification.\nIn the spec block, consider whether the two accounts for the transfer and receiving are the same address.\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures (addr_from == to && eq_post) || (addr_from != to && ne_post);\n```\n\nOr use another slightly more intuitive if syntax:\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures if (addr_from == to) eq_post else ne_post;\n```\n\nNote that `if (P) E1 else E2` is not the same as conditional execution in program logic -- it's actually a syntactic sugar equivalent to `ensures` both `P ==> E1` and `!P ==> E2`.\nAnd `p ==> q` is actually `!p || q`.\n\nThat is to say, the end of the second way of writing actually represents this logic:\n\n```rust\nensures (addr_from == to  ===>  eq_post) && (addr_from != to  ===> ne_post);\n```\n\nthat is:\n\n```rust\nensures (addr_from != to || eq_post) && (addr_from == to  || ne_post);\n```\n\nInterested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former `(addr_from == to && eq_post) || (addr_from != to && ne_post)` and the latter `(addr_from != to || eq_post) && (addr_from == to  || ne_post)` are actually exactly equivalent expressions.\n\n**Plan B** does not modify the spec, but directly adds `assert!(addr_from != to, EEQUAL_ADDR);` in the function body, and adds the definition of the error code `EEQUAL_ADDR` in front, so that the self-transfer transaction cannot be completed.\n\nObviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.\nSo plan B is a better practice.\nIt directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.\n\n### Practice\n\nCurrently, we have only completed functional verification of the `transfer` function.\nBut it doesn't say under what circumstances it will abort.\nAs an exercise, give it an appropriate `aborts_if` condition. The answer can be found in our next article.\n\n## Verify mint function\n\nThe signature of the function `mint` is as follows:\n\n```rust\npublic fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for minting the `amount` of tokens and depositing them in the address `mint_addr`.\nMore interesting is `_witness`, which is of type `CoinType`.\nBecause only the module that defines the `CoinType` can construct a value of this type, this guarantees the identity of the caller.\n\nThere is actually only one call to `deposit` in the `mint` function.\nIt is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:\n\n```rust\nspec mint {\n    let balance = global<Balance<CoinType>>(mint_addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(mint_addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(mint_addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\n## Verify the `publish_balance` function\n\nThe signature of the function `publish_balance` is as follows:\n\n```rust\npublic fun publish_balance<CoinType>(account: &signer)\n```\n\nIt publishes an empty `Balance<CoinType>` resource under `account`.\nSo if the resource already exists it should exit abnormally, and end normally the balance should be zero:\n\n```rust\nspec publish_balance {\n    let addr = signer::address_of(account);\n    aborts_if exists<Balance<CoinType>>(addr);\n\n    ensures exists<Balance<CoinType>>(addr);\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == 0;\n}\n```\n\n## Simplify redundant specifications with Schema\n\nCongratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.\nHowever, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.\n\nSchema is a means of building a specification by grouping properties.\nSemantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.\n\n### Eliminate simple repetitions\n\nAs a most obvious example, the spec blocks of `mint` and `deposit` are a little different except for the variable names (in terms, they are [alpha convertible](https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion)), and the overall structure can be said to be exactly the same.\nTo simplify them, let's create a Schema:\n\n```rust\nspec schema DepositSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\nThis Schema declares two typed variables, and some conditions about what those variables should satisfy.\nWhen other places want to use this Schema, use `include DepositSchema {addr: XX, amount: YY}` to import it.\nwhere `XX` and `YY` are expressions used to replace `addr` and `amount`.\nIf the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.\n\nWith the above Schema definition, we can now simplify the previous spec:\n\n```rust\nspec mint {\n  include DepositSchema<CoinType> {addr: mint_addr};\n}\n// ....\nspec deposit {\n    include DepositSchema<CoinType> {amount: check.value};\n}\n```\n\n### Practice\n\nIn addition to the above example, find another spec block (such as `publish_balance`), and split it into a Schema declaration and a spec block that uses the corresponding Schema.\nAs an exercise, the Schema you created might not be available in this code, so it doesn't feel like there's a benefit to it.\nBut if in the later development, there are other functions that call `publish_balance`, it will be more convenient.\n\n\n## Conclusion\n\nIn our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore \n\n* the tips and best practices; \n* a more complicated case study using the Move Prover; \n* the limitation of the current version of the Move Prover, and its future outlook; \n\nSo stay tuned!\n\nMore and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please [fill out our contact form](https://www.movebit.xyz/#contact). We’d be happy to help.\n\n## About Us\n\n[MoveBit](https://www.movebit.xyz/) is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. \n\n\n### References\n\n* [Move tutorial]( https://github.com/move-language/move/tree/main/language/documentation/tutorial/) by the Move team\n* [Starocin Move Prover tutorial]( https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/) by Xudong Wang","source":"_posts/move-prover-tutorial-part-1.md","raw":"---\ntitle: Verify Smart Contracts in Aptos with the Move Prover Pt.1\ndate: 2022-09-27 16:53:50\ntags: move prover, m\ndescription: It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts\nthumbnail: /img/icon.png\n---\n\n*Xudong Wang  & 0xyi* 09-14-2022\n\n\nIt has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?\n\nWe will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. \n\nFor this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.\n\n\n## What is the Move Prover\n\nFormal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.\nNow it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.\n\nSmart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.\n**Move Prover (MVP)** is designed to prevent bugs in smart contracts written in the Move language.\n\nIn Aptos ( and Starcoin/Sui ), Users can specify functional properties of smart contracts using the **Move Specification Language (MSL)**, and then use the Move Prover to automatically and statically inspect them.\n\nSimply put, there can be two components in a Move file:\n\n- Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.\n\n- The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.\n\nWhen we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.\n\n## Install Prover dependencies in Aptos\n\nBefore using the Move Prover, let's install some of its external dependencies.\nIt is assumed that you already have [installed Aptos CLI](https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli).\nMake sure you did \"Step 3\" and installed the dependencies of the Move Prover:\n\n```bash\n./scripts/dev_setup.sh -yp\n. ~/.profile\n```\n\nWhen the above command is executed, enter `boogie /version`, if the output is similar to \"Boogie program verifier version X.X.X\", then the installation has been successful.\n\nNote that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).\nWindows users can run it by installing [WSL](https://docs.microsoft.com/en-us/windows/wsl/install).\n\n## Prepare an example for verification in \n\n### Project creation\n\nFirst, let's create a new empty Move package:\n\n```bash\nmkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin\n```\n\nYou can see that its directory structure is as follows:\n\n```\nbasic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    `---- sources   (Directory)\n```\n\n### Module code\n\nNow create `basic_coin/sources/BasicCoin.move`.\n\n<details>\n<summary> BasicCoin.move content</summary>\n\n```rust\n/// This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin {\n    use std::error;\n    use std::signer;\n\n    /// Error codes\n    const ENOT_MODULE_OWNER: u64 = 0;\n    const EINSUFFICIENT_BALANCE: u64 = 1;\n    const EALREADY_HAS_BALANCE: u64 = 2;\n\n    struct Coin<phantom CoinType> has store {\n        value: u64\n    }\n\n    struct Balance<phantom CoinType> has key {\n        coin: Coin<CoinType>\n    }\n\n    /// Publish an empty balance resource under `account`'s address. This function must be called before\n    /// minting or transferring to the account.\n    public fun publish_balance<CoinType>(account: &signer) {\n        let empty_coin = Coin<CoinType> { value: 0 };\n        assert!(!exists<Balance<CoinType>>(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance<CoinType> { coin:  empty_coin });\n    }\n\n    /// Mint `amount` tokens to `mint_addr`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can decide the minting policy.\n    public fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance {\n        // Deposit `total_value` amount of tokens to mint_addr's balance\n        deposit(mint_addr, Coin<CoinType> { value: amount });\n    }\n\n    public fun balance_of<CoinType>(owner: address): u64 acquires Balance {\n        borrow_global<Balance<CoinType>>(owner).coin.value\n    }\n\n    /// Transfers `amount` of tokens from `from` to `to`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can  decide the transferring policy.\n    public fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance {\n        let addr_from = signer::address_of(from);\n        let check = withdraw<CoinType>(addr_from, amount);\n        deposit<CoinType>(to, check);\n    }\n\n    fun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance {\n        let balance = balance_of<CoinType>(addr);\n        assert!(balance >= amount, EINSUFFICIENT_BALANCE);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        *balance_ref = balance - amount;\n        Coin<CoinType> { value: amount }\n    }\n    \n    fun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance{\n        let balance = balance_of<CoinType>(addr);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        let Coin { value } = check;\n        *balance_ref = balance + value;\n    }\n}\n```\n\n</details>\n\nHere we assume that you have a certain grasp of the Move language, and can understand the source code of `BasicCoin.move` above and know the function of each part.\n\n### TOML configuration\n\nBasicCoin uses some facilities of the Aptos standard library, and also needs to add `aptos-framework` to the dependencies. We also need to specify what numerical address it should be replaced with. \n\nTherefore, we modify Move.toml as follows:\n\n```toml\n[package]\nname = \"BasicCoin\"\nversion = \"0.0.0\"\n\n[dependencies]\nAptosFramework = { git = \"https://github.com/aptos-labs/aptos-core.git\", subdir = \"aptos-move/framework/aptos-framework/\", rev = \"main\" }\n\n[addresses]\nBasicCoin=\"Replace_It_With_Your_Numerical_Address\"  \n\n```\n\n## The first verification code\n\nTo give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n}\n```\n\nSyntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the `balance_of` function in order to clearly see the correspondence between the definition and the specification when reading the code.\n\nSimply put, the `spec balance_of {...}` block will contain our **property specification** for the `balance_of` function.\nThere are many types of property specifications, some common examples are:\n\n- Will this function abort? Under what circumstances does it abort?\n- What conditions must be met for the parameters to call this function?\n- What is the return value of this function?\n- After the function is executed, how will the state of the virtual machine be changed?\n- What invariants does this function maintain?\n\nFor example, the Move Prover allows all possible aborts by default when we don't give any abort conditions.\nAnd in the simple snippet above, we tell Prover with the directive `aborts_if_is_strict`:\n\n> I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.\n\nNow, we run the `prove` command in the `basic_coin` directory:\n\n```bash\naptos move prove\n```\nit will call the Move Prover to check the code in the package.\nThen we can see the Prover reporting the following error message:\n\n```\nerror: abort not covered by any of the `aborts_if` clauses\n   ┌─ ./sources/BasicCoin.move:38:5\n   │\n35 │           borrow_global<Balance<CoinType>>(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of {\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     }\n   │ ╰─────^\n   │\n   =     at ./sources/BasicCoin.move:34: balance_of\n   =         owner = 0x29\n   =     at ./sources/BasicCoin.move:35: balance_of\n   =         ABORTED\n\nFAILURE proving 1 modules from package `basic_coin` in 1.794s\n{\n  \"Error\": \"Move Prover failed: exiting with verification errors\"\n}\n```\n\nProver's output tells us that it found a situation where the `balance_of` function aborts, but we don't explicitly point out the possibility of such aborts.\nLooking at the code that triggers the abort, we can see that the exception is caused by calling the built-in `borrow_global` function when the `owner` does not own a resource of type `Balance<CoinType>`.\nFollowing the guidance of the error message, we can add the following `aborts_if` condition:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n    aborts_if !exists<Balance<CoinType>>(owner);\n}\n```\n\nAfter adding this condition, try calling Prover again and see that there are no more validation errors.\nNow we can confidently confirm that the `balance_of` function has one and only one possibility of abnormal termination, that is, the parameter `owner` does not own a resource of type `Balance<CoinType>`.\n\n## Verify withdraw function\n\nThe signature of the function `withdraw` is as follows:\n\n```rust\nfun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance\n```\n\nIts role is to withdraw the `amount` of coins from the address `addr` and return it.\n\n### Specify the abort condition for `withdraw`\n\nThere are two possibilities for `withdraw` to abort:\n\n1. No resource of type `Balance<CoinType>` in `addr`.\n2. The balance in `addr` is less than `amount`.\n\nFrom these, we can define the abort condition like this:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n}\n```\n\n- A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.\n`global<T>(addr): T` is a built-in function that returns a resource of type `T` at address `addr`.\nHere, we set balance to the number of tokens owned by addr via the let binding;\n- `exists<T>(address): bool` is a built-in function that returns true if resource `T` exists at address `addr`; otherwise returns false.\n\nThe two lines of `aborts_if` statements correspond to the two conditions mentioned above.\nIn general, if a function has multiple `aborts_if` conditions, the conditions are ORed together.\n\nAs mentioned earlier, if we don't specify any abort conditions, Prover will not impose any restrictions on aborts.\nBut once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction `pragma aborts_if_is_strict`.\nIf only some of the conditions for abnormal exit are listed, the Prover will report a validation error.\nHowever, if the `pragma aborts_if_is_partial` is defined in the spec block, this is equivalent to telling the Prover:\n\n> I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.\n\nIf you are interested, you can do such a set of experiments to verify:\n\n- When deleting any of the above two `aborts_if` conditions, Prover will report an error;\n- When all `aborts_if` conditions are deleted at the same time, Prover will not report an error;\n- When adding `pragma aborts_if_is_partial`, no matter how many `aborts_if` conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).\n\nSome readers may be curious about the order of the three statements in the spec block:\nWhy the definition of balance can be written after `aborts_if !exists<Balance<CoinType>>(addr)`.\nBecause, if the latter holds true, `balance` does not actually exist.\nWouldn't this order cause the Prover to fail?\nSimply put: no, the statements in the spec block are declarative and the order doesn't matter.\n\nFor a more detailed understanding, you can refer to the MSL documentation for more information.\n\n### Specify the functional nature of `withdraw`\n\nNext, we define functional properties.\nThe two `ensures` statements in the following spec block give us what we expect from the `withdraw` functionality:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n    ensures result == Coin<CoinType> { value: amount };\n}\n```\n\nIn this code, first by using `let post` binding, define `balance_post` as the balance of `addr` after the function is executed, it should be equal to `balance - amount`. Then, `result` is a special name that represents the return value, which should be the `amount` of tokens.\n\n## Verify the `deposit` function\n\nThe signature of the function deposit is as follows:\n\n```rust\nfun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance\n```\n\nIt deposits the token funds indicated by `check` into the address `addr`. Its canonical definition is as follows:\n\n```rust\nspec deposit {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    let check_value = check.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + check_value > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + check_value;\n}\n```\n\nHere, `balance` is defined as the balance in `addr` before the function is executed, and `check_value` is defined as the amount of tokens to be deposited. It will abort in two cases:\n\n1. There is no resource of type `Balance<CoinType>` in `addr`;\n2. Or the sum of `balance` and `check_value` is greater than the maximum value of type `u64`.\n\nThe `ensures` statement is used to let the Prover make sure that in any case, the balance in `addr` can be updated correctly after the function is executed.\n\nThe syntax mentioned earlier will not be repeated here.\nAstute readers may have noticed that it is worth noting that the expression `balance + check_value > MAX_U64` is problematic in the Move program.\nBecause the addition on the left may cause an overflow exception.\nIf we want to write a similar check in the Move program, we should use an expression like `balance > MAX_U64 - check_value` to avoid the overflow problem.\n\nHowever, this expression is perfectly fine in the Move Specification Language (MSL).\nSince the spec block uses the MSL language, its type system is different from that of Move.\nIn MSL, all integers are of type `num`, which is an integer in the mathematical sense. That is, it is signed and has no size limit.\nAll built-in integer types (`u8`, `u64`, etc.) are automatically converted to type `num` when referencing data in a Move program in MSL.\nA more detailed description of the type system can be found in the MSL documentation.\n\n## Verify the `transfer` function\n\nThe signature of the function `transfer` is as follows:\n\n```rust\npublic fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for the transfer `from` the account from to the address `to`, and the transfer amount is `amount`.\n\nLet's ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:\n\n```rust\nspec transfer {\n    let addr_from = signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n```\n\nHere `from` is of type `signer`, not a direct address.\nAlthough in the program we have created a local variable called `addr_from`, we cannot directly reference it in the spec block.\nAt the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to `addr_from` again.\nThen use `let` and `let post` to define several variables, corresponding to the balances in the two addresses `addr_from` and `to` before and after the function is executed.\nFinally, use the `ensures` statement to tell Prover that the balance in `from` should be subtracted by `amount`; the balance in `to` should be increased by `amount`.\n\nAt first glance, there seems to be no problem at all. But is it really so?\nLet's see if Prover thinks this is \"the correct description of the behavior of this function\".\nAfter typing `aptos move prove` you can see:\n\n```\nerror: post-condition does not hold\n   ┌─ ./sources/BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post == balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   =     at ./sources/BasicCoin.move:45: transfer\n   =     at ./sources/BasicCoin.move:51: transfer (spec)\n   =     at ./sources/BasicCoin.move:53: transfer (spec)\n   =     at ./sources/BasicCoin.move:54: transfer (spec)\n   =     at ./sources/BasicCoin.move:45: transfer\n   =         from = signer{0x0}\n   =         to = 0x0\n   =         amount = 1\n   =         _witness = <generic>\n```\n\nIt is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the `transfer` function.\nWhy is this so? Let's look down again: the parameters that make the postconditions not satisfied are `from = signer{0x0}` and `to = 0x0`. We should know the reason: when the account transfers money to itself, both `to` and `from` point to the same address, so the balance does not change.\n\nThere are two solutions now:\n\n**Plan A** does not modify the function definition, but changes the specification.\nIn the spec block, consider whether the two accounts for the transfer and receiving are the same address.\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures (addr_from == to && eq_post) || (addr_from != to && ne_post);\n```\n\nOr use another slightly more intuitive if syntax:\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures if (addr_from == to) eq_post else ne_post;\n```\n\nNote that `if (P) E1 else E2` is not the same as conditional execution in program logic -- it's actually a syntactic sugar equivalent to `ensures` both `P ==> E1` and `!P ==> E2`.\nAnd `p ==> q` is actually `!p || q`.\n\nThat is to say, the end of the second way of writing actually represents this logic:\n\n```rust\nensures (addr_from == to  ===>  eq_post) && (addr_from != to  ===> ne_post);\n```\n\nthat is:\n\n```rust\nensures (addr_from != to || eq_post) && (addr_from == to  || ne_post);\n```\n\nInterested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former `(addr_from == to && eq_post) || (addr_from != to && ne_post)` and the latter `(addr_from != to || eq_post) && (addr_from == to  || ne_post)` are actually exactly equivalent expressions.\n\n**Plan B** does not modify the spec, but directly adds `assert!(addr_from != to, EEQUAL_ADDR);` in the function body, and adds the definition of the error code `EEQUAL_ADDR` in front, so that the self-transfer transaction cannot be completed.\n\nObviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.\nSo plan B is a better practice.\nIt directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.\n\n### Practice\n\nCurrently, we have only completed functional verification of the `transfer` function.\nBut it doesn't say under what circumstances it will abort.\nAs an exercise, give it an appropriate `aborts_if` condition. The answer can be found in our next article.\n\n## Verify mint function\n\nThe signature of the function `mint` is as follows:\n\n```rust\npublic fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for minting the `amount` of tokens and depositing them in the address `mint_addr`.\nMore interesting is `_witness`, which is of type `CoinType`.\nBecause only the module that defines the `CoinType` can construct a value of this type, this guarantees the identity of the caller.\n\nThere is actually only one call to `deposit` in the `mint` function.\nIt is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:\n\n```rust\nspec mint {\n    let balance = global<Balance<CoinType>>(mint_addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(mint_addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(mint_addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\n## Verify the `publish_balance` function\n\nThe signature of the function `publish_balance` is as follows:\n\n```rust\npublic fun publish_balance<CoinType>(account: &signer)\n```\n\nIt publishes an empty `Balance<CoinType>` resource under `account`.\nSo if the resource already exists it should exit abnormally, and end normally the balance should be zero:\n\n```rust\nspec publish_balance {\n    let addr = signer::address_of(account);\n    aborts_if exists<Balance<CoinType>>(addr);\n\n    ensures exists<Balance<CoinType>>(addr);\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == 0;\n}\n```\n\n## Simplify redundant specifications with Schema\n\nCongratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.\nHowever, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.\n\nSchema is a means of building a specification by grouping properties.\nSemantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.\n\n### Eliminate simple repetitions\n\nAs a most obvious example, the spec blocks of `mint` and `deposit` are a little different except for the variable names (in terms, they are [alpha convertible](https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion)), and the overall structure can be said to be exactly the same.\nTo simplify them, let's create a Schema:\n\n```rust\nspec schema DepositSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\nThis Schema declares two typed variables, and some conditions about what those variables should satisfy.\nWhen other places want to use this Schema, use `include DepositSchema {addr: XX, amount: YY}` to import it.\nwhere `XX` and `YY` are expressions used to replace `addr` and `amount`.\nIf the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.\n\nWith the above Schema definition, we can now simplify the previous spec:\n\n```rust\nspec mint {\n  include DepositSchema<CoinType> {addr: mint_addr};\n}\n// ....\nspec deposit {\n    include DepositSchema<CoinType> {amount: check.value};\n}\n```\n\n### Practice\n\nIn addition to the above example, find another spec block (such as `publish_balance`), and split it into a Schema declaration and a spec block that uses the corresponding Schema.\nAs an exercise, the Schema you created might not be available in this code, so it doesn't feel like there's a benefit to it.\nBut if in the later development, there are other functions that call `publish_balance`, it will be more convenient.\n\n\n## Conclusion\n\nIn our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore \n\n* the tips and best practices; \n* a more complicated case study using the Move Prover; \n* the limitation of the current version of the Move Prover, and its future outlook; \n\nSo stay tuned!\n\nMore and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please [fill out our contact form](https://www.movebit.xyz/#contact). We’d be happy to help.\n\n## About Us\n\n[MoveBit](https://www.movebit.xyz/) is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. \n\n\n### References\n\n* [Move tutorial]( https://github.com/move-language/move/tree/main/language/documentation/tutorial/) by the Move team\n* [Starocin Move Prover tutorial]( https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/) by Xudong Wang","slug":"move-prover-tutorial-part-1","published":1,"updated":"2022-12-05T09:52:03.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbbmsdze00016b7l1vg0hzdm","content":"<p><em>Xudong Wang  &amp; 0xyi</em> 09-14-2022</p>\n<p>It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?</p>\n<p>We will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. </p>\n<p>For this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.</p>\n<h2 id=\"What-is-the-Move-Prover\"><a href=\"#What-is-the-Move-Prover\" class=\"headerlink\" title=\"What is the Move Prover\"></a>What is the Move Prover</h2><p>Formal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.<br>Now it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.</p>\n<p>Smart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.<br><strong>Move Prover (MVP)</strong> is designed to prevent bugs in smart contracts written in the Move language.</p>\n<p>In Aptos ( and Starcoin&#x2F;Sui ), Users can specify functional properties of smart contracts using the <strong>Move Specification Language (MSL)</strong>, and then use the Move Prover to automatically and statically inspect them.</p>\n<p>Simply put, there can be two components in a Move file:</p>\n<ul>\n<li><p>Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.</p>\n</li>\n<li><p>The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.</p>\n</li>\n</ul>\n<p>When we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.</p>\n<h2 id=\"Install-Prover-dependencies-in-Aptos\"><a href=\"#Install-Prover-dependencies-in-Aptos\" class=\"headerlink\" title=\"Install Prover dependencies in Aptos\"></a>Install Prover dependencies in Aptos</h2><p>Before using the Move Prover, let’s install some of its external dependencies.<br>It is assumed that you already have <a href=\"https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli\">installed Aptos CLI</a>.<br>Make sure you did “Step 3” and installed the dependencies of the Move Prover:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;scripts&#x2F;dev_setup.sh -yp\n. ~&#x2F;.profile</code></pre>\n\n<p>When the above command is executed, enter <code>boogie /version</code>, if the output is similar to “Boogie program verifier version X.X.X”, then the installation has been successful.</p>\n<p>Note that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).<br>Windows users can run it by installing <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install\">WSL</a>.</p>\n<h2 id=\"Prepare-an-example-for-verification-in\"><a href=\"#Prepare-an-example-for-verification-in\" class=\"headerlink\" title=\"Prepare an example for verification in\"></a>Prepare an example for verification in</h2><h3 id=\"Project-creation\"><a href=\"#Project-creation\" class=\"headerlink\" title=\"Project creation\"></a>Project creation</h3><p>First, let’s create a new empty Move package:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin</code></pre>\n\n<p>You can see that its directory structure is as follows:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">basic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    &#96;---- sources   (Directory)</code></pre>\n\n<h3 id=\"Module-code\"><a href=\"#Module-code\" class=\"headerlink\" title=\"Module code\"></a>Module code</h3><p>Now create <code>basic_coin/sources/BasicCoin.move</code>.</p>\n<details>\n<summary> BasicCoin.move content</summary>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;&#x2F; This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin &#123;\n    use std::error;\n    use std::signer;\n\n    &#x2F;&#x2F;&#x2F; Error codes\n    const ENOT_MODULE_OWNER: u64 &#x3D; 0;\n    const EINSUFFICIENT_BALANCE: u64 &#x3D; 1;\n    const EALREADY_HAS_BALANCE: u64 &#x3D; 2;\n\n    struct Coin&lt;phantom CoinType&gt; has store &#123;\n        value: u64\n    &#125;\n\n    struct Balance&lt;phantom CoinType&gt; has key &#123;\n        coin: Coin&lt;CoinType&gt;\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Publish an empty balance resource under &#96;account&#96;&#39;s address. This function must be called before\n    &#x2F;&#x2F;&#x2F; minting or transferring to the account.\n    public fun publish_balance&lt;CoinType&gt;(account: &amp;signer) &#123;\n        let empty_coin &#x3D; Coin&lt;CoinType&gt; &#123; value: 0 &#125;;\n        assert!(!exists&lt;Balance&lt;CoinType&gt;&gt;(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance&lt;CoinType&gt; &#123; coin:  empty_coin &#125;);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Mint &#96;amount&#96; tokens to &#96;mint_addr&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can decide the minting policy.\n    public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        &#x2F;&#x2F; Deposit &#96;total_value&#96; amount of tokens to mint_addr&#39;s balance\n        deposit(mint_addr, Coin&lt;CoinType&gt; &#123; value: amount &#125;);\n    &#125;\n\n    public fun balance_of&lt;CoinType&gt;(owner: address): u64 acquires Balance &#123;\n        borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Transfers &#96;amount&#96; of tokens from &#96;from&#96; to &#96;to&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can  decide the transferring policy.\n    public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        let addr_from &#x3D; signer::address_of(from);\n        let check &#x3D; withdraw&lt;CoinType&gt;(addr_from, amount);\n        deposit&lt;CoinType&gt;(to, check);\n    &#125;\n\n    fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance &#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        assert!(balance &gt;&#x3D; amount, EINSUFFICIENT_BALANCE);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        *balance_ref &#x3D; balance - amount;\n        Coin&lt;CoinType&gt; &#123; value: amount &#125;\n    &#125;\n    \n    fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance&#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        let Coin &#123; value &#125; &#x3D; check;\n        *balance_ref &#x3D; balance + value;\n    &#125;\n&#125;</code></pre>\n\n</details>\n\n<p>Here we assume that you have a certain grasp of the Move language, and can understand the source code of <code>BasicCoin.move</code> above and know the function of each part.</p>\n<h3 id=\"TOML-configuration\"><a href=\"#TOML-configuration\" class=\"headerlink\" title=\"TOML configuration\"></a>TOML configuration</h3><p>BasicCoin uses some facilities of the Aptos standard library, and also needs to add <code>aptos-framework</code> to the dependencies. We also need to specify what numerical address it should be replaced with. </p>\n<p>Therefore, we modify Move.toml as follows:</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\">[package]\nname &#x3D; &quot;BasicCoin&quot;\nversion &#x3D; &quot;0.0.0&quot;\n\n[dependencies]\nAptosFramework &#x3D; &#123; git &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;aptos-labs&#x2F;aptos-core.git&quot;, subdir &#x3D; &quot;aptos-move&#x2F;framework&#x2F;aptos-framework&#x2F;&quot;, rev &#x3D; &quot;main&quot; &#125;\n\n[addresses]\nBasicCoin&#x3D;&quot;Replace_It_With_Your_Numerical_Address&quot;  \n</code></pre>\n\n<h2 id=\"The-first-verification-code\"><a href=\"#The-first-verification-code\" class=\"headerlink\" title=\"The first verification code\"></a>The first verification code</h2><p>To give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n&#125;</code></pre>\n\n<p>Syntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the <code>balance_of</code> function in order to clearly see the correspondence between the definition and the specification when reading the code.</p>\n<p>Simply put, the <code>spec balance_of &#123;...&#125;</code> block will contain our <strong>property specification</strong> for the <code>balance_of</code> function.<br>There are many types of property specifications, some common examples are:</p>\n<ul>\n<li>Will this function abort? Under what circumstances does it abort?</li>\n<li>What conditions must be met for the parameters to call this function?</li>\n<li>What is the return value of this function?</li>\n<li>After the function is executed, how will the state of the virtual machine be changed?</li>\n<li>What invariants does this function maintain?</li>\n</ul>\n<p>For example, the Move Prover allows all possible aborts by default when we don’t give any abort conditions.<br>And in the simple snippet above, we tell Prover with the directive <code>aborts_if_is_strict</code>:</p>\n<blockquote>\n<p>I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.</p>\n</blockquote>\n<p>Now, we run the <code>prove</code> command in the <code>basic_coin</code> directory:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">aptos move prove</code></pre>\n<p>it will call the Move Prover to check the code in the package.<br>Then we can see the Prover reporting the following error message:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: abort not covered by any of the &#96;aborts_if&#96; clauses\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:38:5\n   │\n35 │           borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of &#123;\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     &#125;\n   │ ╰─────^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:34: balance_of\n   &#x3D;         owner &#x3D; 0x29\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:35: balance_of\n   &#x3D;         ABORTED\n\nFAILURE proving 1 modules from package &#96;basic_coin&#96; in 1.794s\n&#123;\n  &quot;Error&quot;: &quot;Move Prover failed: exiting with verification errors&quot;\n&#125;</code></pre>\n\n<p>Prover’s output tells us that it found a situation where the <code>balance_of</code> function aborts, but we don’t explicitly point out the possibility of such aborts.<br>Looking at the code that triggers the abort, we can see that the exception is caused by calling the built-in <code>borrow_global</code> function when the <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.<br>Following the guidance of the error message, we can add the following <code>aborts_if</code> condition:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(owner);\n&#125;</code></pre>\n\n<p>After adding this condition, try calling Prover again and see that there are no more validation errors.<br>Now we can confidently confirm that the <code>balance_of</code> function has one and only one possibility of abnormal termination, that is, the parameter <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.</p>\n<h2 id=\"Verify-withdraw-function\"><a href=\"#Verify-withdraw-function\" class=\"headerlink\" title=\"Verify withdraw function\"></a>Verify withdraw function</h2><p>The signature of the function <code>withdraw</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance</code></pre>\n\n<p>Its role is to withdraw the <code>amount</code> of coins from the address <code>addr</code> and return it.</p>\n<h3 id=\"Specify-the-abort-condition-for-withdraw\"><a href=\"#Specify-the-abort-condition-for-withdraw\" class=\"headerlink\" title=\"Specify the abort condition for withdraw\"></a>Specify the abort condition for <code>withdraw</code></h3><p>There are two possibilities for <code>withdraw</code> to abort:</p>\n<ol>\n<li>No resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>.</li>\n<li>The balance in <code>addr</code> is less than <code>amount</code>.</li>\n</ol>\n<p>From these, we can define the abort condition like this:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n&#125;</code></pre>\n\n<ul>\n<li>A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.<br><code>global&lt;T&gt;(addr): T</code> is a built-in function that returns a resource of type <code>T</code> at address <code>addr</code>.<br>Here, we set balance to the number of tokens owned by addr via the let binding;</li>\n<li><code>exists&lt;T&gt;(address): bool</code> is a built-in function that returns true if resource <code>T</code> exists at address <code>addr</code>; otherwise returns false.</li>\n</ul>\n<p>The two lines of <code>aborts_if</code> statements correspond to the two conditions mentioned above.<br>In general, if a function has multiple <code>aborts_if</code> conditions, the conditions are ORed together.</p>\n<p>As mentioned earlier, if we don’t specify any abort conditions, Prover will not impose any restrictions on aborts.<br>But once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction <code>pragma aborts_if_is_strict</code>.<br>If only some of the conditions for abnormal exit are listed, the Prover will report a validation error.<br>However, if the <code>pragma aborts_if_is_partial</code> is defined in the spec block, this is equivalent to telling the Prover:</p>\n<blockquote>\n<p>I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.</p>\n</blockquote>\n<p>If you are interested, you can do such a set of experiments to verify:</p>\n<ul>\n<li>When deleting any of the above two <code>aborts_if</code> conditions, Prover will report an error;</li>\n<li>When all <code>aborts_if</code> conditions are deleted at the same time, Prover will not report an error;</li>\n<li>When adding <code>pragma aborts_if_is_partial</code>, no matter how many <code>aborts_if</code> conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).</li>\n</ul>\n<p>Some readers may be curious about the order of the three statements in the spec block:<br>Why the definition of balance can be written after <code>aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr)</code>.<br>Because, if the latter holds true, <code>balance</code> does not actually exist.<br>Wouldn’t this order cause the Prover to fail?<br>Simply put: no, the statements in the spec block are declarative and the order doesn’t matter.</p>\n<p>For a more detailed understanding, you can refer to the MSL documentation for more information.</p>\n<h3 id=\"Specify-the-functional-nature-of-withdraw\"><a href=\"#Specify-the-functional-nature-of-withdraw\" class=\"headerlink\" title=\"Specify the functional nature of withdraw\"></a>Specify the functional nature of <code>withdraw</code></h3><p>Next, we define functional properties.<br>The two <code>ensures</code> statements in the following spec block give us what we expect from the <code>withdraw</code> functionality:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance - amount;\n    ensures result &#x3D;&#x3D; Coin&lt;CoinType&gt; &#123; value: amount &#125;;\n&#125;</code></pre>\n\n<p>In this code, first by using <code>let post</code> binding, define <code>balance_post</code> as the balance of <code>addr</code> after the function is executed, it should be equal to <code>balance - amount</code>. Then, <code>result</code> is a special name that represents the return value, which should be the <code>amount</code> of tokens.</p>\n<h2 id=\"Verify-the-deposit-function\"><a href=\"#Verify-the-deposit-function\" class=\"headerlink\" title=\"Verify the deposit function\"></a>Verify the <code>deposit</code> function</h2><p>The signature of the function deposit is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance</code></pre>\n\n<p>It deposits the token funds indicated by <code>check</code> into the address <code>addr</code>. Its canonical definition is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec deposit &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    let check_value &#x3D; check.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + check_value &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + check_value;\n&#125;</code></pre>\n\n<p>Here, <code>balance</code> is defined as the balance in <code>addr</code> before the function is executed, and <code>check_value</code> is defined as the amount of tokens to be deposited. It will abort in two cases:</p>\n<ol>\n<li>There is no resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>;</li>\n<li>Or the sum of <code>balance</code> and <code>check_value</code> is greater than the maximum value of type <code>u64</code>.</li>\n</ol>\n<p>The <code>ensures</code> statement is used to let the Prover make sure that in any case, the balance in <code>addr</code> can be updated correctly after the function is executed.</p>\n<p>The syntax mentioned earlier will not be repeated here.<br>Astute readers may have noticed that it is worth noting that the expression <code>balance + check_value &gt; MAX_U64</code> is problematic in the Move program.<br>Because the addition on the left may cause an overflow exception.<br>If we want to write a similar check in the Move program, we should use an expression like <code>balance &gt; MAX_U64 - check_value</code> to avoid the overflow problem.</p>\n<p>However, this expression is perfectly fine in the Move Specification Language (MSL).<br>Since the spec block uses the MSL language, its type system is different from that of Move.<br>In MSL, all integers are of type <code>num</code>, which is an integer in the mathematical sense. That is, it is signed and has no size limit.<br>All built-in integer types (<code>u8</code>, <code>u64</code>, etc.) are automatically converted to type <code>num</code> when referencing data in a Move program in MSL.<br>A more detailed description of the type system can be found in the MSL documentation.</p>\n<h2 id=\"Verify-the-transfer-function\"><a href=\"#Verify-the-transfer-function\" class=\"headerlink\" title=\"Verify the transfer function\"></a>Verify the <code>transfer</code> function</h2><p>The signature of the function <code>transfer</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for the transfer <code>from</code> the account from to the address <code>to</code>, and the transfer amount is <code>amount</code>.</p>\n<p>Let’s ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec transfer &#123;\n    let addr_from &#x3D; signer::address_of(from);\n\n    let balance_from &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let balance_to &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n    let post balance_from_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let post balance_to_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n\n    ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n    ensures balance_to_post &#x3D;&#x3D; balance_to + amount;\n&#125;</code></pre>\n\n<p>Here <code>from</code> is of type <code>signer</code>, not a direct address.<br>Although in the program we have created a local variable called <code>addr_from</code>, we cannot directly reference it in the spec block.<br>At the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to <code>addr_from</code> again.<br>Then use <code>let</code> and <code>let post</code> to define several variables, corresponding to the balances in the two addresses <code>addr_from</code> and <code>to</code> before and after the function is executed.<br>Finally, use the <code>ensures</code> statement to tell Prover that the balance in <code>from</code> should be subtracted by <code>amount</code>; the balance in <code>to</code> should be increased by <code>amount</code>.</p>\n<p>At first glance, there seems to be no problem at all. But is it really so?<br>Let’s see if Prover thinks this is “the correct description of the behavior of this function”.<br>After typing <code>aptos move prove</code> you can see:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: post-condition does not hold\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:51: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:53: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:54: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;         from &#x3D; signer&#123;0x0&#125;\n   &#x3D;         to &#x3D; 0x0\n   &#x3D;         amount &#x3D; 1\n   &#x3D;         _witness &#x3D; &lt;generic&gt;</code></pre>\n\n<p>It is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the <code>transfer</code> function.<br>Why is this so? Let’s look down again: the parameters that make the postconditions not satisfied are <code>from = signer&#123;0x0&#125;</code> and <code>to = 0x0</code>. We should know the reason: when the account transfers money to itself, both <code>to</code> and <code>from</code> point to the same address, so the balance does not change.</p>\n<p>There are two solutions now:</p>\n<p><strong>Plan A</strong> does not modify the function definition, but changes the specification.<br>In the spec block, consider whether the two accounts for the transfer and receiving are the same address.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures (addr_from &#x3D;&#x3D; to &amp;&amp; eq_post) || (addr_from !&#x3D; to &amp;&amp; ne_post);</code></pre>\n\n<p>Or use another slightly more intuitive if syntax:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures if (addr_from &#x3D;&#x3D; to) eq_post else ne_post;</code></pre>\n\n<p>Note that <code>if (P) E1 else E2</code> is not the same as conditional execution in program logic – it’s actually a syntactic sugar equivalent to <code>ensures</code> both <code>P ==&gt; E1</code> and <code>!P ==&gt; E2</code>.<br>And <code>p ==&gt; q</code> is actually <code>!p || q</code>.</p>\n<p>That is to say, the end of the second way of writing actually represents this logic:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from &#x3D;&#x3D; to  &#x3D;&#x3D;&#x3D;&gt;  eq_post) &amp;&amp; (addr_from !&#x3D; to  &#x3D;&#x3D;&#x3D;&gt; ne_post);</code></pre>\n\n<p>that is:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from !&#x3D; to || eq_post) &amp;&amp; (addr_from &#x3D;&#x3D; to  || ne_post);</code></pre>\n\n<p>Interested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former <code>(addr_from == to &amp;&amp; eq_post) || (addr_from != to &amp;&amp; ne_post)</code> and the latter <code>(addr_from != to || eq_post) &amp;&amp; (addr_from == to  || ne_post)</code> are actually exactly equivalent expressions.</p>\n<p><strong>Plan B</strong> does not modify the spec, but directly adds <code>assert!(addr_from != to, EEQUAL_ADDR);</code> in the function body, and adds the definition of the error code <code>EEQUAL_ADDR</code> in front, so that the self-transfer transaction cannot be completed.</p>\n<p>Obviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.<br>So plan B is a better practice.<br>It directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.</p>\n<h3 id=\"Practice\"><a href=\"#Practice\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>Currently, we have only completed functional verification of the <code>transfer</code> function.<br>But it doesn’t say under what circumstances it will abort.<br>As an exercise, give it an appropriate <code>aborts_if</code> condition. The answer can be found in our next article.</p>\n<h2 id=\"Verify-mint-function\"><a href=\"#Verify-mint-function\" class=\"headerlink\" title=\"Verify mint function\"></a>Verify mint function</h2><p>The signature of the function <code>mint</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for minting the <code>amount</code> of tokens and depositing them in the address <code>mint_addr</code>.<br>More interesting is <code>_witness</code>, which is of type <code>CoinType</code>.<br>Because only the module that defines the <code>CoinType</code> can construct a value of this type, this guarantees the identity of the caller.</p>\n<p>There is actually only one call to <code>deposit</code> in the <code>mint</code> function.<br>It is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(mint_addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<h2 id=\"Verify-the-publish-balance-function\"><a href=\"#Verify-the-publish-balance-function\" class=\"headerlink\" title=\"Verify the publish_balance function\"></a>Verify the <code>publish_balance</code> function</h2><p>The signature of the function <code>publish_balance</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun publish_balance&lt;CoinType&gt;(account: &amp;signer)</code></pre>\n\n<p>It publishes an empty <code>Balance&lt;CoinType&gt;</code> resource under <code>account</code>.<br>So if the resource already exists it should exit abnormally, and end normally the balance should be zero:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec publish_balance &#123;\n    let addr &#x3D; signer::address_of(account);\n    aborts_if exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n\n    ensures exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; 0;\n&#125;</code></pre>\n\n<h2 id=\"Simplify-redundant-specifications-with-Schema\"><a href=\"#Simplify-redundant-specifications-with-Schema\" class=\"headerlink\" title=\"Simplify redundant specifications with Schema\"></a>Simplify redundant specifications with Schema</h2><p>Congratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.<br>However, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.</p>\n<p>Schema is a means of building a specification by grouping properties.<br>Semantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.</p>\n<h3 id=\"Eliminate-simple-repetitions\"><a href=\"#Eliminate-simple-repetitions\" class=\"headerlink\" title=\"Eliminate simple repetitions\"></a>Eliminate simple repetitions</h3><p>As a most obvious example, the spec blocks of <code>mint</code> and <code>deposit</code> are a little different except for the variable names (in terms, they are <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion\">alpha convertible</a>), and the overall structure can be said to be exactly the same.<br>To simplify them, let’s create a Schema:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec schema DepositSchema&lt;CoinType&gt; &#123;\n    addr: address;\n    amount: u64;\n\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<p>This Schema declares two typed variables, and some conditions about what those variables should satisfy.<br>When other places want to use this Schema, use <code>include DepositSchema &#123;addr: XX, amount: YY&#125;</code> to import it.<br>where <code>XX</code> and <code>YY</code> are expressions used to replace <code>addr</code> and <code>amount</code>.<br>If the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.</p>\n<p>With the above Schema definition, we can now simplify the previous spec:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n  include DepositSchema&lt;CoinType&gt; &#123;addr: mint_addr&#125;;\n&#125;\n&#x2F;&#x2F; ....\nspec deposit &#123;\n    include DepositSchema&lt;CoinType&gt; &#123;amount: check.value&#125;;\n&#125;</code></pre>\n\n<h3 id=\"Practice-1\"><a href=\"#Practice-1\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>In addition to the above example, find another spec block (such as <code>publish_balance</code>), and split it into a Schema declaration and a spec block that uses the corresponding Schema.<br>As an exercise, the Schema you created might not be available in this code, so it doesn’t feel like there’s a benefit to it.<br>But if in the later development, there are other functions that call <code>publish_balance</code>, it will be more convenient.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>In our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore </p>\n<ul>\n<li>the tips and best practices; </li>\n<li>a more complicated case study using the Move Prover; </li>\n<li>the limitation of the current version of the Move Prover, and its future outlook;</li>\n</ul>\n<p>So stay tuned!</p>\n<p>More and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please <a href=\"https://www.movebit.xyz/#contact\">fill out our contact form</a>. We’d be happy to help.</p>\n<h2 id=\"About-Us\"><a href=\"#About-Us\" class=\"headerlink\" title=\"About Us\"></a>About Us</h2><p><a href=\"https://www.movebit.xyz/\">MoveBit</a> is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. </p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><a href=\"https://github.com/move-language/move/tree/main/language/documentation/tutorial/\">Move tutorial</a> by the Move team</li>\n<li><a href=\"https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/\">Starocin Move Prover tutorial</a> by Xudong Wang</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><em>Xudong Wang  &amp; 0xyi</em> 09-14-2022</p>\n<p>It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?</p>\n<p>We will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. </p>\n<p>For this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.</p>\n<h2 id=\"What-is-the-Move-Prover\"><a href=\"#What-is-the-Move-Prover\" class=\"headerlink\" title=\"What is the Move Prover\"></a>What is the Move Prover</h2><p>Formal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.<br>Now it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.</p>\n<p>Smart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.<br><strong>Move Prover (MVP)</strong> is designed to prevent bugs in smart contracts written in the Move language.</p>\n<p>In Aptos ( and Starcoin&#x2F;Sui ), Users can specify functional properties of smart contracts using the <strong>Move Specification Language (MSL)</strong>, and then use the Move Prover to automatically and statically inspect them.</p>\n<p>Simply put, there can be two components in a Move file:</p>\n<ul>\n<li><p>Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.</p>\n</li>\n<li><p>The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.</p>\n</li>\n</ul>\n<p>When we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.</p>\n<h2 id=\"Install-Prover-dependencies-in-Aptos\"><a href=\"#Install-Prover-dependencies-in-Aptos\" class=\"headerlink\" title=\"Install Prover dependencies in Aptos\"></a>Install Prover dependencies in Aptos</h2><p>Before using the Move Prover, let’s install some of its external dependencies.<br>It is assumed that you already have <a href=\"https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli\">installed Aptos CLI</a>.<br>Make sure you did “Step 3” and installed the dependencies of the Move Prover:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;scripts&#x2F;dev_setup.sh -yp\n. ~&#x2F;.profile</code></pre>\n\n<p>When the above command is executed, enter <code>boogie /version</code>, if the output is similar to “Boogie program verifier version X.X.X”, then the installation has been successful.</p>\n<p>Note that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).<br>Windows users can run it by installing <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install\">WSL</a>.</p>\n<h2 id=\"Prepare-an-example-for-verification-in\"><a href=\"#Prepare-an-example-for-verification-in\" class=\"headerlink\" title=\"Prepare an example for verification in\"></a>Prepare an example for verification in</h2><h3 id=\"Project-creation\"><a href=\"#Project-creation\" class=\"headerlink\" title=\"Project creation\"></a>Project creation</h3><p>First, let’s create a new empty Move package:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin</code></pre>\n\n<p>You can see that its directory structure is as follows:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">basic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    &#96;---- sources   (Directory)</code></pre>\n\n<h3 id=\"Module-code\"><a href=\"#Module-code\" class=\"headerlink\" title=\"Module code\"></a>Module code</h3><p>Now create <code>basic_coin/sources/BasicCoin.move</code>.</p>\n<details>\n<summary> BasicCoin.move content</summary>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;&#x2F; This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin &#123;\n    use std::error;\n    use std::signer;\n\n    &#x2F;&#x2F;&#x2F; Error codes\n    const ENOT_MODULE_OWNER: u64 &#x3D; 0;\n    const EINSUFFICIENT_BALANCE: u64 &#x3D; 1;\n    const EALREADY_HAS_BALANCE: u64 &#x3D; 2;\n\n    struct Coin&lt;phantom CoinType&gt; has store &#123;\n        value: u64\n    &#125;\n\n    struct Balance&lt;phantom CoinType&gt; has key &#123;\n        coin: Coin&lt;CoinType&gt;\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Publish an empty balance resource under &#96;account&#96;&#39;s address. This function must be called before\n    &#x2F;&#x2F;&#x2F; minting or transferring to the account.\n    public fun publish_balance&lt;CoinType&gt;(account: &amp;signer) &#123;\n        let empty_coin &#x3D; Coin&lt;CoinType&gt; &#123; value: 0 &#125;;\n        assert!(!exists&lt;Balance&lt;CoinType&gt;&gt;(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance&lt;CoinType&gt; &#123; coin:  empty_coin &#125;);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Mint &#96;amount&#96; tokens to &#96;mint_addr&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can decide the minting policy.\n    public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        &#x2F;&#x2F; Deposit &#96;total_value&#96; amount of tokens to mint_addr&#39;s balance\n        deposit(mint_addr, Coin&lt;CoinType&gt; &#123; value: amount &#125;);\n    &#125;\n\n    public fun balance_of&lt;CoinType&gt;(owner: address): u64 acquires Balance &#123;\n        borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Transfers &#96;amount&#96; of tokens from &#96;from&#96; to &#96;to&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can  decide the transferring policy.\n    public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        let addr_from &#x3D; signer::address_of(from);\n        let check &#x3D; withdraw&lt;CoinType&gt;(addr_from, amount);\n        deposit&lt;CoinType&gt;(to, check);\n    &#125;\n\n    fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance &#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        assert!(balance &gt;&#x3D; amount, EINSUFFICIENT_BALANCE);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        *balance_ref &#x3D; balance - amount;\n        Coin&lt;CoinType&gt; &#123; value: amount &#125;\n    &#125;\n    \n    fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance&#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        let Coin &#123; value &#125; &#x3D; check;\n        *balance_ref &#x3D; balance + value;\n    &#125;\n&#125;</code></pre>\n\n</details>\n\n<p>Here we assume that you have a certain grasp of the Move language, and can understand the source code of <code>BasicCoin.move</code> above and know the function of each part.</p>\n<h3 id=\"TOML-configuration\"><a href=\"#TOML-configuration\" class=\"headerlink\" title=\"TOML configuration\"></a>TOML configuration</h3><p>BasicCoin uses some facilities of the Aptos standard library, and also needs to add <code>aptos-framework</code> to the dependencies. We also need to specify what numerical address it should be replaced with. </p>\n<p>Therefore, we modify Move.toml as follows:</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\">[package]\nname &#x3D; &quot;BasicCoin&quot;\nversion &#x3D; &quot;0.0.0&quot;\n\n[dependencies]\nAptosFramework &#x3D; &#123; git &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;aptos-labs&#x2F;aptos-core.git&quot;, subdir &#x3D; &quot;aptos-move&#x2F;framework&#x2F;aptos-framework&#x2F;&quot;, rev &#x3D; &quot;main&quot; &#125;\n\n[addresses]\nBasicCoin&#x3D;&quot;Replace_It_With_Your_Numerical_Address&quot;  \n</code></pre>\n\n<h2 id=\"The-first-verification-code\"><a href=\"#The-first-verification-code\" class=\"headerlink\" title=\"The first verification code\"></a>The first verification code</h2><p>To give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n&#125;</code></pre>\n\n<p>Syntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the <code>balance_of</code> function in order to clearly see the correspondence between the definition and the specification when reading the code.</p>\n<p>Simply put, the <code>spec balance_of &#123;...&#125;</code> block will contain our <strong>property specification</strong> for the <code>balance_of</code> function.<br>There are many types of property specifications, some common examples are:</p>\n<ul>\n<li>Will this function abort? Under what circumstances does it abort?</li>\n<li>What conditions must be met for the parameters to call this function?</li>\n<li>What is the return value of this function?</li>\n<li>After the function is executed, how will the state of the virtual machine be changed?</li>\n<li>What invariants does this function maintain?</li>\n</ul>\n<p>For example, the Move Prover allows all possible aborts by default when we don’t give any abort conditions.<br>And in the simple snippet above, we tell Prover with the directive <code>aborts_if_is_strict</code>:</p>\n<blockquote>\n<p>I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.</p>\n</blockquote>\n<p>Now, we run the <code>prove</code> command in the <code>basic_coin</code> directory:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">aptos move prove</code></pre>\n<p>it will call the Move Prover to check the code in the package.<br>Then we can see the Prover reporting the following error message:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: abort not covered by any of the &#96;aborts_if&#96; clauses\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:38:5\n   │\n35 │           borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of &#123;\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     &#125;\n   │ ╰─────^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:34: balance_of\n   &#x3D;         owner &#x3D; 0x29\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:35: balance_of\n   &#x3D;         ABORTED\n\nFAILURE proving 1 modules from package &#96;basic_coin&#96; in 1.794s\n&#123;\n  &quot;Error&quot;: &quot;Move Prover failed: exiting with verification errors&quot;\n&#125;</code></pre>\n\n<p>Prover’s output tells us that it found a situation where the <code>balance_of</code> function aborts, but we don’t explicitly point out the possibility of such aborts.<br>Looking at the code that triggers the abort, we can see that the exception is caused by calling the built-in <code>borrow_global</code> function when the <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.<br>Following the guidance of the error message, we can add the following <code>aborts_if</code> condition:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(owner);\n&#125;</code></pre>\n\n<p>After adding this condition, try calling Prover again and see that there are no more validation errors.<br>Now we can confidently confirm that the <code>balance_of</code> function has one and only one possibility of abnormal termination, that is, the parameter <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.</p>\n<h2 id=\"Verify-withdraw-function\"><a href=\"#Verify-withdraw-function\" class=\"headerlink\" title=\"Verify withdraw function\"></a>Verify withdraw function</h2><p>The signature of the function <code>withdraw</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance</code></pre>\n\n<p>Its role is to withdraw the <code>amount</code> of coins from the address <code>addr</code> and return it.</p>\n<h3 id=\"Specify-the-abort-condition-for-withdraw\"><a href=\"#Specify-the-abort-condition-for-withdraw\" class=\"headerlink\" title=\"Specify the abort condition for withdraw\"></a>Specify the abort condition for <code>withdraw</code></h3><p>There are two possibilities for <code>withdraw</code> to abort:</p>\n<ol>\n<li>No resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>.</li>\n<li>The balance in <code>addr</code> is less than <code>amount</code>.</li>\n</ol>\n<p>From these, we can define the abort condition like this:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n&#125;</code></pre>\n\n<ul>\n<li>A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.<br><code>global&lt;T&gt;(addr): T</code> is a built-in function that returns a resource of type <code>T</code> at address <code>addr</code>.<br>Here, we set balance to the number of tokens owned by addr via the let binding;</li>\n<li><code>exists&lt;T&gt;(address): bool</code> is a built-in function that returns true if resource <code>T</code> exists at address <code>addr</code>; otherwise returns false.</li>\n</ul>\n<p>The two lines of <code>aborts_if</code> statements correspond to the two conditions mentioned above.<br>In general, if a function has multiple <code>aborts_if</code> conditions, the conditions are ORed together.</p>\n<p>As mentioned earlier, if we don’t specify any abort conditions, Prover will not impose any restrictions on aborts.<br>But once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction <code>pragma aborts_if_is_strict</code>.<br>If only some of the conditions for abnormal exit are listed, the Prover will report a validation error.<br>However, if the <code>pragma aborts_if_is_partial</code> is defined in the spec block, this is equivalent to telling the Prover:</p>\n<blockquote>\n<p>I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.</p>\n</blockquote>\n<p>If you are interested, you can do such a set of experiments to verify:</p>\n<ul>\n<li>When deleting any of the above two <code>aborts_if</code> conditions, Prover will report an error;</li>\n<li>When all <code>aborts_if</code> conditions are deleted at the same time, Prover will not report an error;</li>\n<li>When adding <code>pragma aborts_if_is_partial</code>, no matter how many <code>aborts_if</code> conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).</li>\n</ul>\n<p>Some readers may be curious about the order of the three statements in the spec block:<br>Why the definition of balance can be written after <code>aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr)</code>.<br>Because, if the latter holds true, <code>balance</code> does not actually exist.<br>Wouldn’t this order cause the Prover to fail?<br>Simply put: no, the statements in the spec block are declarative and the order doesn’t matter.</p>\n<p>For a more detailed understanding, you can refer to the MSL documentation for more information.</p>\n<h3 id=\"Specify-the-functional-nature-of-withdraw\"><a href=\"#Specify-the-functional-nature-of-withdraw\" class=\"headerlink\" title=\"Specify the functional nature of withdraw\"></a>Specify the functional nature of <code>withdraw</code></h3><p>Next, we define functional properties.<br>The two <code>ensures</code> statements in the following spec block give us what we expect from the <code>withdraw</code> functionality:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance - amount;\n    ensures result &#x3D;&#x3D; Coin&lt;CoinType&gt; &#123; value: amount &#125;;\n&#125;</code></pre>\n\n<p>In this code, first by using <code>let post</code> binding, define <code>balance_post</code> as the balance of <code>addr</code> after the function is executed, it should be equal to <code>balance - amount</code>. Then, <code>result</code> is a special name that represents the return value, which should be the <code>amount</code> of tokens.</p>\n<h2 id=\"Verify-the-deposit-function\"><a href=\"#Verify-the-deposit-function\" class=\"headerlink\" title=\"Verify the deposit function\"></a>Verify the <code>deposit</code> function</h2><p>The signature of the function deposit is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance</code></pre>\n\n<p>It deposits the token funds indicated by <code>check</code> into the address <code>addr</code>. Its canonical definition is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec deposit &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    let check_value &#x3D; check.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + check_value &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + check_value;\n&#125;</code></pre>\n\n<p>Here, <code>balance</code> is defined as the balance in <code>addr</code> before the function is executed, and <code>check_value</code> is defined as the amount of tokens to be deposited. It will abort in two cases:</p>\n<ol>\n<li>There is no resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>;</li>\n<li>Or the sum of <code>balance</code> and <code>check_value</code> is greater than the maximum value of type <code>u64</code>.</li>\n</ol>\n<p>The <code>ensures</code> statement is used to let the Prover make sure that in any case, the balance in <code>addr</code> can be updated correctly after the function is executed.</p>\n<p>The syntax mentioned earlier will not be repeated here.<br>Astute readers may have noticed that it is worth noting that the expression <code>balance + check_value &gt; MAX_U64</code> is problematic in the Move program.<br>Because the addition on the left may cause an overflow exception.<br>If we want to write a similar check in the Move program, we should use an expression like <code>balance &gt; MAX_U64 - check_value</code> to avoid the overflow problem.</p>\n<p>However, this expression is perfectly fine in the Move Specification Language (MSL).<br>Since the spec block uses the MSL language, its type system is different from that of Move.<br>In MSL, all integers are of type <code>num</code>, which is an integer in the mathematical sense. That is, it is signed and has no size limit.<br>All built-in integer types (<code>u8</code>, <code>u64</code>, etc.) are automatically converted to type <code>num</code> when referencing data in a Move program in MSL.<br>A more detailed description of the type system can be found in the MSL documentation.</p>\n<h2 id=\"Verify-the-transfer-function\"><a href=\"#Verify-the-transfer-function\" class=\"headerlink\" title=\"Verify the transfer function\"></a>Verify the <code>transfer</code> function</h2><p>The signature of the function <code>transfer</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for the transfer <code>from</code> the account from to the address <code>to</code>, and the transfer amount is <code>amount</code>.</p>\n<p>Let’s ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec transfer &#123;\n    let addr_from &#x3D; signer::address_of(from);\n\n    let balance_from &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let balance_to &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n    let post balance_from_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let post balance_to_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n\n    ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n    ensures balance_to_post &#x3D;&#x3D; balance_to + amount;\n&#125;</code></pre>\n\n<p>Here <code>from</code> is of type <code>signer</code>, not a direct address.<br>Although in the program we have created a local variable called <code>addr_from</code>, we cannot directly reference it in the spec block.<br>At the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to <code>addr_from</code> again.<br>Then use <code>let</code> and <code>let post</code> to define several variables, corresponding to the balances in the two addresses <code>addr_from</code> and <code>to</code> before and after the function is executed.<br>Finally, use the <code>ensures</code> statement to tell Prover that the balance in <code>from</code> should be subtracted by <code>amount</code>; the balance in <code>to</code> should be increased by <code>amount</code>.</p>\n<p>At first glance, there seems to be no problem at all. But is it really so?<br>Let’s see if Prover thinks this is “the correct description of the behavior of this function”.<br>After typing <code>aptos move prove</code> you can see:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: post-condition does not hold\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:51: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:53: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:54: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;         from &#x3D; signer&#123;0x0&#125;\n   &#x3D;         to &#x3D; 0x0\n   &#x3D;         amount &#x3D; 1\n   &#x3D;         _witness &#x3D; &lt;generic&gt;</code></pre>\n\n<p>It is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the <code>transfer</code> function.<br>Why is this so? Let’s look down again: the parameters that make the postconditions not satisfied are <code>from = signer&#123;0x0&#125;</code> and <code>to = 0x0</code>. We should know the reason: when the account transfers money to itself, both <code>to</code> and <code>from</code> point to the same address, so the balance does not change.</p>\n<p>There are two solutions now:</p>\n<p><strong>Plan A</strong> does not modify the function definition, but changes the specification.<br>In the spec block, consider whether the two accounts for the transfer and receiving are the same address.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures (addr_from &#x3D;&#x3D; to &amp;&amp; eq_post) || (addr_from !&#x3D; to &amp;&amp; ne_post);</code></pre>\n\n<p>Or use another slightly more intuitive if syntax:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures if (addr_from &#x3D;&#x3D; to) eq_post else ne_post;</code></pre>\n\n<p>Note that <code>if (P) E1 else E2</code> is not the same as conditional execution in program logic – it’s actually a syntactic sugar equivalent to <code>ensures</code> both <code>P ==&gt; E1</code> and <code>!P ==&gt; E2</code>.<br>And <code>p ==&gt; q</code> is actually <code>!p || q</code>.</p>\n<p>That is to say, the end of the second way of writing actually represents this logic:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from &#x3D;&#x3D; to  &#x3D;&#x3D;&#x3D;&gt;  eq_post) &amp;&amp; (addr_from !&#x3D; to  &#x3D;&#x3D;&#x3D;&gt; ne_post);</code></pre>\n\n<p>that is:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from !&#x3D; to || eq_post) &amp;&amp; (addr_from &#x3D;&#x3D; to  || ne_post);</code></pre>\n\n<p>Interested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former <code>(addr_from == to &amp;&amp; eq_post) || (addr_from != to &amp;&amp; ne_post)</code> and the latter <code>(addr_from != to || eq_post) &amp;&amp; (addr_from == to  || ne_post)</code> are actually exactly equivalent expressions.</p>\n<p><strong>Plan B</strong> does not modify the spec, but directly adds <code>assert!(addr_from != to, EEQUAL_ADDR);</code> in the function body, and adds the definition of the error code <code>EEQUAL_ADDR</code> in front, so that the self-transfer transaction cannot be completed.</p>\n<p>Obviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.<br>So plan B is a better practice.<br>It directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.</p>\n<h3 id=\"Practice\"><a href=\"#Practice\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>Currently, we have only completed functional verification of the <code>transfer</code> function.<br>But it doesn’t say under what circumstances it will abort.<br>As an exercise, give it an appropriate <code>aborts_if</code> condition. The answer can be found in our next article.</p>\n<h2 id=\"Verify-mint-function\"><a href=\"#Verify-mint-function\" class=\"headerlink\" title=\"Verify mint function\"></a>Verify mint function</h2><p>The signature of the function <code>mint</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for minting the <code>amount</code> of tokens and depositing them in the address <code>mint_addr</code>.<br>More interesting is <code>_witness</code>, which is of type <code>CoinType</code>.<br>Because only the module that defines the <code>CoinType</code> can construct a value of this type, this guarantees the identity of the caller.</p>\n<p>There is actually only one call to <code>deposit</code> in the <code>mint</code> function.<br>It is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(mint_addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<h2 id=\"Verify-the-publish-balance-function\"><a href=\"#Verify-the-publish-balance-function\" class=\"headerlink\" title=\"Verify the publish_balance function\"></a>Verify the <code>publish_balance</code> function</h2><p>The signature of the function <code>publish_balance</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun publish_balance&lt;CoinType&gt;(account: &amp;signer)</code></pre>\n\n<p>It publishes an empty <code>Balance&lt;CoinType&gt;</code> resource under <code>account</code>.<br>So if the resource already exists it should exit abnormally, and end normally the balance should be zero:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec publish_balance &#123;\n    let addr &#x3D; signer::address_of(account);\n    aborts_if exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n\n    ensures exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; 0;\n&#125;</code></pre>\n\n<h2 id=\"Simplify-redundant-specifications-with-Schema\"><a href=\"#Simplify-redundant-specifications-with-Schema\" class=\"headerlink\" title=\"Simplify redundant specifications with Schema\"></a>Simplify redundant specifications with Schema</h2><p>Congratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.<br>However, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.</p>\n<p>Schema is a means of building a specification by grouping properties.<br>Semantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.</p>\n<h3 id=\"Eliminate-simple-repetitions\"><a href=\"#Eliminate-simple-repetitions\" class=\"headerlink\" title=\"Eliminate simple repetitions\"></a>Eliminate simple repetitions</h3><p>As a most obvious example, the spec blocks of <code>mint</code> and <code>deposit</code> are a little different except for the variable names (in terms, they are <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion\">alpha convertible</a>), and the overall structure can be said to be exactly the same.<br>To simplify them, let’s create a Schema:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec schema DepositSchema&lt;CoinType&gt; &#123;\n    addr: address;\n    amount: u64;\n\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<p>This Schema declares two typed variables, and some conditions about what those variables should satisfy.<br>When other places want to use this Schema, use <code>include DepositSchema &#123;addr: XX, amount: YY&#125;</code> to import it.<br>where <code>XX</code> and <code>YY</code> are expressions used to replace <code>addr</code> and <code>amount</code>.<br>If the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.</p>\n<p>With the above Schema definition, we can now simplify the previous spec:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n  include DepositSchema&lt;CoinType&gt; &#123;addr: mint_addr&#125;;\n&#125;\n&#x2F;&#x2F; ....\nspec deposit &#123;\n    include DepositSchema&lt;CoinType&gt; &#123;amount: check.value&#125;;\n&#125;</code></pre>\n\n<h3 id=\"Practice-1\"><a href=\"#Practice-1\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>In addition to the above example, find another spec block (such as <code>publish_balance</code>), and split it into a Schema declaration and a spec block that uses the corresponding Schema.<br>As an exercise, the Schema you created might not be available in this code, so it doesn’t feel like there’s a benefit to it.<br>But if in the later development, there are other functions that call <code>publish_balance</code>, it will be more convenient.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>In our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore </p>\n<ul>\n<li>the tips and best practices; </li>\n<li>a more complicated case study using the Move Prover; </li>\n<li>the limitation of the current version of the Move Prover, and its future outlook;</li>\n</ul>\n<p>So stay tuned!</p>\n<p>More and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please <a href=\"https://www.movebit.xyz/#contact\">fill out our contact form</a>. We’d be happy to help.</p>\n<h2 id=\"About-Us\"><a href=\"#About-Us\" class=\"headerlink\" title=\"About Us\"></a>About Us</h2><p><a href=\"https://www.movebit.xyz/\">MoveBit</a> is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. </p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><a href=\"https://github.com/move-language/move/tree/main/language/documentation/tutorial/\">Move tutorial</a> by the Move team</li>\n<li><a href=\"https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/\">Starocin Move Prover tutorial</a> by Xudong Wang</li>\n</ul>\n"},{"title":"MoveBit Launches the First Move CTF Security Competition Sponsored by Mysten Labs","date":"2022-10-18T11:42:30.000Z","description":"The Move ecosystem is booming, and with it comes a need for Move-specific security expertise.","thumbnail":"/img/icon.png","_content":"\nThe Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.\n \nThe Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. \n \nMoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.\n\n![MoveCTF](../img/movectf.jpeg)\n \nMoveCTF's first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.\n \nThe top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.\n \nRegistration for the MoveCTF competition is now open. For more information, please visit this link:  https://movectf.movebit.xyz/\n \n## About MoveBit\nMoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.\n\n![MoveBit](../img/movebit_logo.png)\n\n\n## About Mysten Labs\n \nMysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.\n\n![MoveBit](../img/sui_logo.png)\n\n\nSui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.\n\n","source":"_posts/movectf.md","raw":"---\ntitle: MoveBit Launches the First Move CTF Security Competition Sponsored by Mysten Labs\ndate: 2022-10-18 19:42:30\ntags:\ndescription: The Move ecosystem is booming, and with it comes a need for Move-specific security expertise.\nthumbnail: /img/icon.png\n---\n\nThe Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.\n \nThe Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. \n \nMoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.\n\n![MoveCTF](../img/movectf.jpeg)\n \nMoveCTF's first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.\n \nThe top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.\n \nRegistration for the MoveCTF competition is now open. For more information, please visit this link:  https://movectf.movebit.xyz/\n \n## About MoveBit\nMoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.\n\n![MoveBit](../img/movebit_logo.png)\n\n\n## About Mysten Labs\n \nMysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.\n\n![MoveBit](../img/sui_logo.png)\n\n\nSui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.\n\n","slug":"movectf","published":1,"updated":"2022-12-05T09:52:03.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbbmsdzh00026b7lerp2232e","content":"<p>The Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.</p>\n<p>The Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. </p>\n<p>MoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.</p>\n<p><img src=\"/../img/movectf.jpeg\" alt=\"MoveCTF\"></p>\n<p>MoveCTF’s first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.</p>\n<p>The top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.</p>\n<p>Registration for the MoveCTF competition is now open. For more information, please visit this link:  <a href=\"https://movectf.movebit.xyz/\">https://movectf.movebit.xyz/</a></p>\n<h2 id=\"About-MoveBit\"><a href=\"#About-MoveBit\" class=\"headerlink\" title=\"About MoveBit\"></a>About MoveBit</h2><p>MoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.</p>\n<p><img src=\"/../img/movebit_logo.png\" alt=\"MoveBit\"></p>\n<h2 id=\"About-Mysten-Labs\"><a href=\"#About-Mysten-Labs\" class=\"headerlink\" title=\"About Mysten Labs\"></a>About Mysten Labs</h2><p>Mysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.</p>\n<p><img src=\"/../img/sui_logo.png\" alt=\"MoveBit\"></p>\n<p>Sui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>The Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.</p>\n<p>The Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. </p>\n<p>MoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.</p>\n<p><img src=\"/../img/movectf.jpeg\" alt=\"MoveCTF\"></p>\n<p>MoveCTF’s first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.</p>\n<p>The top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.</p>\n<p>Registration for the MoveCTF competition is now open. For more information, please visit this link:  <a href=\"https://movectf.movebit.xyz/\">https://movectf.movebit.xyz/</a></p>\n<h2 id=\"About-MoveBit\"><a href=\"#About-MoveBit\" class=\"headerlink\" title=\"About MoveBit\"></a>About MoveBit</h2><p>MoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.</p>\n<p><img src=\"/../img/movebit_logo.png\" alt=\"MoveBit\"></p>\n<h2 id=\"About-Mysten-Labs\"><a href=\"#About-Mysten-Labs\" class=\"headerlink\" title=\"About Mysten Labs\"></a>About Mysten Labs</h2><p>Mysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.</p>\n<p><img src=\"/../img/sui_logo.png\" alt=\"MoveBit\"></p>\n<p>Sui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.</p>\n"},{"title":"The First MoveCTF Summary","date":"2022-11-10T10:00:00.000Z","description":"MoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition","thumbnail":"/img/icon.png","_content":"\nMoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.\n\nBy the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.\n\nEach challenge was completed as follows.\n* checkin 305 solves \n* simple game 22 solves\n* move lock 37 solves\n* flash loan 41 solves\n\n![alt rank](../img/post3_1.png)\n\nThe top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.\n\nIn addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.\n\n![alt rank](../img/post3_2.png)\n\n![alt rank](../img/post3_3.png)\n\nThanks to all the participants and partners, let's look forward to the next Move CTF!\n\nMoveCTF official website: \n[http://movectf.movebit.xyz/](http://movectf.movebit.xyz/)\n\nMoveBit official website: \n[https://www.movebit.xyz/](https://www.movebit.xyz/)\n","source":"_posts/the-first-movectf-summary.md","raw":"---\ntitle: The First MoveCTF Summary\ndate: 2022-11-10 18:00:00\ntags:\ndescription: MoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition\nthumbnail: /img/icon.png\n---\n\nMoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.\n\nBy the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.\n\nEach challenge was completed as follows.\n* checkin 305 solves \n* simple game 22 solves\n* move lock 37 solves\n* flash loan 41 solves\n\n![alt rank](../img/post3_1.png)\n\nThe top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.\n\nIn addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.\n\n![alt rank](../img/post3_2.png)\n\n![alt rank](../img/post3_3.png)\n\nThanks to all the participants and partners, let's look forward to the next Move CTF!\n\nMoveCTF official website: \n[http://movectf.movebit.xyz/](http://movectf.movebit.xyz/)\n\nMoveBit official website: \n[https://www.movebit.xyz/](https://www.movebit.xyz/)\n","slug":"the-first-movectf-summary","published":1,"updated":"2022-12-05T09:52:03.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbbmsdzl00046b7l4r3e1nhq","content":"<p>MoveCTF  (Nov 5 — Nov 7 &#x2F; 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.</p>\n<p>By the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.</p>\n<p>Each challenge was completed as follows.</p>\n<ul>\n<li>checkin 305 solves </li>\n<li>simple game 22 solves</li>\n<li>move lock 37 solves</li>\n<li>flash loan 41 solves</li>\n</ul>\n<p><img src=\"/../img/post3_1.png\" alt=\"alt rank\"></p>\n<p>The top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.</p>\n<p>In addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.</p>\n<p><img src=\"/../img/post3_2.png\" alt=\"alt rank\"></p>\n<p><img src=\"/../img/post3_3.png\" alt=\"alt rank\"></p>\n<p>Thanks to all the participants and partners, let’s look forward to the next Move CTF!</p>\n<p>MoveCTF official website:<br><a href=\"http://movectf.movebit.xyz/\">http://movectf.movebit.xyz/</a></p>\n<p>MoveBit official website:<br><a href=\"https://www.movebit.xyz/\">https://www.movebit.xyz/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>MoveCTF  (Nov 5 — Nov 7 &#x2F; 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.</p>\n<p>By the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.</p>\n<p>Each challenge was completed as follows.</p>\n<ul>\n<li>checkin 305 solves </li>\n<li>simple game 22 solves</li>\n<li>move lock 37 solves</li>\n<li>flash loan 41 solves</li>\n</ul>\n<p><img src=\"/../img/post3_1.png\" alt=\"alt rank\"></p>\n<p>The top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.</p>\n<p>In addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.</p>\n<p><img src=\"/../img/post3_2.png\" alt=\"alt rank\"></p>\n<p><img src=\"/../img/post3_3.png\" alt=\"alt rank\"></p>\n<p>Thanks to all the participants and partners, let’s look forward to the next Move CTF!</p>\n<p>MoveCTF official website:<br><a href=\"http://movectf.movebit.xyz/\">http://movectf.movebit.xyz/</a></p>\n<p>MoveBit official website:<br><a href=\"https://www.movebit.xyz/\">https://www.movebit.xyz/</a></p>\n"},{"title":"Sui Concept and Testnet","date":"2022-12-30T08:53:50.000Z","description":"MoveBit will show you how to run and interact with Sui local testnet","thumbnail":"/img/icon.png","_content":"We can learn Sui concepts from here:\n[https://docs.sui.io/learn/how-sui-works](https://docs.sui.io/learn/how-sui-works)\n\n# SUI CODE ARCHITECTURE\nThe latest version of the code  is `devnet-0.17.0`\n\n```jsx\ngit clone https://github.com/MystenLabs/sui.git\n```\n\n```bash\n.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp\n```\n\nAs we can see, the structure of the code is similar to Aptos.\n\nDifferent functions are organized in different packages in `sui/crates/ folder`.The most parts are those:\n\n```bash\n├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n```\n\n## cartes/sui\n\nLike Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in `crates/src/main.rc —> fn main()`. Our entire code analysis process starts with this entry.\n\n![Untitled](../img/123.png)\n\n## other packages\n\n- sui-faucet - sui faucet related service.\n- sui-node - node related\n- sui-core - authority server and Sui Gateway\n- sui-types - coins, gas, and other object types\n- sui-network - networking interfaces\n\n\n# Build Sui and run local testnet\n\nThe Sui repository includes two primary branches, `devnet` and `main`.\n\n- The `devnet` branch includes the latest stable build of Sui. Choose the `devnet` branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the `main` branch. To submit a pull request (PR), you should push commits to your fork of the `main` branch.\n- The `main` branch includes the most recent changes and updates. Use the `main` branch if you want to contribute to the Sui project. The `main` branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.\n\n> *The previous* `git clone` *command syncs with the* `devnet` *branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don't need to interact with our Devnet, you should switch to* `main` *branch.*\n> \n\n## **Build**\n\nCause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.\n\n```bash\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch devnet sui\n```\n\nThis will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can't compile, then change the system.\n\nI have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.\n\nIt took about an hour to compile this.\n\n![Untitled](../img/1234.png)\n\n> For more detail : [https://docs.sui.io/build/install](https://docs.sui.io/build/install)\n> \n\nAfter we compiled we can see the executable file in `~/.carge/bin/sui`. And the we can use it to run local testnet.\n\n![Untitled](../img/12345.png)\n\n## genesis\n\nTo create the configuration files and objects for a local Sui network, run the `genesis` command. Genesis creates the network configuration files in the `~/.sui/sui_config` folder. \n\n```bash\n#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in \"/Users/safeer/.sui/sui_config/network.yaml\".\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in \"/Users/safeer/.sui/sui_config/sui.keystore\".\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in \"/Users/safeer/.sui/sui_config/client.yaml\".\n```\n\nThis includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.\n\nThe network that genesis creates includes four validators and five user accounts that contain five coin objects each.\n\n![Untitled](../img/123456.png)\n\n## Start the local network\n\nRun the following command to start the local Sui network with default configuration( `~/.sui/sui_config/network.yaml`).\n\n```bash\nsui start\n```\n\n![Untitled](../img/23.jpeg)\n\nWhen you start the network, Sui generates an `authorities_db directory` that stores validator data, and a `consensus_db` directory that stores consensus data.\n\n![Untitled](../img/24.png)\n\n# Interact with Sui local network\n\n## sui client\n\nwe can use Sui CLI to interact with Sui net\n\n```bash\n#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~/.sui/sui_config directory\nsui console \n```\n\n![Untitled](../img/25.png)\n\nSome example:\n\n```bash\n#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100\n```\n\n![Untitled](../img/26.png)\n\n![Untitled](../img/27.png)\n\n![Untitled](../img/28.png)\n\n# Debug Sui with vscode\n\nIn the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.\n\nSteps(on mac):\n\n1. install vscode and plug-in (rust-analyzer,CodeLLDB)\n2. open the sui folder\n3. open the target file\n\ncreate new launch.json file(will be automatically generated  ).\n\n![Untitled](../img/30.png)\n\nadd args:\n\n![Untitled](../img/31.png)\n\nStart to debug:\n\n![Untitled](../img/33.png)\n\n**About MoveBit**\n\n**MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.**\n\nTwitter: https://twitter.com/MoveBit_  \nMedium: https://movebit.medium.com/\nGithub: https://github.com/movebit\nDiscord: https://discord.com/invite/7wM8VU9Gyj\n","source":"_posts/Sui Concept and Testnet.md","raw":"---\ntitle: Sui Concept and Testnet\ndate: 2022-12-30 16:53:50\ntags: SuiEcosystem, MoveLang\ndescription: MoveBit will show you how to run and interact with Sui local testnet\nthumbnail: /img/icon.png\n---\nWe can learn Sui concepts from here:\n[https://docs.sui.io/learn/how-sui-works](https://docs.sui.io/learn/how-sui-works)\n\n# SUI CODE ARCHITECTURE\nThe latest version of the code  is `devnet-0.17.0`\n\n```jsx\ngit clone https://github.com/MystenLabs/sui.git\n```\n\n```bash\n.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp\n```\n\nAs we can see, the structure of the code is similar to Aptos.\n\nDifferent functions are organized in different packages in `sui/crates/ folder`.The most parts are those:\n\n```bash\n├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n```\n\n## cartes/sui\n\nLike Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in `crates/src/main.rc —> fn main()`. Our entire code analysis process starts with this entry.\n\n![Untitled](../img/123.png)\n\n## other packages\n\n- sui-faucet - sui faucet related service.\n- sui-node - node related\n- sui-core - authority server and Sui Gateway\n- sui-types - coins, gas, and other object types\n- sui-network - networking interfaces\n\n\n# Build Sui and run local testnet\n\nThe Sui repository includes two primary branches, `devnet` and `main`.\n\n- The `devnet` branch includes the latest stable build of Sui. Choose the `devnet` branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the `main` branch. To submit a pull request (PR), you should push commits to your fork of the `main` branch.\n- The `main` branch includes the most recent changes and updates. Use the `main` branch if you want to contribute to the Sui project. The `main` branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.\n\n> *The previous* `git clone` *command syncs with the* `devnet` *branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don't need to interact with our Devnet, you should switch to* `main` *branch.*\n> \n\n## **Build**\n\nCause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.\n\n```bash\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch devnet sui\n```\n\nThis will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can't compile, then change the system.\n\nI have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.\n\nIt took about an hour to compile this.\n\n![Untitled](../img/1234.png)\n\n> For more detail : [https://docs.sui.io/build/install](https://docs.sui.io/build/install)\n> \n\nAfter we compiled we can see the executable file in `~/.carge/bin/sui`. And the we can use it to run local testnet.\n\n![Untitled](../img/12345.png)\n\n## genesis\n\nTo create the configuration files and objects for a local Sui network, run the `genesis` command. Genesis creates the network configuration files in the `~/.sui/sui_config` folder. \n\n```bash\n#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in \"/Users/safeer/.sui/sui_config/network.yaml\".\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in \"/Users/safeer/.sui/sui_config/sui.keystore\".\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in \"/Users/safeer/.sui/sui_config/client.yaml\".\n```\n\nThis includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.\n\nThe network that genesis creates includes four validators and five user accounts that contain five coin objects each.\n\n![Untitled](../img/123456.png)\n\n## Start the local network\n\nRun the following command to start the local Sui network with default configuration( `~/.sui/sui_config/network.yaml`).\n\n```bash\nsui start\n```\n\n![Untitled](../img/23.jpeg)\n\nWhen you start the network, Sui generates an `authorities_db directory` that stores validator data, and a `consensus_db` directory that stores consensus data.\n\n![Untitled](../img/24.png)\n\n# Interact with Sui local network\n\n## sui client\n\nwe can use Sui CLI to interact with Sui net\n\n```bash\n#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~/.sui/sui_config directory\nsui console \n```\n\n![Untitled](../img/25.png)\n\nSome example:\n\n```bash\n#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100\n```\n\n![Untitled](../img/26.png)\n\n![Untitled](../img/27.png)\n\n![Untitled](../img/28.png)\n\n# Debug Sui with vscode\n\nIn the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.\n\nSteps(on mac):\n\n1. install vscode and plug-in (rust-analyzer,CodeLLDB)\n2. open the sui folder\n3. open the target file\n\ncreate new launch.json file(will be automatically generated  ).\n\n![Untitled](../img/30.png)\n\nadd args:\n\n![Untitled](../img/31.png)\n\nStart to debug:\n\n![Untitled](../img/33.png)\n\n**About MoveBit**\n\n**MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.**\n\nTwitter: https://twitter.com/MoveBit_  \nMedium: https://movebit.medium.com/\nGithub: https://github.com/movebit\nDiscord: https://discord.com/invite/7wM8VU9Gyj\n","slug":"Sui Concept and Testnet","published":1,"updated":"2022-12-30T07:26:44.865Z","_id":"clca67fe20000jjqq2ytb76v7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>We can learn Sui concepts from here:<br><a href=\"https://docs.sui.io/learn/how-sui-works\">https://docs.sui.io/learn/how-sui-works</a></p>\n<h1 id=\"SUI-CODE-ARCHITECTURE\"><a href=\"#SUI-CODE-ARCHITECTURE\" class=\"headerlink\" title=\"SUI CODE ARCHITECTURE\"></a>SUI CODE ARCHITECTURE</h1><p>The latest version of the code  is <code>devnet-0.17.0</code></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">git clone https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp</code></pre>\n\n<p>As we can see, the structure of the code is similar to Aptos.</p>\n<p>Different functions are organized in different packages in <code>sui/crates/ folder</code>.The most parts are those:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node</code></pre>\n\n<h2 id=\"cartes-x2F-sui\"><a href=\"#cartes-x2F-sui\" class=\"headerlink\" title=\"cartes&#x2F;sui\"></a>cartes&#x2F;sui</h2><p>Like Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in <code>crates/src/main.rc —&gt; fn main()</code>. Our entire code analysis process starts with this entry.</p>\n<p><img src=\"/../img/123.png\" alt=\"Untitled\"></p>\n<h2 id=\"other-packages\"><a href=\"#other-packages\" class=\"headerlink\" title=\"other packages\"></a>other packages</h2><ul>\n<li>sui-faucet - sui faucet related service.</li>\n<li>sui-node - node related</li>\n<li>sui-core - authority server and Sui Gateway</li>\n<li>sui-types - coins, gas, and other object types</li>\n<li>sui-network - networking interfaces</li>\n</ul>\n<h1 id=\"Build-Sui-and-run-local-testnet\"><a href=\"#Build-Sui-and-run-local-testnet\" class=\"headerlink\" title=\"Build Sui and run local testnet\"></a>Build Sui and run local testnet</h1><p>The Sui repository includes two primary branches, <code>devnet</code> and <code>main</code>.</p>\n<ul>\n<li>The <code>devnet</code> branch includes the latest stable build of Sui. Choose the <code>devnet</code> branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the <code>main</code> branch. To submit a pull request (PR), you should push commits to your fork of the <code>main</code> branch.</li>\n<li>The <code>main</code> branch includes the most recent changes and updates. Use the <code>main</code> branch if you want to contribute to the Sui project. The <code>main</code> branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.</li>\n</ul>\n<blockquote>\n<p><em>The previous</em> <code>git clone</code> <em>command syncs with the</em> <code>devnet</code> <em>branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don’t need to interact with our Devnet, you should switch to</em> <code>main</code> <em>branch.</em></p>\n</blockquote>\n<h2 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a><strong>Build</strong></h2><p>Cause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cargo install --locked --git https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git --branch devnet sui</code></pre>\n\n<p>This will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can’t compile, then change the system.</p>\n<p>I have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.</p>\n<p>It took about an hour to compile this.</p>\n<p><img src=\"/../img/1234.png\" alt=\"Untitled\"></p>\n<blockquote>\n<p>For more detail : <a href=\"https://docs.sui.io/build/install\">https://docs.sui.io/build/install</a></p>\n</blockquote>\n<p>After we compiled we can see the executable file in <code>~/.carge/bin/sui</code>. And the we can use it to run local testnet.</p>\n<p><img src=\"/../img/12345.png\" alt=\"Untitled\"></p>\n<h2 id=\"genesis\"><a href=\"#genesis\" class=\"headerlink\" title=\"genesis\"></a>genesis</h2><p>To create the configuration files and objects for a local Sui network, run the <code>genesis</code> command. Genesis creates the network configuration files in the <code>~/.sui/sui_config</code> folder. </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;network.yaml&quot;.\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;sui.keystore&quot;.\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;client.yaml&quot;.</code></pre>\n\n<p>This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.</p>\n<p>The network that genesis creates includes four validators and five user accounts that contain five coin objects each.</p>\n<p><img src=\"/../img/123456.png\" alt=\"Untitled\"></p>\n<h2 id=\"Start-the-local-network\"><a href=\"#Start-the-local-network\" class=\"headerlink\" title=\"Start the local network\"></a>Start the local network</h2><p>Run the following command to start the local Sui network with default configuration( <code>~/.sui/sui_config/network.yaml</code>).</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sui start</code></pre>\n\n<p><img src=\"/../img/23.jpeg\" alt=\"Untitled\"></p>\n<p>When you start the network, Sui generates an <code>authorities_db directory</code> that stores validator data, and a <code>consensus_db</code> directory that stores consensus data.</p>\n<p><img src=\"/../img/24.png\" alt=\"Untitled\"></p>\n<h1 id=\"Interact-with-Sui-local-network\"><a href=\"#Interact-with-Sui-local-network\" class=\"headerlink\" title=\"Interact with Sui local network\"></a>Interact with Sui local network</h1><h2 id=\"sui-client\"><a href=\"#sui-client\" class=\"headerlink\" title=\"sui client\"></a>sui client</h2><p>we can use Sui CLI to interact with Sui net</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~&#x2F;.sui&#x2F;sui_config directory\nsui console </code></pre>\n\n<p><img src=\"/../img/25.png\" alt=\"Untitled\"></p>\n<p>Some example:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100</code></pre>\n\n<p><img src=\"/../img/26.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/27.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/28.png\" alt=\"Untitled\"></p>\n<h1 id=\"Debug-Sui-with-vscode\"><a href=\"#Debug-Sui-with-vscode\" class=\"headerlink\" title=\"Debug Sui with vscode\"></a>Debug Sui with vscode</h1><p>In the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.</p>\n<p>Steps(on mac):</p>\n<ol>\n<li>install vscode and plug-in (rust-analyzer,CodeLLDB)</li>\n<li>open the sui folder</li>\n<li>open the target file</li>\n</ol>\n<p>create new launch.json file(will be automatically generated  ).</p>\n<p><img src=\"/../img/30.png\" alt=\"Untitled\"></p>\n<p>add args:</p>\n<p><img src=\"/../img/31.png\" alt=\"Untitled\"></p>\n<p>Start to debug:</p>\n<p><img src=\"/../img/33.png\" alt=\"Untitled\"></p>\n<p><strong>About MoveBit</strong></p>\n<p><strong>MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.</strong></p>\n<p>Twitter: <a href=\"https://twitter.com/MoveBit\">https://twitter.com/MoveBit</a>_<br>Medium: <a href=\"https://movebit.medium.com/\">https://movebit.medium.com/</a><br>Github: <a href=\"https://github.com/movebit\">https://github.com/movebit</a><br>Discord: <a href=\"https://discord.com/invite/7wM8VU9Gyj\">https://discord.com/invite/7wM8VU9Gyj</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>We can learn Sui concepts from here:<br><a href=\"https://docs.sui.io/learn/how-sui-works\">https://docs.sui.io/learn/how-sui-works</a></p>\n<h1 id=\"SUI-CODE-ARCHITECTURE\"><a href=\"#SUI-CODE-ARCHITECTURE\" class=\"headerlink\" title=\"SUI CODE ARCHITECTURE\"></a>SUI CODE ARCHITECTURE</h1><p>The latest version of the code  is <code>devnet-0.17.0</code></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">git clone https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp</code></pre>\n\n<p>As we can see, the structure of the code is similar to Aptos.</p>\n<p>Different functions are organized in different packages in <code>sui/crates/ folder</code>.The most parts are those:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node</code></pre>\n\n<h2 id=\"cartes-x2F-sui\"><a href=\"#cartes-x2F-sui\" class=\"headerlink\" title=\"cartes&#x2F;sui\"></a>cartes&#x2F;sui</h2><p>Like Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in <code>crates/src/main.rc —&gt; fn main()</code>. Our entire code analysis process starts with this entry.</p>\n<p><img src=\"/../img/123.png\" alt=\"Untitled\"></p>\n<h2 id=\"other-packages\"><a href=\"#other-packages\" class=\"headerlink\" title=\"other packages\"></a>other packages</h2><ul>\n<li>sui-faucet - sui faucet related service.</li>\n<li>sui-node - node related</li>\n<li>sui-core - authority server and Sui Gateway</li>\n<li>sui-types - coins, gas, and other object types</li>\n<li>sui-network - networking interfaces</li>\n</ul>\n<h1 id=\"Build-Sui-and-run-local-testnet\"><a href=\"#Build-Sui-and-run-local-testnet\" class=\"headerlink\" title=\"Build Sui and run local testnet\"></a>Build Sui and run local testnet</h1><p>The Sui repository includes two primary branches, <code>devnet</code> and <code>main</code>.</p>\n<ul>\n<li>The <code>devnet</code> branch includes the latest stable build of Sui. Choose the <code>devnet</code> branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the <code>main</code> branch. To submit a pull request (PR), you should push commits to your fork of the <code>main</code> branch.</li>\n<li>The <code>main</code> branch includes the most recent changes and updates. Use the <code>main</code> branch if you want to contribute to the Sui project. The <code>main</code> branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.</li>\n</ul>\n<blockquote>\n<p><em>The previous</em> <code>git clone</code> <em>command syncs with the</em> <code>devnet</code> <em>branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don’t need to interact with our Devnet, you should switch to</em> <code>main</code> <em>branch.</em></p>\n</blockquote>\n<h2 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a><strong>Build</strong></h2><p>Cause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cargo install --locked --git https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git --branch devnet sui</code></pre>\n\n<p>This will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can’t compile, then change the system.</p>\n<p>I have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.</p>\n<p>It took about an hour to compile this.</p>\n<p><img src=\"/../img/1234.png\" alt=\"Untitled\"></p>\n<blockquote>\n<p>For more detail : <a href=\"https://docs.sui.io/build/install\">https://docs.sui.io/build/install</a></p>\n</blockquote>\n<p>After we compiled we can see the executable file in <code>~/.carge/bin/sui</code>. And the we can use it to run local testnet.</p>\n<p><img src=\"/../img/12345.png\" alt=\"Untitled\"></p>\n<h2 id=\"genesis\"><a href=\"#genesis\" class=\"headerlink\" title=\"genesis\"></a>genesis</h2><p>To create the configuration files and objects for a local Sui network, run the <code>genesis</code> command. Genesis creates the network configuration files in the <code>~/.sui/sui_config</code> folder. </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;network.yaml&quot;.\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;sui.keystore&quot;.\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;client.yaml&quot;.</code></pre>\n\n<p>This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.</p>\n<p>The network that genesis creates includes four validators and five user accounts that contain five coin objects each.</p>\n<p><img src=\"/../img/123456.png\" alt=\"Untitled\"></p>\n<h2 id=\"Start-the-local-network\"><a href=\"#Start-the-local-network\" class=\"headerlink\" title=\"Start the local network\"></a>Start the local network</h2><p>Run the following command to start the local Sui network with default configuration( <code>~/.sui/sui_config/network.yaml</code>).</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sui start</code></pre>\n\n<p><img src=\"/../img/23.jpeg\" alt=\"Untitled\"></p>\n<p>When you start the network, Sui generates an <code>authorities_db directory</code> that stores validator data, and a <code>consensus_db</code> directory that stores consensus data.</p>\n<p><img src=\"/../img/24.png\" alt=\"Untitled\"></p>\n<h1 id=\"Interact-with-Sui-local-network\"><a href=\"#Interact-with-Sui-local-network\" class=\"headerlink\" title=\"Interact with Sui local network\"></a>Interact with Sui local network</h1><h2 id=\"sui-client\"><a href=\"#sui-client\" class=\"headerlink\" title=\"sui client\"></a>sui client</h2><p>we can use Sui CLI to interact with Sui net</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~&#x2F;.sui&#x2F;sui_config directory\nsui console </code></pre>\n\n<p><img src=\"/../img/25.png\" alt=\"Untitled\"></p>\n<p>Some example:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100</code></pre>\n\n<p><img src=\"/../img/26.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/27.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/28.png\" alt=\"Untitled\"></p>\n<h1 id=\"Debug-Sui-with-vscode\"><a href=\"#Debug-Sui-with-vscode\" class=\"headerlink\" title=\"Debug Sui with vscode\"></a>Debug Sui with vscode</h1><p>In the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.</p>\n<p>Steps(on mac):</p>\n<ol>\n<li>install vscode and plug-in (rust-analyzer,CodeLLDB)</li>\n<li>open the sui folder</li>\n<li>open the target file</li>\n</ol>\n<p>create new launch.json file(will be automatically generated  ).</p>\n<p><img src=\"/../img/30.png\" alt=\"Untitled\"></p>\n<p>add args:</p>\n<p><img src=\"/../img/31.png\" alt=\"Untitled\"></p>\n<p>Start to debug:</p>\n<p><img src=\"/../img/33.png\" alt=\"Untitled\"></p>\n<p><strong>About MoveBit</strong></p>\n<p><strong>MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.</strong></p>\n<p>Twitter: <a href=\"https://twitter.com/MoveBit\">https://twitter.com/MoveBit</a>_<br>Medium: <a href=\"https://movebit.medium.com/\">https://movebit.medium.com/</a><br>Github: <a href=\"https://github.com/movebit\">https://github.com/movebit</a><br>Discord: <a href=\"https://discord.com/invite/7wM8VU9Gyj\">https://discord.com/invite/7wM8VU9Gyj</a></p>\n"},{"title":"Bootstrap of Sui local testnet","date":"2023-01-03T06:30:50.000Z","description":"MoveBit will show you how to run and interact with Sui local testnet","thumbnail":"/img/icon.png","_content":"![Untitled](../img/305.png)\nSince the code of sui is updated very quickly and we do not need to connect to devnet, so we select the main branch to analyze.\n\n```bash\nbranch main\ncommit db5a090d56c8f1f065474f26a12e97dc0ee33e12\n```\n![Untitled](../img/300.png)\n\n# Sui package\n\nThe Sui package is in `sui/crates/sui` folder. It will be compiled into the sui command line tool. The files structure of this package is as follows:\n\n```bash\n➜  sui git:(main) tree\n.\n├── Cargo.toml\n├── build.rs\n├── genesis.md\n├── offline_signing.md\n├── src\n│   ├── client_commands.rs\n│   ├── config\n│   │   └── mod.rs\n│   ├── console.rs\n│   ├── genesis_ceremony.rs\n│   ├── keytool.rs\n│   ├── lib.rs\n│   ├── main.rs\n│   ├── shell.rs\n│   ├── sui_commands.rs\n│   ├── sui_move\n│   │   ├── build.rs\n│   │   ├── coverage.rs\n│   │   ├── disassemble.rs\n│   │   ├── mod.rs\n│   │   ├── new.rs\n│   │   ├── prove.rs\n│   │   ├── sui-natives.bpl\n│   │   └── unit_test.rs\n│   └── unit_tests\n│       ├── cli_tests.rs\n│       ├── data\n│       │   ├── dummy_modules_publish\n│       │   │   ├── Move.toml\n│       │   │   └── sources\n│       │   │       └── trusted_coin.move\n│       │   └── move_call_args_linter\n│       │       ├── Move.toml\n│       │       └── sources\n│       │           └── object_basics.move\n│       ├── keytool_tests.rs\n│       └── shell_tests.rs\n└── tests\n    ├── full_node_tests.rs\n    ├── move_test_code\n    │   ├── Move.toml\n    │   └── sources\n    │       └── shared_objects_version.move\n    ├── quorum_driver_tests.rs\n    ├── readme.rs\n    ├── reconfiguration_tests.rs\n    ├── shared_objects_tests.rs\n    ├── shared_objects_version_tests.rs\n    ├── simulator_tests.rs\n    └── transaction_orchestrator_tests.rs\n\n12 directories, 38 files\n```\n\n# sui genesis\n\nTo create the configuration files and objects for a local Sui network, run the `genesis` command. \n\nGenesis creates the network configuration files in the ~/.sui/sui_config folder. This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.\n\nLet's first look at how this command works.\n\n> Entrance：`sui/crates/sui/src/main.rs —> fn main()`\n> \n\nWhen we execute this command, we first parse the input parameters and then call `cmd.execute()`. This method will judge the input parameters and execute different codes for different commands.\n\n```rust\n//sui/crates/sui/src/main.rs\nasync fn main() {\n    #[cfg(windows)]\n    colored::control::set_virtual_terminal(true).unwrap();\n\n    let bin_name = env!(\"CARGO_BIN_NAME\");\n    let cmd: SuiCommand = SuiCommand::parse();\n    ...\n    exit_main!(cmd.execute().await);\n}\n```\n\nIf we use `sui genesis`.The `execute()` will match `SuiCommand::Genesis` .And the will call `genesis()`.\n\n```rust\n//sui/crates/sui/src/sui_commands.rs\nimpl SuiCommand {\n    pub async fn execute(self) -> Result<(), anyhow::Error> {\n        match self {\n            ...\n            SuiCommand::Genesis {\n                working_dir,\n                force,\n                from_config,\n                write_config,\n            } => genesis(from_config, write_config, working_dir, force).await,\n\t\t      ...   \n\t\t\t}\n    }\n}\n```\n\nThis method mainly does 3 things:\n\n1. read config from disk\n2. create some objects with those config value\n3. store important objects(Nodeconfig,genesis_conf & network_config) to disk\n\n## Read config\n\nIf we do not provide the config dir,It will create it with default parameter. \n\nsome default parameter:\n\n```rust\n//sui/crates/sui-config/src/ib.rs\nconst SUI_DIR: &str = \".sui\";\nconst SUI_CONFIG_DIR: &str = \"sui_config\";\npub const SUI_NETWORK_CONFIG: &str = \"network.yaml\";\npub const SUI_FULLNODE_CONFIG: &str = \"fullnode.yaml\";\npub const SUI_CLIENT_CONFIG: &str = \"client.yaml\";\npub const SUI_KEYSTORE_FILENAME: &str = \"sui.keystore\";\npub const SUI_GATEWAY_CONFIG: &str = \"gateway.yaml\";\npub const SUI_GENESIS_FILENAME: &str = \"genesis.blob\";\npub const SUI_DEV_NET_URL: &str = \"https://fullnode.devnet.sui.io:443\";\n\npub const AUTHORITIES_DB_NAME: &str = \"authorities_db\";\npub const CONSENSUS_DB_NAME: &str = \"consensus_db\";\npub const FULL_NODE_DB_PATH: &str = \"full_node_db\";\n\nconst DEFAULT_STAKE: StakeUnit = 100000000000000;\nconst DEFAULT_GAS_PRICE: u64 = 1;\nconst DEFAULT_COMMISSION_RATE: u64 = 0;\n\n//sui/crates/sui-config/src/genesis_config.rs\nconst DEFAULT_GAS_AMOUNT: u64 = 100000000000000;\nconst DEFAULT_NUMBER_OF_AUTHORITIES: usize = 4;\nconst DEFAULT_NUMBER_OF_ACCOUNT: usize = 5;\nconst DEFAULT_NUMBER_OF_OBJECT_PER_ACCOUNT: usize = 5;\n```\n\n```rust\n//sui/crates/sui/src/sui-commands.rs\nasync fn genesis(\n    from_config: Option<PathBuf>,\n    write_config: Option<PathBuf>,\n    working_dir: Option<PathBuf>,\n    force: bool,\n) -> Result<(), anyhow::Error> {\n    let sui_config_dir = &match working_dir {\n        // if a directory is specified, it must exist (it\n        // will not be created)\n        Some(v) => v,\n        // create default Sui config dir if not specified\n        // on the command line and if it does not exist\n        // yet\n        None => {\n            let config_path = sui_config_dir()?;\n            fs::create_dir_all(&config_path)?;\n            config_path\n        }\n    };\n\n     ...\n\t\tlet client_path = sui_config_dir.join(SUI_CLIENT_CONFIG);\n    let keystore_path = sui_config_dir.join(SUI_KEYSTORE_FILENAME);\n    ...\n\t\tlet network_path = sui_config_dir.join(SUI_NETWORK_CONFIG);\n    let genesis_path = sui_config_dir.join(SUI_GENESIS_FILENAME);\n\n    let mut genesis_conf = match from_config {\n        Some(path) => PersistedConfig::read(&path)?,\n        None => {\n            if keystore_path.exists() {\n                let existing_keys = FileBasedKeystore::new(&keystore_path)?.addresses();\n                GenesisConfig::for_local_testing_with_addresses(existing_keys)\n            } else {\n                GenesisConfig::for_local_testing()\n            }\n        }\n    };\n...\n```\n\n![Untitled](../img/301.png)\n\n## create objects\n\nGenerate some important objects according the given configuration files or default configuration parameters.\n\n- network_config\n- genesis_config\n- Client_config\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->genesis()\n\nlet mut network_config = if let Some(validators) = validator_info {\n        ConfigBuilder::new(sui_config_dir)\n            .initial_accounts_config(genesis_conf)\n            .with_validators(validators)\n            .build()\n    } else {\n        ConfigBuilder::new(sui_config_dir)\n            .committee_size(NonZeroUsize::new(genesis_conf.committee_size).unwrap())\n            .initial_accounts_config(genesis_conf)\n\t\t\t\t\t\t//will finally call build_with-calidators() in sui-config/src/builder.rs\n\t\t\t\t\t\t//to genesis NetworkConfig{} and Nodeconfig\n            .build()\n    };\n\n```\n\n![Untitled](../img/308.png)\n\n## store objects\n\nAfter all objects are generated, the `network_config , genesis, validator,keystore and client_config`  will be written to disk.\n\n```rust\n\n    let mut keystore = FileBasedKeystore::new(&keystore_path)?;\n    for key in &network_config.account_keys {\n        keystore.add_key(SuiKeyPair::Ed25519SuiKeyPair(key.copy()))?;\n    }\n\t\t//Take out the latest one in the keystore as active_address\n    let active_address = keystore.addresses().pop();\n\n    network_config.genesis.save(&genesis_path)?;\n    for validator in &mut network_config.validator_configs {\n        validator.genesis = sui_config::node::Genesis::new_from_file(&genesis_path);\n    }\n\n    info!(\"Network genesis completed.\");\n    network_config.save(&network_path)?;\n    info!(\"Network config file is stored in {:?}.\", network_path);\n\n    info!(\"Client keystore is stored in {:?}.\", keystore_path);\n\n    let mut fullnode_config = network_config.generate_fullnode_config();\n    fullnode_config.json_rpc_address = sui_config::node::default_json_rpc_address();\n    fullnode_config.save(sui_config_dir.join(SUI_FULLNODE_CONFIG))?;\n\n    for (i, validator) in network_config\n        .into_validator_configs()\n        .into_iter()\n        .enumerate()\n    {\n        let path = sui_config_dir.join(format!(\"validator-config-{}.yaml\", i));\n        validator.save(path)?;\n    }\n\n    let mut client_config = if client_path.exists() {\n        PersistedConfig::read(&client_path)?\n    } else {\n        SuiClientConfig::new(keystore.into())\n    };\n\t\t...\n    client_config.save(&client_path)?;\n    info!(\"Client config file is stored in {:?}.\", client_path);\n\n    Ok(())\n```\n\nWe can get the detail from the output log.\n\n```rust\n2022-12-13T08:12:04.072712Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-13T08:16:33.039813Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-13T08:16:33.069233Z  INFO sui::sui_commands: Network config file is stored in \"/Users/safeer/.sui/sui_config/network.yaml\".\n2022-12-13T08:16:33.069286Z  INFO sui::sui_commands: Client keystore is stored in \"/Users/safeer/.sui/sui_config/sui.keystore\".\n2022-12-13T08:18:02.582274Z  INFO sui::sui_commands: Client config file is stored in \"/Users/safeer/.sui/sui_config/client.yaml\"\n```\n\n```rust\n➜  sui_config tree\n.\n├── client.yaml\n├── fullnode.yaml\n├── genesis.blob\n├── network.yaml\n├── sui.keystore\n├── validator-config-0.yaml\n├── validator-config-1.yaml\n├── validator-config-2.yaml\n└── validator-config-3.yaml\n```\n\n\n# sui start\n\nRun `sui start` to start the local Sui network with default location for configuration.\n\nThis command looks for the Sui network configuration file `network.yaml` in the `~/.sui/sui_config` directory. If there is no configuration in this directory, it will call genesis() to genesis the default configuration first.\n\nThe sui node is divided into validator and full node:\n\n- validator: validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected Full nodes that then service the queries from clients.\n- full node:Sui Full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each Full node stores and services the queries for the blockchain state and history.\n\nIt will do those things:\n\n1. read configuration from disk(will call  genesis() to auto genesis if path is none)\n2. build swarm with network_config(by default the swarm will contain 4 validators )\n3. call swarm.launch() to start 4 validators.\n4. run health Check service.\n\n## read configuration\n\nBefore we used `sui genesis` to generate configuration files and perform storage persistence management.Here we will take it out, and then use these configuration files to generate `network_config` objects.\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->execute()\nSuiCommand::Start {\n                config,\n                no_full_node,\n            } => {\n              ... \n\t\t\t\t\t\t\tlet network_config: NetworkConfig = PersistedConfig::read(&network_config_path)\n                    .map_err(|err| {\n                        err.context(format!(\n                            \"Cannot open Sui network config file at {:?}\",\n                            network_config_path\n                        ))\n                    })?;\n\n//sui/crates/sui-config/src/lib.rs\nfn load<P: AsRef<Path>>(path: P) -> Result<Self, anyhow::Error> {\n        let path = path.as_ref();\n        trace!(\"Reading config from {}\", path.display());\n        let reader = fs::File::open(path)\n            .with_context(|| format!(\"Unable to load config from {}\", path.display()))?;\n        Ok(serde_yaml::from_reader(reader)?)\n    }\n```\n\n![Untitled](../img/302.png)\n\n## build swarm\n\nSwarm is a handle to an in-memory Sui network.It contain a network_config and validators.\n\n```rust\n//sui/crates/sui-swarm/src/memory/swarm.rs\n/// A handle to an in-memory Sui Network.\n#[derive(Debug)]\npub struct Swarm {\n    dir: SwarmDirectory,\n    network_config: NetworkConfig,\n    validators: HashMap<SuiAddress, Node>,\n    fullnodes: HashMap<SuiAddress, Node>,\n}\n```\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->execute() \nlet mut swarm = if no_full_node {\n                    Swarm::builder()\n                } else {\n                    Swarm::builder()\n                        .with_fullnode_rpc_addr(sui_config::node::default_json_rpc_address())\n                }\n                .from_network_config(sui_config_dir()?, network_config);\n```\n\n![Untitled](../img/303.png)\n\n## run validators\n\nAfter we build the swarm, we can use it to run each validator.\n\nThe whole process is:\n\n`//node.spawn()-->Container::spawn()-->SuiNode::start()`\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->execute() \n\nswarm.launch().await?;\n\n//sui/crates/sui-swarm/src/memory/swarm.rs\n/// Start all of the Validators associated with this Swarm\n    pub async fn launch(&mut self) -> Result<()> {\n        let start_handles = self\n            .nodes_iter_mut()\n            .map(|node| node.spawn())\n            .collect::<Result<Vec<_>>>()?;\n\n        try_join_all(start_handles).await?;\n\n        Ok(())\n    }\n\n////sui/crates/sui-swarm/src/memory/node.rs\n\n/// Start this Node, returning a handle that will resolve when the node has completed starting\n    /// up.\n    pub fn spawn(&mut self) -> Result<tokio::sync::oneshot::Receiver<()>> {\n        trace!(name =% self.name(), \"starting in-memory node\");\n        let (startup_receiver, node_handle) =\n            Container::spawn(self.config.clone(), self.runtime_type);\n        self.thread = Some(node_handle);\n        Ok(startup_receiver)\n    }\n\n////sui/crates/sui-swarm/src/memory/container.rs-->spawn()\n\nruntime.block_on(async move {\n                let prometheus_registry = metrics::start_prometheus_server(config.metrics_address);\n                info!(\n                    \"Started Prometheus HTTP endpoint. To query metrics use\\n\\tcurl -s http://{}/metrics\",\n                    config.metrics_address\n                );\n                let _server = SuiNode::start(&config, prometheus_registry).await.unwrap();\n                // Notify that we've successfully started the node\n                let _ = startup_sender.send(());\n                // run until canceled\n                cancel_reciever.map(|_| ()).await;\n```\n\n### SuiNode\n\nSuinode is the smallest unit of node management and is a very important object.It contains almost all the functions that a node needs to implement. The focus of our follow-up analysis is here.\n\nThe main members of it are:\n\n- config\n- checkpoint_store\n- _batch_subsystem_handle\n- _execute_driver_handle\n- state\n- active\n- _p2p_network\n- _discovery\n- _state_sync\n- sim_node\n\n```rust\n\n//sui/crates/sui-node/src/lib.rs\n\npub struct SuiNode {\n    config: NodeConfig,\n    checkpoint_store: Arc<CheckpointStore>,\n    validator_server_info: Option<ValidatorServerInfo>,\n    _json_rpc_service: Option<ServerHandle>,\n    _batch_subsystem_handle: tokio::task::JoinHandle<()>,\n    _post_processing_subsystem_handle: Option<tokio::task::JoinHandle<Result<()>>>,\n    _gossip_handle: Option<tokio::task::JoinHandle<()>>,\n    _execute_driver_handle: tokio::task::JoinHandle<()>,\n    state: Arc<AuthorityState>,\n    active: Arc<ActiveAuthority<NetworkAuthorityClient>>,\n    transaction_orchestrator: Option<Arc<TransactiondOrchestrator<NetworkAuthorityClient>>>,\n    _prometheus_registry: Registry,\n\n    _p2p_network: anemo::Network,\n    _discovery: discovery::Handle,\n    _state_sync: state_sync::Handle,\n\n    reconfig_channel: (\n        tokio::sync::mpsc::Sender<EpochId>,\n        tokio::sync::mpsc::Receiver<EpochId>,\n    ),\n\n    #[cfg(msim)]\n    sim_node: sui_simulator::runtime::NodeHandle,\n}\n\n```\n\nNow let's analyze the detailed steps in the node startup process:\n\n1. Judging whether it is fullnode or validator\n2. Initialize DB(committee_store,checkpoint_store,state_sync_store,index_store,event_store)\n3. create p2p network(discovery_handle,state_sync_handle)\n4. create transaction_streamer (if it’s fullNode)\n5. create node_sync_store\n6. create handles(batch_subsystem_handle,post_processing_subsystem_handle,execute_driver_handle)\n7. create json_rpc_service\n8. finish start up\n\n```rust\n\n//sui/crates/sui-node/src/lib.rs\npub async fn start(config: &NodeConfig, prometheus_registry: Registry) -> Result<SuiNode> {\n        ...\n        let store =\n            Arc::new(AuthorityStore::open(&config.db_path().join(\"store\"), None, genesis).await?);\n        let committee_store = Arc::new(CommitteeStore::new(\n            config.db_path().join(\"epochs\"),\n            &committee,\n            None,\n        ));\n        let checkpoint_store = CheckpointStore::new(&config.db_path().join(\"checkpoints\"));\n\n        let state_sync_store = RocksDbStore::new(\n            store.clone(),\n            committee_store.clone(),\n            checkpoint_store.clone(),\n        );\n\n        let index_store = if is_validator {\n            None\n        } else {\n            Some(Arc::new(IndexStore::open_tables_read_write(\n                config.db_path().join(\"indexes\"),\n                None,\n                None,\n            )))\n        };\n\n        let event_store = if config.enable_event_processing {\n            let path = config.db_path().join(\"events.db\");\n            let db = SqlEventStore::new_from_file(&path).await?;\n            db.initialize().await?;\n            Some(Arc::new(EventStoreType::SqlEventStore(db)))\n        } else {\n            None\n        };\n\n        let (p2p_network, discovery_handle, state_sync_handle) =\n            Self::create_p2p_network(config, state_sync_store, &prometheus_registry)?;\n\n       ...\n        let node_sync_store = Arc::new(NodeSyncStore::open_tables_read_write(\n            config.db_path().join(\"node_sync_db\"),\n            None,\n            None,\n        ));\n\n        ...\n\n        let batch_subsystem_handle = {\n            // Start batch system so that this node can be followed\n            let batch_state = state.clone();\n            spawn_monitored_task!(async move {\n                batch_state\n                    .run_batch_service(1000, Duration::from_secs(1))\n                    .await\n            })\n        };\n\n        let post_processing_subsystem_handle =\n            if index_store.is_some() || config.enable_event_processing {\n                let indexing_state = state.clone();\n                Some(spawn_monitored_task!(async move {\n                    indexing_state\n                        .run_tx_post_processing_process()\n                        .await\n                        .map_err(Into::into)\n                }))\n            } else {\n                None\n            };\n\n        \n        let execute_driver_handle = active_authority.clone().spawn_execute_process().await;\n\t\t\t\t...\n        let json_rpc_service = build_server(\n            state.clone(),\n            &transaction_orchestrator.clone(),\n            config,\n            &prometheus_registry,\n        )\n        .await?;\n\n\t\t\t ...\n\n        info!(\"SuiNode started!\");\n\n        Ok(node)\n```\n\n![Untitled](../img/304.png)\n\nWe can get more info from the debug output.(here we only focus on the startup information of one node: 0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a).\n\n```bash\nLaunching: /Users/safeer/sui/target/debug/sui start\nLaunched process 80154\n2022-12-14T08:59:58.765242Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n\tcurl -s http://127.0.0.1:52424/metrics\n2022-12-14T08:59:58.765242Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n2022-12-14T09:00:12.433291Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_node: Initializing sui-node listening on /ip4/127.0.0.1/tcp/52420/http node=k#8c26601d82aac59fade53f345f8fe84239d69652142a7fdc7724f729a1716a07e16b07a91e5afd49ee45d5cc6f5f3a9e0d152797d9251f2be21811a764a2dea2539c3b7541d52bf2e78b4d256bd94daa193f0c2234ec76276b80c6f0fedf4274\n2022-12-14T09:00:12.435263Z  WARN node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: mysten_metrics: init_metrics registry overwritten\n2022-12-14T09:13:51.573049Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Created/opened SQLite EventStore on disk db_path=\"/Users/safeer/.sui/sui_config/authorities_db/2727618050/events.db\"\n2022-12-14T09:13:56.940186Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: SQLite events table is initialized with query \"CREATE TABLE IF NOT EXISTS events(timestamp INTEGER NOT NULL, seq_num INTEGER, event_num INTEGER, tx_digest BLOB, event_type INTEGER, package_id BLOB, module_name TEXT, function TEXT, object_type TEXT, object_id BLOB, fields TEXT, move_event_name TEXT, contents BLOB, sender BLOB, recipient TEXT);\"\n2022-12-14T09:14:05.392089Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"seq_num\"\n2022-12-14T09:14:10.311911Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"event_num\"\n2022-12-14T09:14:13.542209Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"timestamp\"\n2022-12-14T09:14:17.262100Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"tx_digest\"\n2022-12-14T09:14:20.959975Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"event_type\"\n2022-12-14T09:14:26.008174Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"package_id\"\n2022-12-14T09:14:30.079815Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"module_name\"\n2022-12-14T09:14:36.559934Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"sender\"\n2022-12-14T09:14:36.567273Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"recipient\"\n2022-12-14T09:14:36.574490Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"object_id\"\n2022-12-14T09:14:36.582455Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"object_type\"\n2022-12-14T09:14:36.589734Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"move_event_name\"\n2022-12-14T09:14:36.598456Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_node: P2p network started on 127.0.0.1:52422\n2022-12-14T09:14:43.930692Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_core::authority_active: respawn_node_sync_process epoch=0\n2022-12-14T09:14:43.931350Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_core::authority_active: spawning node sync task\n2022-12-14T09:14:46.921729Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_json_rpc: acl=Const(\"*\")\n2022-12-14T09:14:46.922716Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_json_rpc: Sui JSON-RPC server listening on 0.0.0.0:9000 local_addr=0.0.0.0:9000\n2022-12-14T09:14:46.922772Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_json_rpc: Available JSON-RPC methods : [\"sui_moveCall\", \"sui_getCoinMetadata\", \"sui_publish\", \"sui_getObjectsOwnedByAddress\", \"sui_payAllSui\", \"sui_transferObject\", \"sui_unsubscribeEvent\", \"sui_executeTransaction\", \"sui_mergeCoins\", \"sui_subscribeTransaction\", \"sui_getEvents\", \"sui_getObject\", \"sui_getTransactionsInRange\", \"sui_getObjectsOwnedByObject\", \"sui_executeTransactionSerializedSig\", \"sui_subscribeEvent\", \"sui_paySui\", \"sui_getRawObject\", \"sui_splitCoin\", \"sui_getNormalizedMoveFunction\", \"sui_getTransaction\", \"sui_getTotalTransactionNumber\", \"sui_pay\", \"sui_getTransactionAuthSigners\", \"sui_getMoveFunctionArgTypes\", \"sui_transferSui\", \"sui_batchTransaction\", \"sui_unsubscribeTransaction\", \"sui_dryRunTransaction\", \"sui_splitCoinEqual\", \"sui_getNormalizedMoveModule\", \"sui_getNormalizedMoveModulesByPackage\", \"sui_tryGetPastObject\", \"rpc.discover\", \"sui_getTransactions\", \"sui_getCommitteeInfo\", \"sui_getNormalizedMoveStruct\"]\n2022-12-14T09:14:58.627411Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_node: SuiNode started!\n2022-12-14T09:15:08.957227Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}:connection-manager{peer=82a014fa}: anemo::network::connection_manager: ConnectionManager started\n2022-12-14T09:15:08.957369Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_network::discovery: Discovery started\n2022-12-14T09:15:08.957515Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_network::state_sync: State-Synchronizer started\n2022-12-14T09:15:08.960911Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_core::authority_active::execution_driver: Starting pending certificates execution process.\n```\n\n## health check\n\nAfter starting the nodes,Performing a health check service to check that status of the node(Check every 5 seconds).\n\n```rust\n\n////sui/crates/sui-swarm/src/memory/node.rs-->spawn()\n\n/// Perform a health check on this Node by:\n    /// * Checking that the node is running\n    /// * Calling the Node's gRPC Health service if it's a validator.\n    pub async fn health_check(&self, is_validator: bool) -> Result<(), HealthCheckError> {\n        let thread = self.thread.as_ref().ok_or(HealthCheckError::NotRunning)?;\n        if !thread.is_alive() {\n            return Err(HealthCheckError::NotRunning);\n        }\n\n        if is_validator {\n            let channel = mysten_network::client::connect(self.config.network_address())\n                .await\n                .map_err(|err| anyhow!(err.to_string()))\n                .map_err(HealthCheckError::Failure)\n                .tap_err(|e| error!(\"error connecting to {}: {e}\", self.name()))?;\n\n            let mut client = tonic_health::proto::health_client::HealthClient::new(channel);\n            client\n                .check(tonic_health::proto::HealthCheckRequest::default())\n                .await\n                .map_err(|e| HealthCheckError::Failure(e.into()))\n                .tap_err(|e| error!(\"error performing health check on {}: {e}\", self.name()))?;\n        }\n\n        Ok(())\n    }\n```\n\n# **Summarize**\nWe analyzed the startup process of the node in this page. \n\n- reading the configuration file\n- generating objects according to the configuration file\n- open services during the node startup process\n\nIn the following articles, we will analyze each part in detail, the most important of which is to analyze the various services opened during the node startup process(SuiNode object).","source":"_posts/02-Bootstrap of Sui local testnet 7860ec878e8f42c98a7c754b3afd2d30.md","raw":"---\ntitle: Bootstrap of Sui local testnet\ndate: 2023-01-03 14:30:50\ntags: Sui blockchain,Sui,Move Language\ndescription: MoveBit will show you how to run and interact with Sui local testnet\nthumbnail: /img/icon.png\n---\n![Untitled](../img/305.png)\nSince the code of sui is updated very quickly and we do not need to connect to devnet, so we select the main branch to analyze.\n\n```bash\nbranch main\ncommit db5a090d56c8f1f065474f26a12e97dc0ee33e12\n```\n![Untitled](../img/300.png)\n\n# Sui package\n\nThe Sui package is in `sui/crates/sui` folder. It will be compiled into the sui command line tool. The files structure of this package is as follows:\n\n```bash\n➜  sui git:(main) tree\n.\n├── Cargo.toml\n├── build.rs\n├── genesis.md\n├── offline_signing.md\n├── src\n│   ├── client_commands.rs\n│   ├── config\n│   │   └── mod.rs\n│   ├── console.rs\n│   ├── genesis_ceremony.rs\n│   ├── keytool.rs\n│   ├── lib.rs\n│   ├── main.rs\n│   ├── shell.rs\n│   ├── sui_commands.rs\n│   ├── sui_move\n│   │   ├── build.rs\n│   │   ├── coverage.rs\n│   │   ├── disassemble.rs\n│   │   ├── mod.rs\n│   │   ├── new.rs\n│   │   ├── prove.rs\n│   │   ├── sui-natives.bpl\n│   │   └── unit_test.rs\n│   └── unit_tests\n│       ├── cli_tests.rs\n│       ├── data\n│       │   ├── dummy_modules_publish\n│       │   │   ├── Move.toml\n│       │   │   └── sources\n│       │   │       └── trusted_coin.move\n│       │   └── move_call_args_linter\n│       │       ├── Move.toml\n│       │       └── sources\n│       │           └── object_basics.move\n│       ├── keytool_tests.rs\n│       └── shell_tests.rs\n└── tests\n    ├── full_node_tests.rs\n    ├── move_test_code\n    │   ├── Move.toml\n    │   └── sources\n    │       └── shared_objects_version.move\n    ├── quorum_driver_tests.rs\n    ├── readme.rs\n    ├── reconfiguration_tests.rs\n    ├── shared_objects_tests.rs\n    ├── shared_objects_version_tests.rs\n    ├── simulator_tests.rs\n    └── transaction_orchestrator_tests.rs\n\n12 directories, 38 files\n```\n\n# sui genesis\n\nTo create the configuration files and objects for a local Sui network, run the `genesis` command. \n\nGenesis creates the network configuration files in the ~/.sui/sui_config folder. This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.\n\nLet's first look at how this command works.\n\n> Entrance：`sui/crates/sui/src/main.rs —> fn main()`\n> \n\nWhen we execute this command, we first parse the input parameters and then call `cmd.execute()`. This method will judge the input parameters and execute different codes for different commands.\n\n```rust\n//sui/crates/sui/src/main.rs\nasync fn main() {\n    #[cfg(windows)]\n    colored::control::set_virtual_terminal(true).unwrap();\n\n    let bin_name = env!(\"CARGO_BIN_NAME\");\n    let cmd: SuiCommand = SuiCommand::parse();\n    ...\n    exit_main!(cmd.execute().await);\n}\n```\n\nIf we use `sui genesis`.The `execute()` will match `SuiCommand::Genesis` .And the will call `genesis()`.\n\n```rust\n//sui/crates/sui/src/sui_commands.rs\nimpl SuiCommand {\n    pub async fn execute(self) -> Result<(), anyhow::Error> {\n        match self {\n            ...\n            SuiCommand::Genesis {\n                working_dir,\n                force,\n                from_config,\n                write_config,\n            } => genesis(from_config, write_config, working_dir, force).await,\n\t\t      ...   \n\t\t\t}\n    }\n}\n```\n\nThis method mainly does 3 things:\n\n1. read config from disk\n2. create some objects with those config value\n3. store important objects(Nodeconfig,genesis_conf & network_config) to disk\n\n## Read config\n\nIf we do not provide the config dir,It will create it with default parameter. \n\nsome default parameter:\n\n```rust\n//sui/crates/sui-config/src/ib.rs\nconst SUI_DIR: &str = \".sui\";\nconst SUI_CONFIG_DIR: &str = \"sui_config\";\npub const SUI_NETWORK_CONFIG: &str = \"network.yaml\";\npub const SUI_FULLNODE_CONFIG: &str = \"fullnode.yaml\";\npub const SUI_CLIENT_CONFIG: &str = \"client.yaml\";\npub const SUI_KEYSTORE_FILENAME: &str = \"sui.keystore\";\npub const SUI_GATEWAY_CONFIG: &str = \"gateway.yaml\";\npub const SUI_GENESIS_FILENAME: &str = \"genesis.blob\";\npub const SUI_DEV_NET_URL: &str = \"https://fullnode.devnet.sui.io:443\";\n\npub const AUTHORITIES_DB_NAME: &str = \"authorities_db\";\npub const CONSENSUS_DB_NAME: &str = \"consensus_db\";\npub const FULL_NODE_DB_PATH: &str = \"full_node_db\";\n\nconst DEFAULT_STAKE: StakeUnit = 100000000000000;\nconst DEFAULT_GAS_PRICE: u64 = 1;\nconst DEFAULT_COMMISSION_RATE: u64 = 0;\n\n//sui/crates/sui-config/src/genesis_config.rs\nconst DEFAULT_GAS_AMOUNT: u64 = 100000000000000;\nconst DEFAULT_NUMBER_OF_AUTHORITIES: usize = 4;\nconst DEFAULT_NUMBER_OF_ACCOUNT: usize = 5;\nconst DEFAULT_NUMBER_OF_OBJECT_PER_ACCOUNT: usize = 5;\n```\n\n```rust\n//sui/crates/sui/src/sui-commands.rs\nasync fn genesis(\n    from_config: Option<PathBuf>,\n    write_config: Option<PathBuf>,\n    working_dir: Option<PathBuf>,\n    force: bool,\n) -> Result<(), anyhow::Error> {\n    let sui_config_dir = &match working_dir {\n        // if a directory is specified, it must exist (it\n        // will not be created)\n        Some(v) => v,\n        // create default Sui config dir if not specified\n        // on the command line and if it does not exist\n        // yet\n        None => {\n            let config_path = sui_config_dir()?;\n            fs::create_dir_all(&config_path)?;\n            config_path\n        }\n    };\n\n     ...\n\t\tlet client_path = sui_config_dir.join(SUI_CLIENT_CONFIG);\n    let keystore_path = sui_config_dir.join(SUI_KEYSTORE_FILENAME);\n    ...\n\t\tlet network_path = sui_config_dir.join(SUI_NETWORK_CONFIG);\n    let genesis_path = sui_config_dir.join(SUI_GENESIS_FILENAME);\n\n    let mut genesis_conf = match from_config {\n        Some(path) => PersistedConfig::read(&path)?,\n        None => {\n            if keystore_path.exists() {\n                let existing_keys = FileBasedKeystore::new(&keystore_path)?.addresses();\n                GenesisConfig::for_local_testing_with_addresses(existing_keys)\n            } else {\n                GenesisConfig::for_local_testing()\n            }\n        }\n    };\n...\n```\n\n![Untitled](../img/301.png)\n\n## create objects\n\nGenerate some important objects according the given configuration files or default configuration parameters.\n\n- network_config\n- genesis_config\n- Client_config\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->genesis()\n\nlet mut network_config = if let Some(validators) = validator_info {\n        ConfigBuilder::new(sui_config_dir)\n            .initial_accounts_config(genesis_conf)\n            .with_validators(validators)\n            .build()\n    } else {\n        ConfigBuilder::new(sui_config_dir)\n            .committee_size(NonZeroUsize::new(genesis_conf.committee_size).unwrap())\n            .initial_accounts_config(genesis_conf)\n\t\t\t\t\t\t//will finally call build_with-calidators() in sui-config/src/builder.rs\n\t\t\t\t\t\t//to genesis NetworkConfig{} and Nodeconfig\n            .build()\n    };\n\n```\n\n![Untitled](../img/308.png)\n\n## store objects\n\nAfter all objects are generated, the `network_config , genesis, validator,keystore and client_config`  will be written to disk.\n\n```rust\n\n    let mut keystore = FileBasedKeystore::new(&keystore_path)?;\n    for key in &network_config.account_keys {\n        keystore.add_key(SuiKeyPair::Ed25519SuiKeyPair(key.copy()))?;\n    }\n\t\t//Take out the latest one in the keystore as active_address\n    let active_address = keystore.addresses().pop();\n\n    network_config.genesis.save(&genesis_path)?;\n    for validator in &mut network_config.validator_configs {\n        validator.genesis = sui_config::node::Genesis::new_from_file(&genesis_path);\n    }\n\n    info!(\"Network genesis completed.\");\n    network_config.save(&network_path)?;\n    info!(\"Network config file is stored in {:?}.\", network_path);\n\n    info!(\"Client keystore is stored in {:?}.\", keystore_path);\n\n    let mut fullnode_config = network_config.generate_fullnode_config();\n    fullnode_config.json_rpc_address = sui_config::node::default_json_rpc_address();\n    fullnode_config.save(sui_config_dir.join(SUI_FULLNODE_CONFIG))?;\n\n    for (i, validator) in network_config\n        .into_validator_configs()\n        .into_iter()\n        .enumerate()\n    {\n        let path = sui_config_dir.join(format!(\"validator-config-{}.yaml\", i));\n        validator.save(path)?;\n    }\n\n    let mut client_config = if client_path.exists() {\n        PersistedConfig::read(&client_path)?\n    } else {\n        SuiClientConfig::new(keystore.into())\n    };\n\t\t...\n    client_config.save(&client_path)?;\n    info!(\"Client config file is stored in {:?}.\", client_path);\n\n    Ok(())\n```\n\nWe can get the detail from the output log.\n\n```rust\n2022-12-13T08:12:04.072712Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-13T08:16:33.039813Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-13T08:16:33.069233Z  INFO sui::sui_commands: Network config file is stored in \"/Users/safeer/.sui/sui_config/network.yaml\".\n2022-12-13T08:16:33.069286Z  INFO sui::sui_commands: Client keystore is stored in \"/Users/safeer/.sui/sui_config/sui.keystore\".\n2022-12-13T08:18:02.582274Z  INFO sui::sui_commands: Client config file is stored in \"/Users/safeer/.sui/sui_config/client.yaml\"\n```\n\n```rust\n➜  sui_config tree\n.\n├── client.yaml\n├── fullnode.yaml\n├── genesis.blob\n├── network.yaml\n├── sui.keystore\n├── validator-config-0.yaml\n├── validator-config-1.yaml\n├── validator-config-2.yaml\n└── validator-config-3.yaml\n```\n\n\n# sui start\n\nRun `sui start` to start the local Sui network with default location for configuration.\n\nThis command looks for the Sui network configuration file `network.yaml` in the `~/.sui/sui_config` directory. If there is no configuration in this directory, it will call genesis() to genesis the default configuration first.\n\nThe sui node is divided into validator and full node:\n\n- validator: validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected Full nodes that then service the queries from clients.\n- full node:Sui Full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each Full node stores and services the queries for the blockchain state and history.\n\nIt will do those things:\n\n1. read configuration from disk(will call  genesis() to auto genesis if path is none)\n2. build swarm with network_config(by default the swarm will contain 4 validators )\n3. call swarm.launch() to start 4 validators.\n4. run health Check service.\n\n## read configuration\n\nBefore we used `sui genesis` to generate configuration files and perform storage persistence management.Here we will take it out, and then use these configuration files to generate `network_config` objects.\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->execute()\nSuiCommand::Start {\n                config,\n                no_full_node,\n            } => {\n              ... \n\t\t\t\t\t\t\tlet network_config: NetworkConfig = PersistedConfig::read(&network_config_path)\n                    .map_err(|err| {\n                        err.context(format!(\n                            \"Cannot open Sui network config file at {:?}\",\n                            network_config_path\n                        ))\n                    })?;\n\n//sui/crates/sui-config/src/lib.rs\nfn load<P: AsRef<Path>>(path: P) -> Result<Self, anyhow::Error> {\n        let path = path.as_ref();\n        trace!(\"Reading config from {}\", path.display());\n        let reader = fs::File::open(path)\n            .with_context(|| format!(\"Unable to load config from {}\", path.display()))?;\n        Ok(serde_yaml::from_reader(reader)?)\n    }\n```\n\n![Untitled](../img/302.png)\n\n## build swarm\n\nSwarm is a handle to an in-memory Sui network.It contain a network_config and validators.\n\n```rust\n//sui/crates/sui-swarm/src/memory/swarm.rs\n/// A handle to an in-memory Sui Network.\n#[derive(Debug)]\npub struct Swarm {\n    dir: SwarmDirectory,\n    network_config: NetworkConfig,\n    validators: HashMap<SuiAddress, Node>,\n    fullnodes: HashMap<SuiAddress, Node>,\n}\n```\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->execute() \nlet mut swarm = if no_full_node {\n                    Swarm::builder()\n                } else {\n                    Swarm::builder()\n                        .with_fullnode_rpc_addr(sui_config::node::default_json_rpc_address())\n                }\n                .from_network_config(sui_config_dir()?, network_config);\n```\n\n![Untitled](../img/303.png)\n\n## run validators\n\nAfter we build the swarm, we can use it to run each validator.\n\nThe whole process is:\n\n`//node.spawn()-->Container::spawn()-->SuiNode::start()`\n\n```rust\n//sui/crates/sui/src/sui_commands.rs-->execute() \n\nswarm.launch().await?;\n\n//sui/crates/sui-swarm/src/memory/swarm.rs\n/// Start all of the Validators associated with this Swarm\n    pub async fn launch(&mut self) -> Result<()> {\n        let start_handles = self\n            .nodes_iter_mut()\n            .map(|node| node.spawn())\n            .collect::<Result<Vec<_>>>()?;\n\n        try_join_all(start_handles).await?;\n\n        Ok(())\n    }\n\n////sui/crates/sui-swarm/src/memory/node.rs\n\n/// Start this Node, returning a handle that will resolve when the node has completed starting\n    /// up.\n    pub fn spawn(&mut self) -> Result<tokio::sync::oneshot::Receiver<()>> {\n        trace!(name =% self.name(), \"starting in-memory node\");\n        let (startup_receiver, node_handle) =\n            Container::spawn(self.config.clone(), self.runtime_type);\n        self.thread = Some(node_handle);\n        Ok(startup_receiver)\n    }\n\n////sui/crates/sui-swarm/src/memory/container.rs-->spawn()\n\nruntime.block_on(async move {\n                let prometheus_registry = metrics::start_prometheus_server(config.metrics_address);\n                info!(\n                    \"Started Prometheus HTTP endpoint. To query metrics use\\n\\tcurl -s http://{}/metrics\",\n                    config.metrics_address\n                );\n                let _server = SuiNode::start(&config, prometheus_registry).await.unwrap();\n                // Notify that we've successfully started the node\n                let _ = startup_sender.send(());\n                // run until canceled\n                cancel_reciever.map(|_| ()).await;\n```\n\n### SuiNode\n\nSuinode is the smallest unit of node management and is a very important object.It contains almost all the functions that a node needs to implement. The focus of our follow-up analysis is here.\n\nThe main members of it are:\n\n- config\n- checkpoint_store\n- _batch_subsystem_handle\n- _execute_driver_handle\n- state\n- active\n- _p2p_network\n- _discovery\n- _state_sync\n- sim_node\n\n```rust\n\n//sui/crates/sui-node/src/lib.rs\n\npub struct SuiNode {\n    config: NodeConfig,\n    checkpoint_store: Arc<CheckpointStore>,\n    validator_server_info: Option<ValidatorServerInfo>,\n    _json_rpc_service: Option<ServerHandle>,\n    _batch_subsystem_handle: tokio::task::JoinHandle<()>,\n    _post_processing_subsystem_handle: Option<tokio::task::JoinHandle<Result<()>>>,\n    _gossip_handle: Option<tokio::task::JoinHandle<()>>,\n    _execute_driver_handle: tokio::task::JoinHandle<()>,\n    state: Arc<AuthorityState>,\n    active: Arc<ActiveAuthority<NetworkAuthorityClient>>,\n    transaction_orchestrator: Option<Arc<TransactiondOrchestrator<NetworkAuthorityClient>>>,\n    _prometheus_registry: Registry,\n\n    _p2p_network: anemo::Network,\n    _discovery: discovery::Handle,\n    _state_sync: state_sync::Handle,\n\n    reconfig_channel: (\n        tokio::sync::mpsc::Sender<EpochId>,\n        tokio::sync::mpsc::Receiver<EpochId>,\n    ),\n\n    #[cfg(msim)]\n    sim_node: sui_simulator::runtime::NodeHandle,\n}\n\n```\n\nNow let's analyze the detailed steps in the node startup process:\n\n1. Judging whether it is fullnode or validator\n2. Initialize DB(committee_store,checkpoint_store,state_sync_store,index_store,event_store)\n3. create p2p network(discovery_handle,state_sync_handle)\n4. create transaction_streamer (if it’s fullNode)\n5. create node_sync_store\n6. create handles(batch_subsystem_handle,post_processing_subsystem_handle,execute_driver_handle)\n7. create json_rpc_service\n8. finish start up\n\n```rust\n\n//sui/crates/sui-node/src/lib.rs\npub async fn start(config: &NodeConfig, prometheus_registry: Registry) -> Result<SuiNode> {\n        ...\n        let store =\n            Arc::new(AuthorityStore::open(&config.db_path().join(\"store\"), None, genesis).await?);\n        let committee_store = Arc::new(CommitteeStore::new(\n            config.db_path().join(\"epochs\"),\n            &committee,\n            None,\n        ));\n        let checkpoint_store = CheckpointStore::new(&config.db_path().join(\"checkpoints\"));\n\n        let state_sync_store = RocksDbStore::new(\n            store.clone(),\n            committee_store.clone(),\n            checkpoint_store.clone(),\n        );\n\n        let index_store = if is_validator {\n            None\n        } else {\n            Some(Arc::new(IndexStore::open_tables_read_write(\n                config.db_path().join(\"indexes\"),\n                None,\n                None,\n            )))\n        };\n\n        let event_store = if config.enable_event_processing {\n            let path = config.db_path().join(\"events.db\");\n            let db = SqlEventStore::new_from_file(&path).await?;\n            db.initialize().await?;\n            Some(Arc::new(EventStoreType::SqlEventStore(db)))\n        } else {\n            None\n        };\n\n        let (p2p_network, discovery_handle, state_sync_handle) =\n            Self::create_p2p_network(config, state_sync_store, &prometheus_registry)?;\n\n       ...\n        let node_sync_store = Arc::new(NodeSyncStore::open_tables_read_write(\n            config.db_path().join(\"node_sync_db\"),\n            None,\n            None,\n        ));\n\n        ...\n\n        let batch_subsystem_handle = {\n            // Start batch system so that this node can be followed\n            let batch_state = state.clone();\n            spawn_monitored_task!(async move {\n                batch_state\n                    .run_batch_service(1000, Duration::from_secs(1))\n                    .await\n            })\n        };\n\n        let post_processing_subsystem_handle =\n            if index_store.is_some() || config.enable_event_processing {\n                let indexing_state = state.clone();\n                Some(spawn_monitored_task!(async move {\n                    indexing_state\n                        .run_tx_post_processing_process()\n                        .await\n                        .map_err(Into::into)\n                }))\n            } else {\n                None\n            };\n\n        \n        let execute_driver_handle = active_authority.clone().spawn_execute_process().await;\n\t\t\t\t...\n        let json_rpc_service = build_server(\n            state.clone(),\n            &transaction_orchestrator.clone(),\n            config,\n            &prometheus_registry,\n        )\n        .await?;\n\n\t\t\t ...\n\n        info!(\"SuiNode started!\");\n\n        Ok(node)\n```\n\n![Untitled](../img/304.png)\n\nWe can get more info from the debug output.(here we only focus on the startup information of one node: 0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a).\n\n```bash\nLaunching: /Users/safeer/sui/target/debug/sui start\nLaunched process 80154\n2022-12-14T08:59:58.765242Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n\tcurl -s http://127.0.0.1:52424/metrics\n2022-12-14T08:59:58.765242Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n2022-12-14T09:00:12.433291Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_node: Initializing sui-node listening on /ip4/127.0.0.1/tcp/52420/http node=k#8c26601d82aac59fade53f345f8fe84239d69652142a7fdc7724f729a1716a07e16b07a91e5afd49ee45d5cc6f5f3a9e0d152797d9251f2be21811a764a2dea2539c3b7541d52bf2e78b4d256bd94daa193f0c2234ec76276b80c6f0fedf4274\n2022-12-14T09:00:12.435263Z  WARN node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: mysten_metrics: init_metrics registry overwritten\n2022-12-14T09:13:51.573049Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Created/opened SQLite EventStore on disk db_path=\"/Users/safeer/.sui/sui_config/authorities_db/2727618050/events.db\"\n2022-12-14T09:13:56.940186Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: SQLite events table is initialized with query \"CREATE TABLE IF NOT EXISTS events(timestamp INTEGER NOT NULL, seq_num INTEGER, event_num INTEGER, tx_digest BLOB, event_type INTEGER, package_id BLOB, module_name TEXT, function TEXT, object_type TEXT, object_id BLOB, fields TEXT, move_event_name TEXT, contents BLOB, sender BLOB, recipient TEXT);\"\n2022-12-14T09:14:05.392089Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"seq_num\"\n2022-12-14T09:14:10.311911Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"event_num\"\n2022-12-14T09:14:13.542209Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"timestamp\"\n2022-12-14T09:14:17.262100Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"tx_digest\"\n2022-12-14T09:14:20.959975Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"event_type\"\n2022-12-14T09:14:26.008174Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"package_id\"\n2022-12-14T09:14:30.079815Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"module_name\"\n2022-12-14T09:14:36.559934Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"sender\"\n2022-12-14T09:14:36.567273Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"recipient\"\n2022-12-14T09:14:36.574490Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"object_id\"\n2022-12-14T09:14:36.582455Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"object_type\"\n2022-12-14T09:14:36.589734Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_storage::event_store::sql: Index is ready column=\"move_event_name\"\n2022-12-14T09:14:36.598456Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_node: P2p network started on 127.0.0.1:52422\n2022-12-14T09:14:43.930692Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_core::authority_active: respawn_node_sync_process epoch=0\n2022-12-14T09:14:43.931350Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_core::authority_active: spawning node sync task\n2022-12-14T09:14:46.921729Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_json_rpc: acl=Const(\"*\")\n2022-12-14T09:14:46.922716Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_json_rpc: Sui JSON-RPC server listening on 0.0.0.0:9000 local_addr=0.0.0.0:9000\n2022-12-14T09:14:46.922772Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_json_rpc: Available JSON-RPC methods : [\"sui_moveCall\", \"sui_getCoinMetadata\", \"sui_publish\", \"sui_getObjectsOwnedByAddress\", \"sui_payAllSui\", \"sui_transferObject\", \"sui_unsubscribeEvent\", \"sui_executeTransaction\", \"sui_mergeCoins\", \"sui_subscribeTransaction\", \"sui_getEvents\", \"sui_getObject\", \"sui_getTransactionsInRange\", \"sui_getObjectsOwnedByObject\", \"sui_executeTransactionSerializedSig\", \"sui_subscribeEvent\", \"sui_paySui\", \"sui_getRawObject\", \"sui_splitCoin\", \"sui_getNormalizedMoveFunction\", \"sui_getTransaction\", \"sui_getTotalTransactionNumber\", \"sui_pay\", \"sui_getTransactionAuthSigners\", \"sui_getMoveFunctionArgTypes\", \"sui_transferSui\", \"sui_batchTransaction\", \"sui_unsubscribeTransaction\", \"sui_dryRunTransaction\", \"sui_splitCoinEqual\", \"sui_getNormalizedMoveModule\", \"sui_getNormalizedMoveModulesByPackage\", \"sui_tryGetPastObject\", \"rpc.discover\", \"sui_getTransactions\", \"sui_getCommitteeInfo\", \"sui_getNormalizedMoveStruct\"]\n2022-12-14T09:14:58.627411Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_node: SuiNode started!\n2022-12-14T09:15:08.957227Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}:connection-manager{peer=82a014fa}: anemo::network::connection_manager: ConnectionManager started\n2022-12-14T09:15:08.957369Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_network::discovery: Discovery started\n2022-12-14T09:15:08.957515Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_network::state_sync: State-Synchronizer started\n2022-12-14T09:15:08.960911Z  INFO node{name=0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a}: sui_core::authority_active::execution_driver: Starting pending certificates execution process.\n```\n\n## health check\n\nAfter starting the nodes,Performing a health check service to check that status of the node(Check every 5 seconds).\n\n```rust\n\n////sui/crates/sui-swarm/src/memory/node.rs-->spawn()\n\n/// Perform a health check on this Node by:\n    /// * Checking that the node is running\n    /// * Calling the Node's gRPC Health service if it's a validator.\n    pub async fn health_check(&self, is_validator: bool) -> Result<(), HealthCheckError> {\n        let thread = self.thread.as_ref().ok_or(HealthCheckError::NotRunning)?;\n        if !thread.is_alive() {\n            return Err(HealthCheckError::NotRunning);\n        }\n\n        if is_validator {\n            let channel = mysten_network::client::connect(self.config.network_address())\n                .await\n                .map_err(|err| anyhow!(err.to_string()))\n                .map_err(HealthCheckError::Failure)\n                .tap_err(|e| error!(\"error connecting to {}: {e}\", self.name()))?;\n\n            let mut client = tonic_health::proto::health_client::HealthClient::new(channel);\n            client\n                .check(tonic_health::proto::HealthCheckRequest::default())\n                .await\n                .map_err(|e| HealthCheckError::Failure(e.into()))\n                .tap_err(|e| error!(\"error performing health check on {}: {e}\", self.name()))?;\n        }\n\n        Ok(())\n    }\n```\n\n# **Summarize**\nWe analyzed the startup process of the node in this page. \n\n- reading the configuration file\n- generating objects according to the configuration file\n- open services during the node startup process\n\nIn the following articles, we will analyze each part in detail, the most important of which is to analyze the various services opened during the node startup process(SuiNode object).","slug":"02-Bootstrap of Sui local testnet 7860ec878e8f42c98a7c754b3afd2d30","published":1,"updated":"2023-01-03T07:06:23.320Z","_id":"clcfu8udp0000t9qqhvi09lzv","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/../img/305.png\" alt=\"Untitled\"><br>Since the code of sui is updated very quickly and we do not need to connect to devnet, so we select the main branch to analyze.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">branch main\ncommit db5a090d56c8f1f065474f26a12e97dc0ee33e12</code></pre>\n<p><img src=\"/../img/300.png\" alt=\"Untitled\"></p>\n<h1 id=\"Sui-package\"><a href=\"#Sui-package\" class=\"headerlink\" title=\"Sui package\"></a>Sui package</h1><p>The Sui package is in <code>sui/crates/sui</code> folder. It will be compiled into the sui command line tool. The files structure of this package is as follows:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  sui git:(main) tree\n.\n├── Cargo.toml\n├── build.rs\n├── genesis.md\n├── offline_signing.md\n├── src\n│   ├── client_commands.rs\n│   ├── config\n│   │   └── mod.rs\n│   ├── console.rs\n│   ├── genesis_ceremony.rs\n│   ├── keytool.rs\n│   ├── lib.rs\n│   ├── main.rs\n│   ├── shell.rs\n│   ├── sui_commands.rs\n│   ├── sui_move\n│   │   ├── build.rs\n│   │   ├── coverage.rs\n│   │   ├── disassemble.rs\n│   │   ├── mod.rs\n│   │   ├── new.rs\n│   │   ├── prove.rs\n│   │   ├── sui-natives.bpl\n│   │   └── unit_test.rs\n│   └── unit_tests\n│       ├── cli_tests.rs\n│       ├── data\n│       │   ├── dummy_modules_publish\n│       │   │   ├── Move.toml\n│       │   │   └── sources\n│       │   │       └── trusted_coin.move\n│       │   └── move_call_args_linter\n│       │       ├── Move.toml\n│       │       └── sources\n│       │           └── object_basics.move\n│       ├── keytool_tests.rs\n│       └── shell_tests.rs\n└── tests\n    ├── full_node_tests.rs\n    ├── move_test_code\n    │   ├── Move.toml\n    │   └── sources\n    │       └── shared_objects_version.move\n    ├── quorum_driver_tests.rs\n    ├── readme.rs\n    ├── reconfiguration_tests.rs\n    ├── shared_objects_tests.rs\n    ├── shared_objects_version_tests.rs\n    ├── simulator_tests.rs\n    └── transaction_orchestrator_tests.rs\n\n12 directories, 38 files</code></pre>\n\n<h1 id=\"sui-genesis\"><a href=\"#sui-genesis\" class=\"headerlink\" title=\"sui genesis\"></a>sui genesis</h1><p>To create the configuration files and objects for a local Sui network, run the <code>genesis</code> command. </p>\n<p>Genesis creates the network configuration files in the ~&#x2F;.sui&#x2F;sui_config folder. This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.</p>\n<p>Let’s first look at how this command works.</p>\n<blockquote>\n<p>Entrance：<code>sui/crates/sui/src/main.rs —&gt; fn main()</code></p>\n</blockquote>\n<p>When we execute this command, we first parse the input parameters and then call <code>cmd.execute()</code>. This method will judge the input parameters and execute different codes for different commands.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;main.rs\nasync fn main() &#123;\n    #[cfg(windows)]\n    colored::control::set_virtual_terminal(true).unwrap();\n\n    let bin_name &#x3D; env!(&quot;CARGO_BIN_NAME&quot;);\n    let cmd: SuiCommand &#x3D; SuiCommand::parse();\n    ...\n    exit_main!(cmd.execute().await);\n&#125;</code></pre>\n\n<p>If we use <code>sui genesis</code>.The <code>execute()</code> will match <code>SuiCommand::Genesis</code> .And the will call <code>genesis()</code>.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs\nimpl SuiCommand &#123;\n    pub async fn execute(self) -&gt; Result&lt;(), anyhow::Error&gt; &#123;\n        match self &#123;\n            ...\n            SuiCommand::Genesis &#123;\n                working_dir,\n                force,\n                from_config,\n                write_config,\n            &#125; &#x3D;&gt; genesis(from_config, write_config, working_dir, force).await,\n\t\t      ...   \n\t\t\t&#125;\n    &#125;\n&#125;</code></pre>\n\n<p>This method mainly does 3 things:</p>\n<ol>\n<li>read config from disk</li>\n<li>create some objects with those config value</li>\n<li>store important objects(Nodeconfig,genesis_conf &amp; network_config) to disk</li>\n</ol>\n<h2 id=\"Read-config\"><a href=\"#Read-config\" class=\"headerlink\" title=\"Read config\"></a>Read config</h2><p>If we do not provide the config dir,It will create it with default parameter. </p>\n<p>some default parameter:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;ib.rs\nconst SUI_DIR: &amp;str &#x3D; &quot;.sui&quot;;\nconst SUI_CONFIG_DIR: &amp;str &#x3D; &quot;sui_config&quot;;\npub const SUI_NETWORK_CONFIG: &amp;str &#x3D; &quot;network.yaml&quot;;\npub const SUI_FULLNODE_CONFIG: &amp;str &#x3D; &quot;fullnode.yaml&quot;;\npub const SUI_CLIENT_CONFIG: &amp;str &#x3D; &quot;client.yaml&quot;;\npub const SUI_KEYSTORE_FILENAME: &amp;str &#x3D; &quot;sui.keystore&quot;;\npub const SUI_GATEWAY_CONFIG: &amp;str &#x3D; &quot;gateway.yaml&quot;;\npub const SUI_GENESIS_FILENAME: &amp;str &#x3D; &quot;genesis.blob&quot;;\npub const SUI_DEV_NET_URL: &amp;str &#x3D; &quot;https:&#x2F;&#x2F;fullnode.devnet.sui.io:443&quot;;\n\npub const AUTHORITIES_DB_NAME: &amp;str &#x3D; &quot;authorities_db&quot;;\npub const CONSENSUS_DB_NAME: &amp;str &#x3D; &quot;consensus_db&quot;;\npub const FULL_NODE_DB_PATH: &amp;str &#x3D; &quot;full_node_db&quot;;\n\nconst DEFAULT_STAKE: StakeUnit &#x3D; 100000000000000;\nconst DEFAULT_GAS_PRICE: u64 &#x3D; 1;\nconst DEFAULT_COMMISSION_RATE: u64 &#x3D; 0;\n\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;genesis_config.rs\nconst DEFAULT_GAS_AMOUNT: u64 &#x3D; 100000000000000;\nconst DEFAULT_NUMBER_OF_AUTHORITIES: usize &#x3D; 4;\nconst DEFAULT_NUMBER_OF_ACCOUNT: usize &#x3D; 5;\nconst DEFAULT_NUMBER_OF_OBJECT_PER_ACCOUNT: usize &#x3D; 5;</code></pre>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui-commands.rs\nasync fn genesis(\n    from_config: Option&lt;PathBuf&gt;,\n    write_config: Option&lt;PathBuf&gt;,\n    working_dir: Option&lt;PathBuf&gt;,\n    force: bool,\n) -&gt; Result&lt;(), anyhow::Error&gt; &#123;\n    let sui_config_dir &#x3D; &amp;match working_dir &#123;\n        &#x2F;&#x2F; if a directory is specified, it must exist (it\n        &#x2F;&#x2F; will not be created)\n        Some(v) &#x3D;&gt; v,\n        &#x2F;&#x2F; create default Sui config dir if not specified\n        &#x2F;&#x2F; on the command line and if it does not exist\n        &#x2F;&#x2F; yet\n        None &#x3D;&gt; &#123;\n            let config_path &#x3D; sui_config_dir()?;\n            fs::create_dir_all(&amp;config_path)?;\n            config_path\n        &#125;\n    &#125;;\n\n     ...\n\t\tlet client_path &#x3D; sui_config_dir.join(SUI_CLIENT_CONFIG);\n    let keystore_path &#x3D; sui_config_dir.join(SUI_KEYSTORE_FILENAME);\n    ...\n\t\tlet network_path &#x3D; sui_config_dir.join(SUI_NETWORK_CONFIG);\n    let genesis_path &#x3D; sui_config_dir.join(SUI_GENESIS_FILENAME);\n\n    let mut genesis_conf &#x3D; match from_config &#123;\n        Some(path) &#x3D;&gt; PersistedConfig::read(&amp;path)?,\n        None &#x3D;&gt; &#123;\n            if keystore_path.exists() &#123;\n                let existing_keys &#x3D; FileBasedKeystore::new(&amp;keystore_path)?.addresses();\n                GenesisConfig::for_local_testing_with_addresses(existing_keys)\n            &#125; else &#123;\n                GenesisConfig::for_local_testing()\n            &#125;\n        &#125;\n    &#125;;\n...</code></pre>\n\n<p><img src=\"/../img/301.png\" alt=\"Untitled\"></p>\n<h2 id=\"create-objects\"><a href=\"#create-objects\" class=\"headerlink\" title=\"create objects\"></a>create objects</h2><p>Generate some important objects according the given configuration files or default configuration parameters.</p>\n<ul>\n<li>network_config</li>\n<li>genesis_config</li>\n<li>Client_config</li>\n</ul>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;genesis()\n\nlet mut network_config &#x3D; if let Some(validators) &#x3D; validator_info &#123;\n        ConfigBuilder::new(sui_config_dir)\n            .initial_accounts_config(genesis_conf)\n            .with_validators(validators)\n            .build()\n    &#125; else &#123;\n        ConfigBuilder::new(sui_config_dir)\n            .committee_size(NonZeroUsize::new(genesis_conf.committee_size).unwrap())\n            .initial_accounts_config(genesis_conf)\n\t\t\t\t\t\t&#x2F;&#x2F;will finally call build_with-calidators() in sui-config&#x2F;src&#x2F;builder.rs\n\t\t\t\t\t\t&#x2F;&#x2F;to genesis NetworkConfig&#123;&#125; and Nodeconfig\n            .build()\n    &#125;;\n</code></pre>\n\n<p><img src=\"/../img/308.png\" alt=\"Untitled\"></p>\n<h2 id=\"store-objects\"><a href=\"#store-objects\" class=\"headerlink\" title=\"store objects\"></a>store objects</h2><p>After all objects are generated, the <code>network_config , genesis, validator,keystore and client_config</code>  will be written to disk.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n  let mut keystore &#x3D; FileBasedKeystore::new(&amp;keystore_path)?;\n  for key in &amp;network_config.account_keys &#123;\n      keystore.add_key(SuiKeyPair::Ed25519SuiKeyPair(key.copy()))?;\n  &#125;\n&#x2F;&#x2F;Take out the latest one in the keystore as active_address\n  let active_address &#x3D; keystore.addresses().pop();\n\n  network_config.genesis.save(&amp;genesis_path)?;\n  for validator in &amp;mut network_config.validator_configs &#123;\n      validator.genesis &#x3D; sui_config::node::Genesis::new_from_file(&amp;genesis_path);\n  &#125;\n\n  info!(&quot;Network genesis completed.&quot;);\n  network_config.save(&amp;network_path)?;\n  info!(&quot;Network config file is stored in &#123;:?&#125;.&quot;, network_path);\n\n  info!(&quot;Client keystore is stored in &#123;:?&#125;.&quot;, keystore_path);\n\n  let mut fullnode_config &#x3D; network_config.generate_fullnode_config();\n  fullnode_config.json_rpc_address &#x3D; sui_config::node::default_json_rpc_address();\n  fullnode_config.save(sui_config_dir.join(SUI_FULLNODE_CONFIG))?;\n\n  for (i, validator) in network_config\n      .into_validator_configs()\n      .into_iter()\n      .enumerate()\n  &#123;\n      let path &#x3D; sui_config_dir.join(format!(&quot;validator-config-&#123;&#125;.yaml&quot;, i));\n      validator.save(path)?;\n  &#125;\n\n  let mut client_config &#x3D; if client_path.exists() &#123;\n      PersistedConfig::read(&amp;client_path)?\n  &#125; else &#123;\n      SuiClientConfig::new(keystore.into())\n  &#125;;\n...\n  client_config.save(&amp;client_path)?;\n  info!(&quot;Client config file is stored in &#123;:?&#125;.&quot;, client_path);\n\n  Ok(())</code></pre>\n\n<p>We can get the detail from the output log.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">2022-12-13T08:12:04.072712Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-13T08:16:33.039813Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-13T08:16:33.069233Z  INFO sui::sui_commands: Network config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;network.yaml&quot;.\n2022-12-13T08:16:33.069286Z  INFO sui::sui_commands: Client keystore is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;sui.keystore&quot;.\n2022-12-13T08:18:02.582274Z  INFO sui::sui_commands: Client config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;client.yaml&quot;</code></pre>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">➜  sui_config tree\n.\n├── client.yaml\n├── fullnode.yaml\n├── genesis.blob\n├── network.yaml\n├── sui.keystore\n├── validator-config-0.yaml\n├── validator-config-1.yaml\n├── validator-config-2.yaml\n└── validator-config-3.yaml</code></pre>\n\n\n<h1 id=\"sui-start\"><a href=\"#sui-start\" class=\"headerlink\" title=\"sui start\"></a>sui start</h1><p>Run <code>sui start</code> to start the local Sui network with default location for configuration.</p>\n<p>This command looks for the Sui network configuration file <code>network.yaml</code> in the <code>~/.sui/sui_config</code> directory. If there is no configuration in this directory, it will call genesis() to genesis the default configuration first.</p>\n<p>The sui node is divided into validator and full node:</p>\n<ul>\n<li>validator: validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected Full nodes that then service the queries from clients.</li>\n<li>full node:Sui Full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each Full node stores and services the queries for the blockchain state and history.</li>\n</ul>\n<p>It will do those things:</p>\n<ol>\n<li>read configuration from disk(will call  genesis() to auto genesis if path is none)</li>\n<li>build swarm with network_config(by default the swarm will contain 4 validators )</li>\n<li>call swarm.launch() to start 4 validators.</li>\n<li>run health Check service.</li>\n</ol>\n<h2 id=\"read-configuration\"><a href=\"#read-configuration\" class=\"headerlink\" title=\"read configuration\"></a>read configuration</h2><p>Before we used <code>sui genesis</code> to generate configuration files and perform storage persistence management.Here we will take it out, and then use these configuration files to generate <code>network_config</code> objects.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute()\nSuiCommand::Start &#123;\n                config,\n                no_full_node,\n            &#125; &#x3D;&gt; &#123;\n              ... \n\t\t\t\t\t\t\tlet network_config: NetworkConfig &#x3D; PersistedConfig::read(&amp;network_config_path)\n                    .map_err(|err| &#123;\n                        err.context(format!(\n                            &quot;Cannot open Sui network config file at &#123;:?&#125;&quot;,\n                            network_config_path\n                        ))\n                    &#125;)?;\n\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;lib.rs\nfn load&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Self, anyhow::Error&gt; &#123;\n        let path &#x3D; path.as_ref();\n        trace!(&quot;Reading config from &#123;&#125;&quot;, path.display());\n        let reader &#x3D; fs::File::open(path)\n            .with_context(|| format!(&quot;Unable to load config from &#123;&#125;&quot;, path.display()))?;\n        Ok(serde_yaml::from_reader(reader)?)\n    &#125;</code></pre>\n\n<p><img src=\"/../img/302.png\" alt=\"Untitled\"></p>\n<h2 id=\"build-swarm\"><a href=\"#build-swarm\" class=\"headerlink\" title=\"build swarm\"></a>build swarm</h2><p>Swarm is a handle to an in-memory Sui network.It contain a network_config and validators.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;swarm.rs\n&#x2F;&#x2F;&#x2F; A handle to an in-memory Sui Network.\n#[derive(Debug)]\npub struct Swarm &#123;\n    dir: SwarmDirectory,\n    network_config: NetworkConfig,\n    validators: HashMap&lt;SuiAddress, Node&gt;,\n    fullnodes: HashMap&lt;SuiAddress, Node&gt;,\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute() \nlet mut swarm &#x3D; if no_full_node &#123;\n                    Swarm::builder()\n                &#125; else &#123;\n                    Swarm::builder()\n                        .with_fullnode_rpc_addr(sui_config::node::default_json_rpc_address())\n                &#125;\n                .from_network_config(sui_config_dir()?, network_config);</code></pre>\n\n<p><img src=\"/../img/303.png\" alt=\"Untitled\"></p>\n<h2 id=\"run-validators\"><a href=\"#run-validators\" class=\"headerlink\" title=\"run validators\"></a>run validators</h2><p>After we build the swarm, we can use it to run each validator.</p>\n<p>The whole process is:</p>\n<p><code>//node.spawn()--&gt;Container::spawn()--&gt;SuiNode::start()</code></p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute() \n\nswarm.launch().await?;\n\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;swarm.rs\n&#x2F;&#x2F;&#x2F; Start all of the Validators associated with this Swarm\n    pub async fn launch(&amp;mut self) -&gt; Result&lt;()&gt; &#123;\n        let start_handles &#x3D; self\n            .nodes_iter_mut()\n            .map(|node| node.spawn())\n            .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;\n\n        try_join_all(start_handles).await?;\n\n        Ok(())\n    &#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;node.rs\n\n&#x2F;&#x2F;&#x2F; Start this Node, returning a handle that will resolve when the node has completed starting\n    &#x2F;&#x2F;&#x2F; up.\n    pub fn spawn(&amp;mut self) -&gt; Result&lt;tokio::sync::oneshot::Receiver&lt;()&gt;&gt; &#123;\n        trace!(name &#x3D;% self.name(), &quot;starting in-memory node&quot;);\n        let (startup_receiver, node_handle) &#x3D;\n            Container::spawn(self.config.clone(), self.runtime_type);\n        self.thread &#x3D; Some(node_handle);\n        Ok(startup_receiver)\n    &#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;container.rs--&gt;spawn()\n\nruntime.block_on(async move &#123;\n                let prometheus_registry &#x3D; metrics::start_prometheus_server(config.metrics_address);\n                info!(\n                    &quot;Started Prometheus HTTP endpoint. To query metrics use\\n\\tcurl -s http:&#x2F;&#x2F;&#123;&#125;&#x2F;metrics&quot;,\n                    config.metrics_address\n                );\n                let _server &#x3D; SuiNode::start(&amp;config, prometheus_registry).await.unwrap();\n                &#x2F;&#x2F; Notify that we&#39;ve successfully started the node\n                let _ &#x3D; startup_sender.send(());\n                &#x2F;&#x2F; run until canceled\n                cancel_reciever.map(|_| ()).await;</code></pre>\n\n<h3 id=\"SuiNode\"><a href=\"#SuiNode\" class=\"headerlink\" title=\"SuiNode\"></a>SuiNode</h3><p>Suinode is the smallest unit of node management and is a very important object.It contains almost all the functions that a node needs to implement. The focus of our follow-up analysis is here.</p>\n<p>The main members of it are:</p>\n<ul>\n<li>config</li>\n<li>checkpoint_store</li>\n<li>_batch_subsystem_handle</li>\n<li>_execute_driver_handle</li>\n<li>state</li>\n<li>active</li>\n<li>_p2p_network</li>\n<li>_discovery</li>\n<li>_state_sync</li>\n<li>sim_node</li>\n</ul>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-node&#x2F;src&#x2F;lib.rs\n\npub struct SuiNode &#123;\n    config: NodeConfig,\n    checkpoint_store: Arc&lt;CheckpointStore&gt;,\n    validator_server_info: Option&lt;ValidatorServerInfo&gt;,\n    _json_rpc_service: Option&lt;ServerHandle&gt;,\n    _batch_subsystem_handle: tokio::task::JoinHandle&lt;()&gt;,\n    _post_processing_subsystem_handle: Option&lt;tokio::task::JoinHandle&lt;Result&lt;()&gt;&gt;&gt;,\n    _gossip_handle: Option&lt;tokio::task::JoinHandle&lt;()&gt;&gt;,\n    _execute_driver_handle: tokio::task::JoinHandle&lt;()&gt;,\n    state: Arc&lt;AuthorityState&gt;,\n    active: Arc&lt;ActiveAuthority&lt;NetworkAuthorityClient&gt;&gt;,\n    transaction_orchestrator: Option&lt;Arc&lt;TransactiondOrchestrator&lt;NetworkAuthorityClient&gt;&gt;&gt;,\n    _prometheus_registry: Registry,\n\n    _p2p_network: anemo::Network,\n    _discovery: discovery::Handle,\n    _state_sync: state_sync::Handle,\n\n    reconfig_channel: (\n        tokio::sync::mpsc::Sender&lt;EpochId&gt;,\n        tokio::sync::mpsc::Receiver&lt;EpochId&gt;,\n    ),\n\n    #[cfg(msim)]\n    sim_node: sui_simulator::runtime::NodeHandle,\n&#125;\n</code></pre>\n\n<p>Now let’s analyze the detailed steps in the node startup process:</p>\n<ol>\n<li>Judging whether it is fullnode or validator</li>\n<li>Initialize DB(committee_store,checkpoint_store,state_sync_store,index_store,event_store)</li>\n<li>create p2p network(discovery_handle,state_sync_handle)</li>\n<li>create transaction_streamer (if it’s fullNode)</li>\n<li>create node_sync_store</li>\n<li>create handles(batch_subsystem_handle,post_processing_subsystem_handle,execute_driver_handle)</li>\n<li>create json_rpc_service</li>\n<li>finish start up</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-node&#x2F;src&#x2F;lib.rs\npub async fn start(config: &amp;NodeConfig, prometheus_registry: Registry) -&gt; Result&lt;SuiNode&gt; &#123;\n        ...\n        let store &#x3D;\n            Arc::new(AuthorityStore::open(&amp;config.db_path().join(&quot;store&quot;), None, genesis).await?);\n        let committee_store &#x3D; Arc::new(CommitteeStore::new(\n            config.db_path().join(&quot;epochs&quot;),\n            &amp;committee,\n            None,\n        ));\n        let checkpoint_store &#x3D; CheckpointStore::new(&amp;config.db_path().join(&quot;checkpoints&quot;));\n\n        let state_sync_store &#x3D; RocksDbStore::new(\n            store.clone(),\n            committee_store.clone(),\n            checkpoint_store.clone(),\n        );\n\n        let index_store &#x3D; if is_validator &#123;\n            None\n        &#125; else &#123;\n            Some(Arc::new(IndexStore::open_tables_read_write(\n                config.db_path().join(&quot;indexes&quot;),\n                None,\n                None,\n            )))\n        &#125;;\n\n        let event_store &#x3D; if config.enable_event_processing &#123;\n            let path &#x3D; config.db_path().join(&quot;events.db&quot;);\n            let db &#x3D; SqlEventStore::new_from_file(&amp;path).await?;\n            db.initialize().await?;\n            Some(Arc::new(EventStoreType::SqlEventStore(db)))\n        &#125; else &#123;\n            None\n        &#125;;\n\n        let (p2p_network, discovery_handle, state_sync_handle) &#x3D;\n            Self::create_p2p_network(config, state_sync_store, &amp;prometheus_registry)?;\n\n       ...\n        let node_sync_store &#x3D; Arc::new(NodeSyncStore::open_tables_read_write(\n            config.db_path().join(&quot;node_sync_db&quot;),\n            None,\n            None,\n        ));\n\n        ...\n\n        let batch_subsystem_handle &#x3D; &#123;\n            &#x2F;&#x2F; Start batch system so that this node can be followed\n            let batch_state &#x3D; state.clone();\n            spawn_monitored_task!(async move &#123;\n                batch_state\n                    .run_batch_service(1000, Duration::from_secs(1))\n                    .await\n            &#125;)\n        &#125;;\n\n        let post_processing_subsystem_handle &#x3D;\n            if index_store.is_some() || config.enable_event_processing &#123;\n                let indexing_state &#x3D; state.clone();\n                Some(spawn_monitored_task!(async move &#123;\n                    indexing_state\n                        .run_tx_post_processing_process()\n                        .await\n                        .map_err(Into::into)\n                &#125;))\n            &#125; else &#123;\n                None\n            &#125;;\n\n        \n        let execute_driver_handle &#x3D; active_authority.clone().spawn_execute_process().await;\n\t\t\t\t...\n        let json_rpc_service &#x3D; build_server(\n            state.clone(),\n            &amp;transaction_orchestrator.clone(),\n            config,\n            &amp;prometheus_registry,\n        )\n        .await?;\n\n\t\t\t ...\n\n        info!(&quot;SuiNode started!&quot;);\n\n        Ok(node)</code></pre>\n\n<p><img src=\"/../img/304.png\" alt=\"Untitled\"></p>\n<p>We can get more info from the debug output.(here we only focus on the startup information of one node: 0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a).</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Launching: &#x2F;Users&#x2F;safeer&#x2F;sui&#x2F;target&#x2F;debug&#x2F;sui start\nLaunched process 80154\n2022-12-14T08:59:58.765242Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n\tcurl -s http:&#x2F;&#x2F;127.0.0.1:52424&#x2F;metrics\n2022-12-14T08:59:58.765242Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n2022-12-14T09:00:12.433291Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: Initializing sui-node listening on &#x2F;ip4&#x2F;127.0.0.1&#x2F;tcp&#x2F;52420&#x2F;http node&#x3D;k#8c26601d82aac59fade53f345f8fe84239d69652142a7fdc7724f729a1716a07e16b07a91e5afd49ee45d5cc6f5f3a9e0d152797d9251f2be21811a764a2dea2539c3b7541d52bf2e78b4d256bd94daa193f0c2234ec76276b80c6f0fedf4274\n2022-12-14T09:00:12.435263Z  WARN node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: mysten_metrics: init_metrics registry overwritten\n2022-12-14T09:13:51.573049Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Created&#x2F;opened SQLite EventStore on disk db_path&#x3D;&quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;authorities_db&#x2F;2727618050&#x2F;events.db&quot;\n2022-12-14T09:13:56.940186Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: SQLite events table is initialized with query &quot;CREATE TABLE IF NOT EXISTS events(timestamp INTEGER NOT NULL, seq_num INTEGER, event_num INTEGER, tx_digest BLOB, event_type INTEGER, package_id BLOB, module_name TEXT, function TEXT, object_type TEXT, object_id BLOB, fields TEXT, move_event_name TEXT, contents BLOB, sender BLOB, recipient TEXT);&quot;\n2022-12-14T09:14:05.392089Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;seq_num&quot;\n2022-12-14T09:14:10.311911Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;event_num&quot;\n2022-12-14T09:14:13.542209Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;timestamp&quot;\n2022-12-14T09:14:17.262100Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;tx_digest&quot;\n2022-12-14T09:14:20.959975Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;event_type&quot;\n2022-12-14T09:14:26.008174Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;package_id&quot;\n2022-12-14T09:14:30.079815Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;module_name&quot;\n2022-12-14T09:14:36.559934Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;sender&quot;\n2022-12-14T09:14:36.567273Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;recipient&quot;\n2022-12-14T09:14:36.574490Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;object_id&quot;\n2022-12-14T09:14:36.582455Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;object_type&quot;\n2022-12-14T09:14:36.589734Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;move_event_name&quot;\n2022-12-14T09:14:36.598456Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: P2p network started on 127.0.0.1:52422\n2022-12-14T09:14:43.930692Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active: respawn_node_sync_process epoch&#x3D;0\n2022-12-14T09:14:43.931350Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active: spawning node sync task\n2022-12-14T09:14:46.921729Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: acl&#x3D;Const(&quot;*&quot;)\n2022-12-14T09:14:46.922716Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: Sui JSON-RPC server listening on 0.0.0.0:9000 local_addr&#x3D;0.0.0.0:9000\n2022-12-14T09:14:46.922772Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: Available JSON-RPC methods : [&quot;sui_moveCall&quot;, &quot;sui_getCoinMetadata&quot;, &quot;sui_publish&quot;, &quot;sui_getObjectsOwnedByAddress&quot;, &quot;sui_payAllSui&quot;, &quot;sui_transferObject&quot;, &quot;sui_unsubscribeEvent&quot;, &quot;sui_executeTransaction&quot;, &quot;sui_mergeCoins&quot;, &quot;sui_subscribeTransaction&quot;, &quot;sui_getEvents&quot;, &quot;sui_getObject&quot;, &quot;sui_getTransactionsInRange&quot;, &quot;sui_getObjectsOwnedByObject&quot;, &quot;sui_executeTransactionSerializedSig&quot;, &quot;sui_subscribeEvent&quot;, &quot;sui_paySui&quot;, &quot;sui_getRawObject&quot;, &quot;sui_splitCoin&quot;, &quot;sui_getNormalizedMoveFunction&quot;, &quot;sui_getTransaction&quot;, &quot;sui_getTotalTransactionNumber&quot;, &quot;sui_pay&quot;, &quot;sui_getTransactionAuthSigners&quot;, &quot;sui_getMoveFunctionArgTypes&quot;, &quot;sui_transferSui&quot;, &quot;sui_batchTransaction&quot;, &quot;sui_unsubscribeTransaction&quot;, &quot;sui_dryRunTransaction&quot;, &quot;sui_splitCoinEqual&quot;, &quot;sui_getNormalizedMoveModule&quot;, &quot;sui_getNormalizedMoveModulesByPackage&quot;, &quot;sui_tryGetPastObject&quot;, &quot;rpc.discover&quot;, &quot;sui_getTransactions&quot;, &quot;sui_getCommitteeInfo&quot;, &quot;sui_getNormalizedMoveStruct&quot;]\n2022-12-14T09:14:58.627411Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: SuiNode started!\n2022-12-14T09:15:08.957227Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;:connection-manager&#123;peer&#x3D;82a014fa&#125;: anemo::network::connection_manager: ConnectionManager started\n2022-12-14T09:15:08.957369Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_network::discovery: Discovery started\n2022-12-14T09:15:08.957515Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_network::state_sync: State-Synchronizer started\n2022-12-14T09:15:08.960911Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active::execution_driver: Starting pending certificates execution process.</code></pre>\n\n<h2 id=\"health-check\"><a href=\"#health-check\" class=\"headerlink\" title=\"health check\"></a>health check</h2><p>After starting the nodes,Performing a health check service to check that status of the node(Check every 5 seconds).</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;node.rs--&gt;spawn()\n\n&#x2F;&#x2F;&#x2F; Perform a health check on this Node by:\n    &#x2F;&#x2F;&#x2F; * Checking that the node is running\n    &#x2F;&#x2F;&#x2F; * Calling the Node&#39;s gRPC Health service if it&#39;s a validator.\n    pub async fn health_check(&amp;self, is_validator: bool) -&gt; Result&lt;(), HealthCheckError&gt; &#123;\n        let thread &#x3D; self.thread.as_ref().ok_or(HealthCheckError::NotRunning)?;\n        if !thread.is_alive() &#123;\n            return Err(HealthCheckError::NotRunning);\n        &#125;\n\n        if is_validator &#123;\n            let channel &#x3D; mysten_network::client::connect(self.config.network_address())\n                .await\n                .map_err(|err| anyhow!(err.to_string()))\n                .map_err(HealthCheckError::Failure)\n                .tap_err(|e| error!(&quot;error connecting to &#123;&#125;: &#123;e&#125;&quot;, self.name()))?;\n\n            let mut client &#x3D; tonic_health::proto::health_client::HealthClient::new(channel);\n            client\n                .check(tonic_health::proto::HealthCheckRequest::default())\n                .await\n                .map_err(|e| HealthCheckError::Failure(e.into()))\n                .tap_err(|e| error!(&quot;error performing health check on &#123;&#125;: &#123;e&#125;&quot;, self.name()))?;\n        &#125;\n\n        Ok(())\n    &#125;</code></pre>\n\n<h1 id=\"Summarize\"><a href=\"#Summarize\" class=\"headerlink\" title=\"Summarize\"></a><strong>Summarize</strong></h1><p>We analyzed the startup process of the node in this page. </p>\n<ul>\n<li>reading the configuration file</li>\n<li>generating objects according to the configuration file</li>\n<li>open services during the node startup process</li>\n</ul>\n<p>In the following articles, we will analyze each part in detail, the most important of which is to analyze the various services opened during the node startup process(SuiNode object).</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/../img/305.png\" alt=\"Untitled\"><br>Since the code of sui is updated very quickly and we do not need to connect to devnet, so we select the main branch to analyze.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">branch main\ncommit db5a090d56c8f1f065474f26a12e97dc0ee33e12</code></pre>\n<p><img src=\"/../img/300.png\" alt=\"Untitled\"></p>\n<h1 id=\"Sui-package\"><a href=\"#Sui-package\" class=\"headerlink\" title=\"Sui package\"></a>Sui package</h1><p>The Sui package is in <code>sui/crates/sui</code> folder. It will be compiled into the sui command line tool. The files structure of this package is as follows:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  sui git:(main) tree\n.\n├── Cargo.toml\n├── build.rs\n├── genesis.md\n├── offline_signing.md\n├── src\n│   ├── client_commands.rs\n│   ├── config\n│   │   └── mod.rs\n│   ├── console.rs\n│   ├── genesis_ceremony.rs\n│   ├── keytool.rs\n│   ├── lib.rs\n│   ├── main.rs\n│   ├── shell.rs\n│   ├── sui_commands.rs\n│   ├── sui_move\n│   │   ├── build.rs\n│   │   ├── coverage.rs\n│   │   ├── disassemble.rs\n│   │   ├── mod.rs\n│   │   ├── new.rs\n│   │   ├── prove.rs\n│   │   ├── sui-natives.bpl\n│   │   └── unit_test.rs\n│   └── unit_tests\n│       ├── cli_tests.rs\n│       ├── data\n│       │   ├── dummy_modules_publish\n│       │   │   ├── Move.toml\n│       │   │   └── sources\n│       │   │       └── trusted_coin.move\n│       │   └── move_call_args_linter\n│       │       ├── Move.toml\n│       │       └── sources\n│       │           └── object_basics.move\n│       ├── keytool_tests.rs\n│       └── shell_tests.rs\n└── tests\n    ├── full_node_tests.rs\n    ├── move_test_code\n    │   ├── Move.toml\n    │   └── sources\n    │       └── shared_objects_version.move\n    ├── quorum_driver_tests.rs\n    ├── readme.rs\n    ├── reconfiguration_tests.rs\n    ├── shared_objects_tests.rs\n    ├── shared_objects_version_tests.rs\n    ├── simulator_tests.rs\n    └── transaction_orchestrator_tests.rs\n\n12 directories, 38 files</code></pre>\n\n<h1 id=\"sui-genesis\"><a href=\"#sui-genesis\" class=\"headerlink\" title=\"sui genesis\"></a>sui genesis</h1><p>To create the configuration files and objects for a local Sui network, run the <code>genesis</code> command. </p>\n<p>Genesis creates the network configuration files in the ~&#x2F;.sui&#x2F;sui_config folder. This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.</p>\n<p>Let’s first look at how this command works.</p>\n<blockquote>\n<p>Entrance：<code>sui/crates/sui/src/main.rs —&gt; fn main()</code></p>\n</blockquote>\n<p>When we execute this command, we first parse the input parameters and then call <code>cmd.execute()</code>. This method will judge the input parameters and execute different codes for different commands.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;main.rs\nasync fn main() &#123;\n    #[cfg(windows)]\n    colored::control::set_virtual_terminal(true).unwrap();\n\n    let bin_name &#x3D; env!(&quot;CARGO_BIN_NAME&quot;);\n    let cmd: SuiCommand &#x3D; SuiCommand::parse();\n    ...\n    exit_main!(cmd.execute().await);\n&#125;</code></pre>\n\n<p>If we use <code>sui genesis</code>.The <code>execute()</code> will match <code>SuiCommand::Genesis</code> .And the will call <code>genesis()</code>.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs\nimpl SuiCommand &#123;\n    pub async fn execute(self) -&gt; Result&lt;(), anyhow::Error&gt; &#123;\n        match self &#123;\n            ...\n            SuiCommand::Genesis &#123;\n                working_dir,\n                force,\n                from_config,\n                write_config,\n            &#125; &#x3D;&gt; genesis(from_config, write_config, working_dir, force).await,\n\t\t      ...   \n\t\t\t&#125;\n    &#125;\n&#125;</code></pre>\n\n<p>This method mainly does 3 things:</p>\n<ol>\n<li>read config from disk</li>\n<li>create some objects with those config value</li>\n<li>store important objects(Nodeconfig,genesis_conf &amp; network_config) to disk</li>\n</ol>\n<h2 id=\"Read-config\"><a href=\"#Read-config\" class=\"headerlink\" title=\"Read config\"></a>Read config</h2><p>If we do not provide the config dir,It will create it with default parameter. </p>\n<p>some default parameter:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;ib.rs\nconst SUI_DIR: &amp;str &#x3D; &quot;.sui&quot;;\nconst SUI_CONFIG_DIR: &amp;str &#x3D; &quot;sui_config&quot;;\npub const SUI_NETWORK_CONFIG: &amp;str &#x3D; &quot;network.yaml&quot;;\npub const SUI_FULLNODE_CONFIG: &amp;str &#x3D; &quot;fullnode.yaml&quot;;\npub const SUI_CLIENT_CONFIG: &amp;str &#x3D; &quot;client.yaml&quot;;\npub const SUI_KEYSTORE_FILENAME: &amp;str &#x3D; &quot;sui.keystore&quot;;\npub const SUI_GATEWAY_CONFIG: &amp;str &#x3D; &quot;gateway.yaml&quot;;\npub const SUI_GENESIS_FILENAME: &amp;str &#x3D; &quot;genesis.blob&quot;;\npub const SUI_DEV_NET_URL: &amp;str &#x3D; &quot;https:&#x2F;&#x2F;fullnode.devnet.sui.io:443&quot;;\n\npub const AUTHORITIES_DB_NAME: &amp;str &#x3D; &quot;authorities_db&quot;;\npub const CONSENSUS_DB_NAME: &amp;str &#x3D; &quot;consensus_db&quot;;\npub const FULL_NODE_DB_PATH: &amp;str &#x3D; &quot;full_node_db&quot;;\n\nconst DEFAULT_STAKE: StakeUnit &#x3D; 100000000000000;\nconst DEFAULT_GAS_PRICE: u64 &#x3D; 1;\nconst DEFAULT_COMMISSION_RATE: u64 &#x3D; 0;\n\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;genesis_config.rs\nconst DEFAULT_GAS_AMOUNT: u64 &#x3D; 100000000000000;\nconst DEFAULT_NUMBER_OF_AUTHORITIES: usize &#x3D; 4;\nconst DEFAULT_NUMBER_OF_ACCOUNT: usize &#x3D; 5;\nconst DEFAULT_NUMBER_OF_OBJECT_PER_ACCOUNT: usize &#x3D; 5;</code></pre>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui-commands.rs\nasync fn genesis(\n    from_config: Option&lt;PathBuf&gt;,\n    write_config: Option&lt;PathBuf&gt;,\n    working_dir: Option&lt;PathBuf&gt;,\n    force: bool,\n) -&gt; Result&lt;(), anyhow::Error&gt; &#123;\n    let sui_config_dir &#x3D; &amp;match working_dir &#123;\n        &#x2F;&#x2F; if a directory is specified, it must exist (it\n        &#x2F;&#x2F; will not be created)\n        Some(v) &#x3D;&gt; v,\n        &#x2F;&#x2F; create default Sui config dir if not specified\n        &#x2F;&#x2F; on the command line and if it does not exist\n        &#x2F;&#x2F; yet\n        None &#x3D;&gt; &#123;\n            let config_path &#x3D; sui_config_dir()?;\n            fs::create_dir_all(&amp;config_path)?;\n            config_path\n        &#125;\n    &#125;;\n\n     ...\n\t\tlet client_path &#x3D; sui_config_dir.join(SUI_CLIENT_CONFIG);\n    let keystore_path &#x3D; sui_config_dir.join(SUI_KEYSTORE_FILENAME);\n    ...\n\t\tlet network_path &#x3D; sui_config_dir.join(SUI_NETWORK_CONFIG);\n    let genesis_path &#x3D; sui_config_dir.join(SUI_GENESIS_FILENAME);\n\n    let mut genesis_conf &#x3D; match from_config &#123;\n        Some(path) &#x3D;&gt; PersistedConfig::read(&amp;path)?,\n        None &#x3D;&gt; &#123;\n            if keystore_path.exists() &#123;\n                let existing_keys &#x3D; FileBasedKeystore::new(&amp;keystore_path)?.addresses();\n                GenesisConfig::for_local_testing_with_addresses(existing_keys)\n            &#125; else &#123;\n                GenesisConfig::for_local_testing()\n            &#125;\n        &#125;\n    &#125;;\n...</code></pre>\n\n<p><img src=\"/../img/301.png\" alt=\"Untitled\"></p>\n<h2 id=\"create-objects\"><a href=\"#create-objects\" class=\"headerlink\" title=\"create objects\"></a>create objects</h2><p>Generate some important objects according the given configuration files or default configuration parameters.</p>\n<ul>\n<li>network_config</li>\n<li>genesis_config</li>\n<li>Client_config</li>\n</ul>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;genesis()\n\nlet mut network_config &#x3D; if let Some(validators) &#x3D; validator_info &#123;\n        ConfigBuilder::new(sui_config_dir)\n            .initial_accounts_config(genesis_conf)\n            .with_validators(validators)\n            .build()\n    &#125; else &#123;\n        ConfigBuilder::new(sui_config_dir)\n            .committee_size(NonZeroUsize::new(genesis_conf.committee_size).unwrap())\n            .initial_accounts_config(genesis_conf)\n\t\t\t\t\t\t&#x2F;&#x2F;will finally call build_with-calidators() in sui-config&#x2F;src&#x2F;builder.rs\n\t\t\t\t\t\t&#x2F;&#x2F;to genesis NetworkConfig&#123;&#125; and Nodeconfig\n            .build()\n    &#125;;\n</code></pre>\n\n<p><img src=\"/../img/308.png\" alt=\"Untitled\"></p>\n<h2 id=\"store-objects\"><a href=\"#store-objects\" class=\"headerlink\" title=\"store objects\"></a>store objects</h2><p>After all objects are generated, the <code>network_config , genesis, validator,keystore and client_config</code>  will be written to disk.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n  let mut keystore &#x3D; FileBasedKeystore::new(&amp;keystore_path)?;\n  for key in &amp;network_config.account_keys &#123;\n      keystore.add_key(SuiKeyPair::Ed25519SuiKeyPair(key.copy()))?;\n  &#125;\n&#x2F;&#x2F;Take out the latest one in the keystore as active_address\n  let active_address &#x3D; keystore.addresses().pop();\n\n  network_config.genesis.save(&amp;genesis_path)?;\n  for validator in &amp;mut network_config.validator_configs &#123;\n      validator.genesis &#x3D; sui_config::node::Genesis::new_from_file(&amp;genesis_path);\n  &#125;\n\n  info!(&quot;Network genesis completed.&quot;);\n  network_config.save(&amp;network_path)?;\n  info!(&quot;Network config file is stored in &#123;:?&#125;.&quot;, network_path);\n\n  info!(&quot;Client keystore is stored in &#123;:?&#125;.&quot;, keystore_path);\n\n  let mut fullnode_config &#x3D; network_config.generate_fullnode_config();\n  fullnode_config.json_rpc_address &#x3D; sui_config::node::default_json_rpc_address();\n  fullnode_config.save(sui_config_dir.join(SUI_FULLNODE_CONFIG))?;\n\n  for (i, validator) in network_config\n      .into_validator_configs()\n      .into_iter()\n      .enumerate()\n  &#123;\n      let path &#x3D; sui_config_dir.join(format!(&quot;validator-config-&#123;&#125;.yaml&quot;, i));\n      validator.save(path)?;\n  &#125;\n\n  let mut client_config &#x3D; if client_path.exists() &#123;\n      PersistedConfig::read(&amp;client_path)?\n  &#125; else &#123;\n      SuiClientConfig::new(keystore.into())\n  &#125;;\n...\n  client_config.save(&amp;client_path)?;\n  info!(&quot;Client config file is stored in &#123;:?&#125;.&quot;, client_path);\n\n  Ok(())</code></pre>\n\n<p>We can get the detail from the output log.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">2022-12-13T08:12:04.072712Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-13T08:16:33.039813Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-13T08:16:33.069233Z  INFO sui::sui_commands: Network config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;network.yaml&quot;.\n2022-12-13T08:16:33.069286Z  INFO sui::sui_commands: Client keystore is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;sui.keystore&quot;.\n2022-12-13T08:18:02.582274Z  INFO sui::sui_commands: Client config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;client.yaml&quot;</code></pre>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">➜  sui_config tree\n.\n├── client.yaml\n├── fullnode.yaml\n├── genesis.blob\n├── network.yaml\n├── sui.keystore\n├── validator-config-0.yaml\n├── validator-config-1.yaml\n├── validator-config-2.yaml\n└── validator-config-3.yaml</code></pre>\n\n\n<h1 id=\"sui-start\"><a href=\"#sui-start\" class=\"headerlink\" title=\"sui start\"></a>sui start</h1><p>Run <code>sui start</code> to start the local Sui network with default location for configuration.</p>\n<p>This command looks for the Sui network configuration file <code>network.yaml</code> in the <code>~/.sui/sui_config</code> directory. If there is no configuration in this directory, it will call genesis() to genesis the default configuration first.</p>\n<p>The sui node is divided into validator and full node:</p>\n<ul>\n<li>validator: validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected Full nodes that then service the queries from clients.</li>\n<li>full node:Sui Full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each Full node stores and services the queries for the blockchain state and history.</li>\n</ul>\n<p>It will do those things:</p>\n<ol>\n<li>read configuration from disk(will call  genesis() to auto genesis if path is none)</li>\n<li>build swarm with network_config(by default the swarm will contain 4 validators )</li>\n<li>call swarm.launch() to start 4 validators.</li>\n<li>run health Check service.</li>\n</ol>\n<h2 id=\"read-configuration\"><a href=\"#read-configuration\" class=\"headerlink\" title=\"read configuration\"></a>read configuration</h2><p>Before we used <code>sui genesis</code> to generate configuration files and perform storage persistence management.Here we will take it out, and then use these configuration files to generate <code>network_config</code> objects.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute()\nSuiCommand::Start &#123;\n                config,\n                no_full_node,\n            &#125; &#x3D;&gt; &#123;\n              ... \n\t\t\t\t\t\t\tlet network_config: NetworkConfig &#x3D; PersistedConfig::read(&amp;network_config_path)\n                    .map_err(|err| &#123;\n                        err.context(format!(\n                            &quot;Cannot open Sui network config file at &#123;:?&#125;&quot;,\n                            network_config_path\n                        ))\n                    &#125;)?;\n\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;lib.rs\nfn load&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Self, anyhow::Error&gt; &#123;\n        let path &#x3D; path.as_ref();\n        trace!(&quot;Reading config from &#123;&#125;&quot;, path.display());\n        let reader &#x3D; fs::File::open(path)\n            .with_context(|| format!(&quot;Unable to load config from &#123;&#125;&quot;, path.display()))?;\n        Ok(serde_yaml::from_reader(reader)?)\n    &#125;</code></pre>\n\n<p><img src=\"/../img/302.png\" alt=\"Untitled\"></p>\n<h2 id=\"build-swarm\"><a href=\"#build-swarm\" class=\"headerlink\" title=\"build swarm\"></a>build swarm</h2><p>Swarm is a handle to an in-memory Sui network.It contain a network_config and validators.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;swarm.rs\n&#x2F;&#x2F;&#x2F; A handle to an in-memory Sui Network.\n#[derive(Debug)]\npub struct Swarm &#123;\n    dir: SwarmDirectory,\n    network_config: NetworkConfig,\n    validators: HashMap&lt;SuiAddress, Node&gt;,\n    fullnodes: HashMap&lt;SuiAddress, Node&gt;,\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute() \nlet mut swarm &#x3D; if no_full_node &#123;\n                    Swarm::builder()\n                &#125; else &#123;\n                    Swarm::builder()\n                        .with_fullnode_rpc_addr(sui_config::node::default_json_rpc_address())\n                &#125;\n                .from_network_config(sui_config_dir()?, network_config);</code></pre>\n\n<p><img src=\"/../img/303.png\" alt=\"Untitled\"></p>\n<h2 id=\"run-validators\"><a href=\"#run-validators\" class=\"headerlink\" title=\"run validators\"></a>run validators</h2><p>After we build the swarm, we can use it to run each validator.</p>\n<p>The whole process is:</p>\n<p><code>//node.spawn()--&gt;Container::spawn()--&gt;SuiNode::start()</code></p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute() \n\nswarm.launch().await?;\n\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;swarm.rs\n&#x2F;&#x2F;&#x2F; Start all of the Validators associated with this Swarm\n    pub async fn launch(&amp;mut self) -&gt; Result&lt;()&gt; &#123;\n        let start_handles &#x3D; self\n            .nodes_iter_mut()\n            .map(|node| node.spawn())\n            .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;\n\n        try_join_all(start_handles).await?;\n\n        Ok(())\n    &#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;node.rs\n\n&#x2F;&#x2F;&#x2F; Start this Node, returning a handle that will resolve when the node has completed starting\n    &#x2F;&#x2F;&#x2F; up.\n    pub fn spawn(&amp;mut self) -&gt; Result&lt;tokio::sync::oneshot::Receiver&lt;()&gt;&gt; &#123;\n        trace!(name &#x3D;% self.name(), &quot;starting in-memory node&quot;);\n        let (startup_receiver, node_handle) &#x3D;\n            Container::spawn(self.config.clone(), self.runtime_type);\n        self.thread &#x3D; Some(node_handle);\n        Ok(startup_receiver)\n    &#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;container.rs--&gt;spawn()\n\nruntime.block_on(async move &#123;\n                let prometheus_registry &#x3D; metrics::start_prometheus_server(config.metrics_address);\n                info!(\n                    &quot;Started Prometheus HTTP endpoint. To query metrics use\\n\\tcurl -s http:&#x2F;&#x2F;&#123;&#125;&#x2F;metrics&quot;,\n                    config.metrics_address\n                );\n                let _server &#x3D; SuiNode::start(&amp;config, prometheus_registry).await.unwrap();\n                &#x2F;&#x2F; Notify that we&#39;ve successfully started the node\n                let _ &#x3D; startup_sender.send(());\n                &#x2F;&#x2F; run until canceled\n                cancel_reciever.map(|_| ()).await;</code></pre>\n\n<h3 id=\"SuiNode\"><a href=\"#SuiNode\" class=\"headerlink\" title=\"SuiNode\"></a>SuiNode</h3><p>Suinode is the smallest unit of node management and is a very important object.It contains almost all the functions that a node needs to implement. The focus of our follow-up analysis is here.</p>\n<p>The main members of it are:</p>\n<ul>\n<li>config</li>\n<li>checkpoint_store</li>\n<li>_batch_subsystem_handle</li>\n<li>_execute_driver_handle</li>\n<li>state</li>\n<li>active</li>\n<li>_p2p_network</li>\n<li>_discovery</li>\n<li>_state_sync</li>\n<li>sim_node</li>\n</ul>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-node&#x2F;src&#x2F;lib.rs\n\npub struct SuiNode &#123;\n    config: NodeConfig,\n    checkpoint_store: Arc&lt;CheckpointStore&gt;,\n    validator_server_info: Option&lt;ValidatorServerInfo&gt;,\n    _json_rpc_service: Option&lt;ServerHandle&gt;,\n    _batch_subsystem_handle: tokio::task::JoinHandle&lt;()&gt;,\n    _post_processing_subsystem_handle: Option&lt;tokio::task::JoinHandle&lt;Result&lt;()&gt;&gt;&gt;,\n    _gossip_handle: Option&lt;tokio::task::JoinHandle&lt;()&gt;&gt;,\n    _execute_driver_handle: tokio::task::JoinHandle&lt;()&gt;,\n    state: Arc&lt;AuthorityState&gt;,\n    active: Arc&lt;ActiveAuthority&lt;NetworkAuthorityClient&gt;&gt;,\n    transaction_orchestrator: Option&lt;Arc&lt;TransactiondOrchestrator&lt;NetworkAuthorityClient&gt;&gt;&gt;,\n    _prometheus_registry: Registry,\n\n    _p2p_network: anemo::Network,\n    _discovery: discovery::Handle,\n    _state_sync: state_sync::Handle,\n\n    reconfig_channel: (\n        tokio::sync::mpsc::Sender&lt;EpochId&gt;,\n        tokio::sync::mpsc::Receiver&lt;EpochId&gt;,\n    ),\n\n    #[cfg(msim)]\n    sim_node: sui_simulator::runtime::NodeHandle,\n&#125;\n</code></pre>\n\n<p>Now let’s analyze the detailed steps in the node startup process:</p>\n<ol>\n<li>Judging whether it is fullnode or validator</li>\n<li>Initialize DB(committee_store,checkpoint_store,state_sync_store,index_store,event_store)</li>\n<li>create p2p network(discovery_handle,state_sync_handle)</li>\n<li>create transaction_streamer (if it’s fullNode)</li>\n<li>create node_sync_store</li>\n<li>create handles(batch_subsystem_handle,post_processing_subsystem_handle,execute_driver_handle)</li>\n<li>create json_rpc_service</li>\n<li>finish start up</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-node&#x2F;src&#x2F;lib.rs\npub async fn start(config: &amp;NodeConfig, prometheus_registry: Registry) -&gt; Result&lt;SuiNode&gt; &#123;\n        ...\n        let store &#x3D;\n            Arc::new(AuthorityStore::open(&amp;config.db_path().join(&quot;store&quot;), None, genesis).await?);\n        let committee_store &#x3D; Arc::new(CommitteeStore::new(\n            config.db_path().join(&quot;epochs&quot;),\n            &amp;committee,\n            None,\n        ));\n        let checkpoint_store &#x3D; CheckpointStore::new(&amp;config.db_path().join(&quot;checkpoints&quot;));\n\n        let state_sync_store &#x3D; RocksDbStore::new(\n            store.clone(),\n            committee_store.clone(),\n            checkpoint_store.clone(),\n        );\n\n        let index_store &#x3D; if is_validator &#123;\n            None\n        &#125; else &#123;\n            Some(Arc::new(IndexStore::open_tables_read_write(\n                config.db_path().join(&quot;indexes&quot;),\n                None,\n                None,\n            )))\n        &#125;;\n\n        let event_store &#x3D; if config.enable_event_processing &#123;\n            let path &#x3D; config.db_path().join(&quot;events.db&quot;);\n            let db &#x3D; SqlEventStore::new_from_file(&amp;path).await?;\n            db.initialize().await?;\n            Some(Arc::new(EventStoreType::SqlEventStore(db)))\n        &#125; else &#123;\n            None\n        &#125;;\n\n        let (p2p_network, discovery_handle, state_sync_handle) &#x3D;\n            Self::create_p2p_network(config, state_sync_store, &amp;prometheus_registry)?;\n\n       ...\n        let node_sync_store &#x3D; Arc::new(NodeSyncStore::open_tables_read_write(\n            config.db_path().join(&quot;node_sync_db&quot;),\n            None,\n            None,\n        ));\n\n        ...\n\n        let batch_subsystem_handle &#x3D; &#123;\n            &#x2F;&#x2F; Start batch system so that this node can be followed\n            let batch_state &#x3D; state.clone();\n            spawn_monitored_task!(async move &#123;\n                batch_state\n                    .run_batch_service(1000, Duration::from_secs(1))\n                    .await\n            &#125;)\n        &#125;;\n\n        let post_processing_subsystem_handle &#x3D;\n            if index_store.is_some() || config.enable_event_processing &#123;\n                let indexing_state &#x3D; state.clone();\n                Some(spawn_monitored_task!(async move &#123;\n                    indexing_state\n                        .run_tx_post_processing_process()\n                        .await\n                        .map_err(Into::into)\n                &#125;))\n            &#125; else &#123;\n                None\n            &#125;;\n\n        \n        let execute_driver_handle &#x3D; active_authority.clone().spawn_execute_process().await;\n\t\t\t\t...\n        let json_rpc_service &#x3D; build_server(\n            state.clone(),\n            &amp;transaction_orchestrator.clone(),\n            config,\n            &amp;prometheus_registry,\n        )\n        .await?;\n\n\t\t\t ...\n\n        info!(&quot;SuiNode started!&quot;);\n\n        Ok(node)</code></pre>\n\n<p><img src=\"/../img/304.png\" alt=\"Untitled\"></p>\n<p>We can get more info from the debug output.(here we only focus on the startup information of one node: 0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a).</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Launching: &#x2F;Users&#x2F;safeer&#x2F;sui&#x2F;target&#x2F;debug&#x2F;sui start\nLaunched process 80154\n2022-12-14T08:59:58.765242Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n\tcurl -s http:&#x2F;&#x2F;127.0.0.1:52424&#x2F;metrics\n2022-12-14T08:59:58.765242Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use\n2022-12-14T09:00:12.433291Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: Initializing sui-node listening on &#x2F;ip4&#x2F;127.0.0.1&#x2F;tcp&#x2F;52420&#x2F;http node&#x3D;k#8c26601d82aac59fade53f345f8fe84239d69652142a7fdc7724f729a1716a07e16b07a91e5afd49ee45d5cc6f5f3a9e0d152797d9251f2be21811a764a2dea2539c3b7541d52bf2e78b4d256bd94daa193f0c2234ec76276b80c6f0fedf4274\n2022-12-14T09:00:12.435263Z  WARN node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: mysten_metrics: init_metrics registry overwritten\n2022-12-14T09:13:51.573049Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Created&#x2F;opened SQLite EventStore on disk db_path&#x3D;&quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;authorities_db&#x2F;2727618050&#x2F;events.db&quot;\n2022-12-14T09:13:56.940186Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: SQLite events table is initialized with query &quot;CREATE TABLE IF NOT EXISTS events(timestamp INTEGER NOT NULL, seq_num INTEGER, event_num INTEGER, tx_digest BLOB, event_type INTEGER, package_id BLOB, module_name TEXT, function TEXT, object_type TEXT, object_id BLOB, fields TEXT, move_event_name TEXT, contents BLOB, sender BLOB, recipient TEXT);&quot;\n2022-12-14T09:14:05.392089Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;seq_num&quot;\n2022-12-14T09:14:10.311911Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;event_num&quot;\n2022-12-14T09:14:13.542209Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;timestamp&quot;\n2022-12-14T09:14:17.262100Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;tx_digest&quot;\n2022-12-14T09:14:20.959975Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;event_type&quot;\n2022-12-14T09:14:26.008174Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;package_id&quot;\n2022-12-14T09:14:30.079815Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;module_name&quot;\n2022-12-14T09:14:36.559934Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;sender&quot;\n2022-12-14T09:14:36.567273Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;recipient&quot;\n2022-12-14T09:14:36.574490Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;object_id&quot;\n2022-12-14T09:14:36.582455Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;object_type&quot;\n2022-12-14T09:14:36.589734Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;move_event_name&quot;\n2022-12-14T09:14:36.598456Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: P2p network started on 127.0.0.1:52422\n2022-12-14T09:14:43.930692Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active: respawn_node_sync_process epoch&#x3D;0\n2022-12-14T09:14:43.931350Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active: spawning node sync task\n2022-12-14T09:14:46.921729Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: acl&#x3D;Const(&quot;*&quot;)\n2022-12-14T09:14:46.922716Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: Sui JSON-RPC server listening on 0.0.0.0:9000 local_addr&#x3D;0.0.0.0:9000\n2022-12-14T09:14:46.922772Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: Available JSON-RPC methods : [&quot;sui_moveCall&quot;, &quot;sui_getCoinMetadata&quot;, &quot;sui_publish&quot;, &quot;sui_getObjectsOwnedByAddress&quot;, &quot;sui_payAllSui&quot;, &quot;sui_transferObject&quot;, &quot;sui_unsubscribeEvent&quot;, &quot;sui_executeTransaction&quot;, &quot;sui_mergeCoins&quot;, &quot;sui_subscribeTransaction&quot;, &quot;sui_getEvents&quot;, &quot;sui_getObject&quot;, &quot;sui_getTransactionsInRange&quot;, &quot;sui_getObjectsOwnedByObject&quot;, &quot;sui_executeTransactionSerializedSig&quot;, &quot;sui_subscribeEvent&quot;, &quot;sui_paySui&quot;, &quot;sui_getRawObject&quot;, &quot;sui_splitCoin&quot;, &quot;sui_getNormalizedMoveFunction&quot;, &quot;sui_getTransaction&quot;, &quot;sui_getTotalTransactionNumber&quot;, &quot;sui_pay&quot;, &quot;sui_getTransactionAuthSigners&quot;, &quot;sui_getMoveFunctionArgTypes&quot;, &quot;sui_transferSui&quot;, &quot;sui_batchTransaction&quot;, &quot;sui_unsubscribeTransaction&quot;, &quot;sui_dryRunTransaction&quot;, &quot;sui_splitCoinEqual&quot;, &quot;sui_getNormalizedMoveModule&quot;, &quot;sui_getNormalizedMoveModulesByPackage&quot;, &quot;sui_tryGetPastObject&quot;, &quot;rpc.discover&quot;, &quot;sui_getTransactions&quot;, &quot;sui_getCommitteeInfo&quot;, &quot;sui_getNormalizedMoveStruct&quot;]\n2022-12-14T09:14:58.627411Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: SuiNode started!\n2022-12-14T09:15:08.957227Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;:connection-manager&#123;peer&#x3D;82a014fa&#125;: anemo::network::connection_manager: ConnectionManager started\n2022-12-14T09:15:08.957369Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_network::discovery: Discovery started\n2022-12-14T09:15:08.957515Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_network::state_sync: State-Synchronizer started\n2022-12-14T09:15:08.960911Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active::execution_driver: Starting pending certificates execution process.</code></pre>\n\n<h2 id=\"health-check\"><a href=\"#health-check\" class=\"headerlink\" title=\"health check\"></a>health check</h2><p>After starting the nodes,Performing a health check service to check that status of the node(Check every 5 seconds).</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;node.rs--&gt;spawn()\n\n&#x2F;&#x2F;&#x2F; Perform a health check on this Node by:\n    &#x2F;&#x2F;&#x2F; * Checking that the node is running\n    &#x2F;&#x2F;&#x2F; * Calling the Node&#39;s gRPC Health service if it&#39;s a validator.\n    pub async fn health_check(&amp;self, is_validator: bool) -&gt; Result&lt;(), HealthCheckError&gt; &#123;\n        let thread &#x3D; self.thread.as_ref().ok_or(HealthCheckError::NotRunning)?;\n        if !thread.is_alive() &#123;\n            return Err(HealthCheckError::NotRunning);\n        &#125;\n\n        if is_validator &#123;\n            let channel &#x3D; mysten_network::client::connect(self.config.network_address())\n                .await\n                .map_err(|err| anyhow!(err.to_string()))\n                .map_err(HealthCheckError::Failure)\n                .tap_err(|e| error!(&quot;error connecting to &#123;&#125;: &#123;e&#125;&quot;, self.name()))?;\n\n            let mut client &#x3D; tonic_health::proto::health_client::HealthClient::new(channel);\n            client\n                .check(tonic_health::proto::HealthCheckRequest::default())\n                .await\n                .map_err(|e| HealthCheckError::Failure(e.into()))\n                .tap_err(|e| error!(&quot;error performing health check on &#123;&#125;: &#123;e&#125;&quot;, self.name()))?;\n        &#125;\n\n        Ok(())\n    &#125;</code></pre>\n\n<h1 id=\"Summarize\"><a href=\"#Summarize\" class=\"headerlink\" title=\"Summarize\"></a><strong>Summarize</strong></h1><p>We analyzed the startup process of the node in this page. </p>\n<ul>\n<li>reading the configuration file</li>\n<li>generating objects according to the configuration file</li>\n<li>open services during the node startup process</li>\n</ul>\n<p>In the following articles, we will analyze each part in detail, the most important of which is to analyze the various services opened during the node startup process(SuiNode object).</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clbbmsdze00016b7l1vg0hzdm","tag_id":"clbbmsdzj00036b7lbd5jgea5","_id":"clbbmsdzp00056b7lbhh54o2w"},{"post_id":"clcfu8udp0000t9qqhvi09lzv","tag_id":"clcfu8uds0001t9qq0o2jgn55","_id":"clcfu8udt0003t9qqbb4ubphg"},{"post_id":"clca67fe20000jjqq2ytb76v7","tag_id":"clcfu8udt0002t9qq7q375nh0","_id":"clcfu8udt0004t9qq96sb3d48"}],"Tag":[{"name":"move prover, m","_id":"clbbmsdzj00036b7lbd5jgea5"},{"name":"Sui blockchain,Sui,Move Language","_id":"clcfu8uds0001t9qq0o2jgn55"},{"name":"SuiEcosystem, MoveLang","_id":"clcfu8udt0002t9qq7q375nh0"}]}}