{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/discord.png","path":"img/discord.png","modified":0,"renderable":0},{"_id":"source/img/icon.png","path":"img/icon.png","modified":0,"renderable":0},{"_id":"source/img/movebit_logo.png","path":"img/movebit_logo.png","modified":0,"renderable":0},{"_id":"source/img/movectf.jpeg","path":"img/movectf.jpeg","modified":0,"renderable":0},{"_id":"source/img/post3_1.png","path":"img/post3_1.png","modified":0,"renderable":0},{"_id":"source/img/post3_2.png","path":"img/post3_2.png","modified":0,"renderable":0},{"_id":"source/img/post3_3.png","path":"img/post3_3.png","modified":0,"renderable":0},{"_id":"source/img/sui_logo.png","path":"img/sui_logo.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-movebit/source/css/base.css","path":"css/base.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/common.css","path":"css/common.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/github-markdown.css","path":"css/github-markdown.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/index.css","path":"css/index.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/css/post.css","path":"css/post.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo.css","path":"iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo_index.html","path":"iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.css","path":"iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.js","path":"iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.json","path":"iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff2","path":"iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/js/backtotop.js","path":"js/backtotop.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-movebit/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"source/img/123.png","path":"img/123.png","modified":0,"renderable":0},{"_id":"source/img/1234.png","path":"img/1234.png","modified":0,"renderable":0},{"_id":"source/img/12345.png","path":"img/12345.png","modified":0,"renderable":0},{"_id":"source/img/123456.png","path":"img/123456.png","modified":0,"renderable":0},{"_id":"source/img/23.jpeg","path":"img/23.jpeg","modified":0,"renderable":0},{"_id":"source/img/24.png","path":"img/24.png","modified":0,"renderable":0},{"_id":"source/img/25.png","path":"img/25.png","modified":0,"renderable":0},{"_id":"source/img/26.png","path":"img/26.png","modified":0,"renderable":0},{"_id":"source/img/27.png","path":"img/27.png","modified":0,"renderable":0},{"_id":"source/img/28.png","path":"img/28.png","modified":0,"renderable":0},{"_id":"source/img/30.png","path":"img/30.png","modified":0,"renderable":0},{"_id":"source/img/31.png","path":"img/31.png","modified":0,"renderable":0},{"_id":"source/img/33.png","path":"img/33.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"e08d7e577111e41028e5adc3327d26bd87d9775e","modified":1670233923530},{"_id":"source/about/index.md","hash":"a5b280c8415bb43fae135e6d11f044e4c42bd049","modified":1670233923530},{"_id":"source/_posts/move-prover-tutorial-part-1.md","hash":"c4d435b42eb784d11f18152b68281a29d887220c","modified":1670233923530},{"_id":"source/_posts/the-first-movectf-summary.md","hash":"caf4171520e1c8359382928f41547de6d426bd14","modified":1670233923530},{"_id":"source/_posts/movectf.md","hash":"19e387c641906dbe7d0f46adfc16f5f3491a658d","modified":1670233923530},{"_id":"source/img/discord.png","hash":"5a6c95672d7ab8864959b58aca7aaea97f981d08","modified":1670233992152},{"_id":"source/.DS_Store","hash":"406834b0d7b1b1254393ba2f2c4ef678bb2bd10c","modified":1670233923530},{"_id":"source/img/icon.png","hash":"d9d8a92a43f9a9a45177e51e7666a93b1a80b73b","modified":1670233923531},{"_id":"source/img/movebit_logo.png","hash":"e9c8ea1ba562979d702a2d1a3332b77821aa75f5","modified":1670233923531},{"_id":"source/img/movectf.jpeg","hash":"0a50cd6800edecbc2fc7b5849ae512b8549e5561","modified":1670233923531},{"_id":"source/img/post3_2.png","hash":"019446fc29fcc0a3333dec0e58475051a1a39d89","modified":1670233923532},{"_id":"source/img/post3_3.png","hash":"1111a336ef4886beabba1023bc44e3029314ae94","modified":1670233923532},{"_id":"source/img/sui_logo.png","hash":"8e28db5c0e2bf50169a38aa351fdbcc842cd9673","modified":1670233923533},{"_id":"source/img/post3_1.png","hash":"02c1f6c63c1c4a54820c514158fa7298445471dd","modified":1670233923532},{"_id":"node_modules/hexo-theme-movebit/LICENSE","hash":"c780fac19902db7360b2bab8f3783c08d28c11da","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/README.md","hash":"6771ab7cd71f572ce385429248a1e9ea2bd6733b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/README.zh-CN.md","hash":"ca987cefc6c33b8035d4d238129928b54187ccec","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/_config.yml","hash":"c98f7ff2b0422bc5f2ddf9461df8367d74d9a2d4","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/package.json","hash":"7511368500be47817900d26427869329d580176d","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/es.yml","hash":"29cf37178f7596fe408cd3234d3addb880608287","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/de.yml","hash":"72cc121b4a9e18c55623cf8035d288e415841851","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/ja.yml","hash":"08c64794618945b5da0edcc5065e46577fbd5ff3","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/default.yml","hash":"c6ab47da3b1e3ec2098aee65cd5b3ee1fd4cc299","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/fr.yml","hash":"ac102613f8a7f10b32b6e38d99d5511034733a0d","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/ko.yml","hash":"98f150835d5b039cdfe1cf8b32df815d8d763231","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/nl.yml","hash":"e6f86d1bc16c916089057e8c8d354983ee839d21","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/no.yml","hash":"1c6fd53c378fdd00c2f84ef0af4f61c1f8ea4f8b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/pt.yml","hash":"0719f13aa9f5211400b129d310f517750f4a6e0b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/ru.yml","hash":"ada59b0713fef0e6617a12b20065ce9b24234521","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/zh-CN.yml","hash":"3a3b4ade3ffcf5ef330e31d3ce0d69804cfa7c26","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/languages/zh-TW.yml","hash":"3d26316a125ea18c64658d4e028351e395e45756","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/archive.ejs","hash":"7fafb2111830763e65c3fef26c9063fdfd17e2a4","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/index.ejs","hash":"fd7067b5dcecb0c42580a760d26808e336964818","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/layout.ejs","hash":"28a32f4c9ec414e5e8f4f5054782ef26435071a1","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/post.ejs","hash":"3e709ffcc4e06d651c9aababfda7582ff484acb1","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/backtotop.ejs","hash":"a7dfc124629cb256adf26963bb393b89f09a3476","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/footer.ejs","hash":"63d582ba201f9e43fe7f93c627a7559b0269ed6e","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/header.ejs","hash":"776d6a10d9813ad36d4a99772733ba2c27b4bbbf","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/links.ejs","hash":"b143f142b3ab8b78d996c46814cd06ed6cf6a2df","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/name.ejs","hash":"bbfb751eddc8a6d22fe727d655eeb4a6a787511c","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/layout/_partial/search.ejs","hash":"7e09f78f4f1c907076a0e82b500827fe017119cc","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/base.css","hash":"823cd020f9ab198105689f3aa02c0c0cbd60f5dc","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/common.css","hash":"5a3e4c477645aa8e557d3e680924b327a0a0f625","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/github-markdown.css","hash":"f78aa3fbbcc5cceab0ee67246b55db8b982c4634","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/highlight.css","hash":"22c32290b22589e69f53cbbd632c77bf398f2130","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/index.css","hash":"5d4d3b2b286ae9b45cd060698060cdbd0571eed9","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/css/post.css","hash":"02736e416b73bd0dbda7d2f8d22d31fb7a3386a1","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo_index.html","hash":"db375ad1f08ed3eeeb455771fca147838394551a","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.js","hash":"55c291a13445c03d566ac8436103a72806d212a5","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.json","hash":"c0eaad34b9e807d2227177d58ec784a5a5e7a89b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.css","hash":"bd5cee4f45e9e3803107ecc6add2d54387246c01","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.eot","hash":"ec8e59b46aee56ebd3fd4bc891fa89b141f8dd77","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.ttf","hash":"434a4874aca648921248884536c3bf3e15e8ff46","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.svg","hash":"39b05213c87755919dd16144be63e288c58d9e81","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff","hash":"97b0996a861db6fdbbc35f40319580273604404b","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/iconfont/iconfont.woff2","hash":"7ef38c1ebe016f9431f1ef5e9ee7348b38a3a3a9","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/js/backtotop.js","hash":"7d31a9b613dcaa88e0f4154a62cd0fb2cfe598e8","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/images/avatar.png","hash":"ea85d371631b34984022817ab63449fb297a2a93","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/images/favicon.png","hash":"7ac208a08013a1dbfa19253602b05b84095310b0","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/js/fancybox.js","hash":"b217d56f8db94498d7e272d164abac6ab1c07ddd","modified":1670295417479},{"_id":"node_modules/hexo-theme-movebit/source/js/search.js","hash":"21c1e736a60de5243742272a7009b47fa1a6ecee","modified":1670295417479},{"_id":"public/atom.xml","hash":"da9d1d945016cd449649cd4e8c9f5845616befdf","modified":1672385141912},{"_id":"public/search.xml","hash":"488c574ff5e3b98ee94ce222b3403f9a0502023d","modified":1672385141912},{"_id":"public/about/index.html","hash":"67867897bce469cd459300688a3725217e90350d","modified":1670295455446},{"_id":"public/post/the-first-movectf-summary.html","hash":"9653bcfec730860f3c0d3d172108ab6f2dcaedfc","modified":1672383974299},{"_id":"public/post/movectf.html","hash":"01c7e55edeb55c483763383f3ee5266e2545e0f1","modified":1670295455446},{"_id":"public/archives/index.html","hash":"a13300a41ff57fc69e9fd9c39aff137de5aa774b","modified":1672383974299},{"_id":"public/archives/2022/index.html","hash":"d3058cbb16f7853d52544fcddde01354559029f6","modified":1672383974299},{"_id":"public/archives/2022/09/index.html","hash":"56d684d8843676ba1e4e6e6275c1bf67130163d0","modified":1672383974299},{"_id":"public/archives/2022/10/index.html","hash":"298a09670db93fd0348b70c21f24d60bbd4c9e05","modified":1672383974299},{"_id":"public/archives/2022/11/index.html","hash":"0cc73a94a130f1a70a37227ffc27f807f59bea86","modified":1672383974299},{"_id":"public/index.html","hash":"6d4734cd9fa7aa4451ddd594d78592240f09bb77","modified":1672383974299},{"_id":"public/tags/move-prover-m/index.html","hash":"c886ac3939f6b1ba66b052430bdc10be0517fbed","modified":1672383974299},{"_id":"public/post/move-prover-tutorial-part-1.html","hash":"0473366d7168ff5bcfef4b6e45be38ca92b221a5","modified":1670295455446},{"_id":"public/CNAME","hash":"e08d7e577111e41028e5adc3327d26bd87d9775e","modified":1670295455446},{"_id":"public/img/icon.png","hash":"d9d8a92a43f9a9a45177e51e7666a93b1a80b73b","modified":1670295455446},{"_id":"public/img/discord.png","hash":"5a6c95672d7ab8864959b58aca7aaea97f981d08","modified":1670295455446},{"_id":"public/img/movebit_logo.png","hash":"e9c8ea1ba562979d702a2d1a3332b77821aa75f5","modified":1670295455446},{"_id":"public/img/movectf.jpeg","hash":"0a50cd6800edecbc2fc7b5849ae512b8549e5561","modified":1670295455446},{"_id":"public/img/post3_2.png","hash":"019446fc29fcc0a3333dec0e58475051a1a39d89","modified":1670295455446},{"_id":"public/img/post3_3.png","hash":"1111a336ef4886beabba1023bc44e3029314ae94","modified":1670295455446},{"_id":"public/img/sui_logo.png","hash":"8e28db5c0e2bf50169a38aa351fdbcc842cd9673","modified":1670295455446},{"_id":"public/iconfont/iconfont.eot","hash":"ec8e59b46aee56ebd3fd4bc891fa89b141f8dd77","modified":1670295455446},{"_id":"public/iconfont/iconfont.svg","hash":"39b05213c87755919dd16144be63e288c58d9e81","modified":1670295455446},{"_id":"public/iconfont/iconfont.ttf","hash":"434a4874aca648921248884536c3bf3e15e8ff46","modified":1670295455446},{"_id":"public/iconfont/iconfont.woff","hash":"97b0996a861db6fdbbc35f40319580273604404b","modified":1670295455446},{"_id":"public/iconfont/iconfont.woff2","hash":"7ef38c1ebe016f9431f1ef5e9ee7348b38a3a3a9","modified":1670295455446},{"_id":"public/images/avatar.png","hash":"ea85d371631b34984022817ab63449fb297a2a93","modified":1670295455446},{"_id":"public/images/favicon.png","hash":"7ac208a08013a1dbfa19253602b05b84095310b0","modified":1670295455446},{"_id":"public/img/post3_1.png","hash":"02c1f6c63c1c4a54820c514158fa7298445471dd","modified":1670295455446},{"_id":"public/css/base.css","hash":"823cd020f9ab198105689f3aa02c0c0cbd60f5dc","modified":1670295455446},{"_id":"public/css/common.css","hash":"5a3e4c477645aa8e557d3e680924b327a0a0f625","modified":1670295455446},{"_id":"public/css/github-markdown.css","hash":"f78aa3fbbcc5cceab0ee67246b55db8b982c4634","modified":1670295455446},{"_id":"public/css/highlight.css","hash":"22c32290b22589e69f53cbbd632c77bf398f2130","modified":1670295455446},{"_id":"public/css/index.css","hash":"5d4d3b2b286ae9b45cd060698060cdbd0571eed9","modified":1670295455446},{"_id":"public/css/post.css","hash":"02736e416b73bd0dbda7d2f8d22d31fb7a3386a1","modified":1670295455446},{"_id":"public/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1670295455446},{"_id":"public/iconfont/iconfont.css","hash":"bd5cee4f45e9e3803107ecc6add2d54387246c01","modified":1670295455446},{"_id":"public/iconfont/iconfont.json","hash":"c4410acbaeba94ff0d48d1e2ccddf49213b40626","modified":1670295455446},{"_id":"public/js/backtotop.js","hash":"7d31a9b613dcaa88e0f4154a62cd0fb2cfe598e8","modified":1670295455446},{"_id":"public/js/fancybox.js","hash":"b217d56f8db94498d7e272d164abac6ab1c07ddd","modified":1670295455446},{"_id":"public/js/search.js","hash":"21c1e736a60de5243742272a7009b47fa1a6ecee","modified":1670295455446},{"_id":"public/iconfont/demo_index.html","hash":"db375ad1f08ed3eeeb455771fca147838394551a","modified":1670295455446},{"_id":"public/iconfont/iconfont.js","hash":"55c291a13445c03d566ac8436103a72806d212a5","modified":1670295455446},{"_id":"source/_posts/222.md","hash":"9756cb2ecbde649a1a2b3a5fe38dff8869da64da","modified":1672382702115},{"_id":"public/archives/2022/12/index.html","hash":"0c8165fa6602d6bde9bbf034b4e4a221f43c8ee1","modified":1672383974299},{"_id":"public/post/222.html","hash":"2854f5e662912ed08b8f6670fb6d5dc788b6df62","modified":1672382712448},{"_id":"source/img/123.png","hash":"7ce527ce0c45087929b3d8ddc3f8216f7f0f8c23","modified":1672381017710},{"_id":"public/img/123.png","hash":"7ce527ce0c45087929b3d8ddc3f8216f7f0f8c23","modified":1672381119856},{"_id":"source/img/23.jpeg","hash":"a12e9e4b5ed6d177ced8f0e5b77457f2f651c834","modified":1672382563708},{"_id":"source/img/24.png","hash":"d93e8f8cb41fdf6e66c3c6b4f4d169ead0011628","modified":1672382662158},{"_id":"source/img/123456.png","hash":"d9bbca76c3d8aa34712d9d7494d1afd54a8eeee8","modified":1672382503315},{"_id":"source/img/1234.png","hash":"107ddb55c7a73a43da9f9bbbc805e07524c77af1","modified":1672381845159},{"_id":"source/img/12345.png","hash":"c1fdab9896d096838a3916e7b72a5439008b3ce1","modified":1672382009100},{"_id":"public/img/23.jpeg","hash":"a12e9e4b5ed6d177ced8f0e5b77457f2f651c834","modified":1672382712448},{"_id":"public/img/123456.png","hash":"d9bbca76c3d8aa34712d9d7494d1afd54a8eeee8","modified":1672382712448},{"_id":"public/img/24.png","hash":"d93e8f8cb41fdf6e66c3c6b4f4d169ead0011628","modified":1672382712448},{"_id":"public/img/1234.png","hash":"107ddb55c7a73a43da9f9bbbc805e07524c77af1","modified":1672382712448},{"_id":"public/img/12345.png","hash":"c1fdab9896d096838a3916e7b72a5439008b3ce1","modified":1672382712448},{"_id":"source/_posts/Sui Concept and Testnet.md","hash":"dc37c61bab35232393bb2b2f2b8ca8120446c0fc","modified":1672385039236},{"_id":"source/img/27.png","hash":"eab8d3d94cbd943c3c6f377330d1d105eb0e99c9","modified":1672382982360},{"_id":"source/img/28.png","hash":"1b117e61314ec2d9effc35d7ccc96ea4eda61974","modified":1672383311980},{"_id":"source/img/31.png","hash":"ec3469082a95eed4d56e5eddbb9d28421c1a64f1","modified":1672383491026},{"_id":"source/img/25.png","hash":"db806d4b8e038c3f915d672b5678f2d167c57671","modified":1672382782771},{"_id":"source/img/26.png","hash":"14f3d8827dc2d2418af9acac0d8e1044bcb5fa3c","modified":1672382921031},{"_id":"source/img/30.png","hash":"cba4945d65c3f5910bbadfea6c0168843dc4ca9d","modified":1672383435526},{"_id":"source/img/33.png","hash":"b2267e166183c1b7618ead9fdcad583e14556005","modified":1672383555651},{"_id":"public/post/Sui Concept and Testnet.html","hash":"23f0caeae1390b92eada45cfe2c4141886362389","modified":1672385141912},{"_id":"public/img/27.png","hash":"eab8d3d94cbd943c3c6f377330d1d105eb0e99c9","modified":1672383974299},{"_id":"public/img/28.png","hash":"1b117e61314ec2d9effc35d7ccc96ea4eda61974","modified":1672383974299},{"_id":"public/img/31.png","hash":"ec3469082a95eed4d56e5eddbb9d28421c1a64f1","modified":1672383974299},{"_id":"public/img/25.png","hash":"db806d4b8e038c3f915d672b5678f2d167c57671","modified":1672383974299},{"_id":"public/img/26.png","hash":"14f3d8827dc2d2418af9acac0d8e1044bcb5fa3c","modified":1672383974299},{"_id":"public/img/30.png","hash":"cba4945d65c3f5910bbadfea6c0168843dc4ca9d","modified":1672383974299},{"_id":"public/img/33.png","hash":"b2267e166183c1b7618ead9fdcad583e14556005","modified":1672383974299}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2022-09-27T01:47:49.000Z","_content":"\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-09-27 09:47:49\n---\n\n","updated":"2022-12-05T09:52:03.530Z","path":"about/index.html","comments":1,"layout":"page","_id":"clbbmsdzb00006b7l8ol3gc8i","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Verify Smart Contracts in Aptos with the Move Prover Pt.1","date":"2022-09-27T08:53:50.000Z","description":"It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts","thumbnail":"/img/icon.png","_content":"\n*Xudong Wang  & 0xyi* 09-14-2022\n\n\nIt has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?\n\nWe will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. \n\nFor this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.\n\n\n## What is the Move Prover\n\nFormal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.\nNow it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.\n\nSmart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.\n**Move Prover (MVP)** is designed to prevent bugs in smart contracts written in the Move language.\n\nIn Aptos ( and Starcoin/Sui ), Users can specify functional properties of smart contracts using the **Move Specification Language (MSL)**, and then use the Move Prover to automatically and statically inspect them.\n\nSimply put, there can be two components in a Move file:\n\n- Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.\n\n- The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.\n\nWhen we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.\n\n## Install Prover dependencies in Aptos\n\nBefore using the Move Prover, let's install some of its external dependencies.\nIt is assumed that you already have [installed Aptos CLI](https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli).\nMake sure you did \"Step 3\" and installed the dependencies of the Move Prover:\n\n```bash\n./scripts/dev_setup.sh -yp\n. ~/.profile\n```\n\nWhen the above command is executed, enter `boogie /version`, if the output is similar to \"Boogie program verifier version X.X.X\", then the installation has been successful.\n\nNote that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).\nWindows users can run it by installing [WSL](https://docs.microsoft.com/en-us/windows/wsl/install).\n\n## Prepare an example for verification in \n\n### Project creation\n\nFirst, let's create a new empty Move package:\n\n```bash\nmkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin\n```\n\nYou can see that its directory structure is as follows:\n\n```\nbasic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    `---- sources   (Directory)\n```\n\n### Module code\n\nNow create `basic_coin/sources/BasicCoin.move`.\n\n<details>\n<summary> BasicCoin.move content</summary>\n\n```rust\n/// This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin {\n    use std::error;\n    use std::signer;\n\n    /// Error codes\n    const ENOT_MODULE_OWNER: u64 = 0;\n    const EINSUFFICIENT_BALANCE: u64 = 1;\n    const EALREADY_HAS_BALANCE: u64 = 2;\n\n    struct Coin<phantom CoinType> has store {\n        value: u64\n    }\n\n    struct Balance<phantom CoinType> has key {\n        coin: Coin<CoinType>\n    }\n\n    /// Publish an empty balance resource under `account`'s address. This function must be called before\n    /// minting or transferring to the account.\n    public fun publish_balance<CoinType>(account: &signer) {\n        let empty_coin = Coin<CoinType> { value: 0 };\n        assert!(!exists<Balance<CoinType>>(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance<CoinType> { coin:  empty_coin });\n    }\n\n    /// Mint `amount` tokens to `mint_addr`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can decide the minting policy.\n    public fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance {\n        // Deposit `total_value` amount of tokens to mint_addr's balance\n        deposit(mint_addr, Coin<CoinType> { value: amount });\n    }\n\n    public fun balance_of<CoinType>(owner: address): u64 acquires Balance {\n        borrow_global<Balance<CoinType>>(owner).coin.value\n    }\n\n    /// Transfers `amount` of tokens from `from` to `to`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can  decide the transferring policy.\n    public fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance {\n        let addr_from = signer::address_of(from);\n        let check = withdraw<CoinType>(addr_from, amount);\n        deposit<CoinType>(to, check);\n    }\n\n    fun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance {\n        let balance = balance_of<CoinType>(addr);\n        assert!(balance >= amount, EINSUFFICIENT_BALANCE);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        *balance_ref = balance - amount;\n        Coin<CoinType> { value: amount }\n    }\n    \n    fun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance{\n        let balance = balance_of<CoinType>(addr);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        let Coin { value } = check;\n        *balance_ref = balance + value;\n    }\n}\n```\n\n</details>\n\nHere we assume that you have a certain grasp of the Move language, and can understand the source code of `BasicCoin.move` above and know the function of each part.\n\n### TOML configuration\n\nBasicCoin uses some facilities of the Aptos standard library, and also needs to add `aptos-framework` to the dependencies. We also need to specify what numerical address it should be replaced with. \n\nTherefore, we modify Move.toml as follows:\n\n```toml\n[package]\nname = \"BasicCoin\"\nversion = \"0.0.0\"\n\n[dependencies]\nAptosFramework = { git = \"https://github.com/aptos-labs/aptos-core.git\", subdir = \"aptos-move/framework/aptos-framework/\", rev = \"main\" }\n\n[addresses]\nBasicCoin=\"Replace_It_With_Your_Numerical_Address\"  \n\n```\n\n## The first verification code\n\nTo give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n}\n```\n\nSyntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the `balance_of` function in order to clearly see the correspondence between the definition and the specification when reading the code.\n\nSimply put, the `spec balance_of {...}` block will contain our **property specification** for the `balance_of` function.\nThere are many types of property specifications, some common examples are:\n\n- Will this function abort? Under what circumstances does it abort?\n- What conditions must be met for the parameters to call this function?\n- What is the return value of this function?\n- After the function is executed, how will the state of the virtual machine be changed?\n- What invariants does this function maintain?\n\nFor example, the Move Prover allows all possible aborts by default when we don't give any abort conditions.\nAnd in the simple snippet above, we tell Prover with the directive `aborts_if_is_strict`:\n\n> I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.\n\nNow, we run the `prove` command in the `basic_coin` directory:\n\n```bash\naptos move prove\n```\nit will call the Move Prover to check the code in the package.\nThen we can see the Prover reporting the following error message:\n\n```\nerror: abort not covered by any of the `aborts_if` clauses\n   ┌─ ./sources/BasicCoin.move:38:5\n   │\n35 │           borrow_global<Balance<CoinType>>(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of {\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     }\n   │ ╰─────^\n   │\n   =     at ./sources/BasicCoin.move:34: balance_of\n   =         owner = 0x29\n   =     at ./sources/BasicCoin.move:35: balance_of\n   =         ABORTED\n\nFAILURE proving 1 modules from package `basic_coin` in 1.794s\n{\n  \"Error\": \"Move Prover failed: exiting with verification errors\"\n}\n```\n\nProver's output tells us that it found a situation where the `balance_of` function aborts, but we don't explicitly point out the possibility of such aborts.\nLooking at the code that triggers the abort, we can see that the exception is caused by calling the built-in `borrow_global` function when the `owner` does not own a resource of type `Balance<CoinType>`.\nFollowing the guidance of the error message, we can add the following `aborts_if` condition:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n    aborts_if !exists<Balance<CoinType>>(owner);\n}\n```\n\nAfter adding this condition, try calling Prover again and see that there are no more validation errors.\nNow we can confidently confirm that the `balance_of` function has one and only one possibility of abnormal termination, that is, the parameter `owner` does not own a resource of type `Balance<CoinType>`.\n\n## Verify withdraw function\n\nThe signature of the function `withdraw` is as follows:\n\n```rust\nfun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance\n```\n\nIts role is to withdraw the `amount` of coins from the address `addr` and return it.\n\n### Specify the abort condition for `withdraw`\n\nThere are two possibilities for `withdraw` to abort:\n\n1. No resource of type `Balance<CoinType>` in `addr`.\n2. The balance in `addr` is less than `amount`.\n\nFrom these, we can define the abort condition like this:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n}\n```\n\n- A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.\n`global<T>(addr): T` is a built-in function that returns a resource of type `T` at address `addr`.\nHere, we set balance to the number of tokens owned by addr via the let binding;\n- `exists<T>(address): bool` is a built-in function that returns true if resource `T` exists at address `addr`; otherwise returns false.\n\nThe two lines of `aborts_if` statements correspond to the two conditions mentioned above.\nIn general, if a function has multiple `aborts_if` conditions, the conditions are ORed together.\n\nAs mentioned earlier, if we don't specify any abort conditions, Prover will not impose any restrictions on aborts.\nBut once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction `pragma aborts_if_is_strict`.\nIf only some of the conditions for abnormal exit are listed, the Prover will report a validation error.\nHowever, if the `pragma aborts_if_is_partial` is defined in the spec block, this is equivalent to telling the Prover:\n\n> I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.\n\nIf you are interested, you can do such a set of experiments to verify:\n\n- When deleting any of the above two `aborts_if` conditions, Prover will report an error;\n- When all `aborts_if` conditions are deleted at the same time, Prover will not report an error;\n- When adding `pragma aborts_if_is_partial`, no matter how many `aborts_if` conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).\n\nSome readers may be curious about the order of the three statements in the spec block:\nWhy the definition of balance can be written after `aborts_if !exists<Balance<CoinType>>(addr)`.\nBecause, if the latter holds true, `balance` does not actually exist.\nWouldn't this order cause the Prover to fail?\nSimply put: no, the statements in the spec block are declarative and the order doesn't matter.\n\nFor a more detailed understanding, you can refer to the MSL documentation for more information.\n\n### Specify the functional nature of `withdraw`\n\nNext, we define functional properties.\nThe two `ensures` statements in the following spec block give us what we expect from the `withdraw` functionality:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n    ensures result == Coin<CoinType> { value: amount };\n}\n```\n\nIn this code, first by using `let post` binding, define `balance_post` as the balance of `addr` after the function is executed, it should be equal to `balance - amount`. Then, `result` is a special name that represents the return value, which should be the `amount` of tokens.\n\n## Verify the `deposit` function\n\nThe signature of the function deposit is as follows:\n\n```rust\nfun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance\n```\n\nIt deposits the token funds indicated by `check` into the address `addr`. Its canonical definition is as follows:\n\n```rust\nspec deposit {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    let check_value = check.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + check_value > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + check_value;\n}\n```\n\nHere, `balance` is defined as the balance in `addr` before the function is executed, and `check_value` is defined as the amount of tokens to be deposited. It will abort in two cases:\n\n1. There is no resource of type `Balance<CoinType>` in `addr`;\n2. Or the sum of `balance` and `check_value` is greater than the maximum value of type `u64`.\n\nThe `ensures` statement is used to let the Prover make sure that in any case, the balance in `addr` can be updated correctly after the function is executed.\n\nThe syntax mentioned earlier will not be repeated here.\nAstute readers may have noticed that it is worth noting that the expression `balance + check_value > MAX_U64` is problematic in the Move program.\nBecause the addition on the left may cause an overflow exception.\nIf we want to write a similar check in the Move program, we should use an expression like `balance > MAX_U64 - check_value` to avoid the overflow problem.\n\nHowever, this expression is perfectly fine in the Move Specification Language (MSL).\nSince the spec block uses the MSL language, its type system is different from that of Move.\nIn MSL, all integers are of type `num`, which is an integer in the mathematical sense. That is, it is signed and has no size limit.\nAll built-in integer types (`u8`, `u64`, etc.) are automatically converted to type `num` when referencing data in a Move program in MSL.\nA more detailed description of the type system can be found in the MSL documentation.\n\n## Verify the `transfer` function\n\nThe signature of the function `transfer` is as follows:\n\n```rust\npublic fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for the transfer `from` the account from to the address `to`, and the transfer amount is `amount`.\n\nLet's ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:\n\n```rust\nspec transfer {\n    let addr_from = signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n```\n\nHere `from` is of type `signer`, not a direct address.\nAlthough in the program we have created a local variable called `addr_from`, we cannot directly reference it in the spec block.\nAt the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to `addr_from` again.\nThen use `let` and `let post` to define several variables, corresponding to the balances in the two addresses `addr_from` and `to` before and after the function is executed.\nFinally, use the `ensures` statement to tell Prover that the balance in `from` should be subtracted by `amount`; the balance in `to` should be increased by `amount`.\n\nAt first glance, there seems to be no problem at all. But is it really so?\nLet's see if Prover thinks this is \"the correct description of the behavior of this function\".\nAfter typing `aptos move prove` you can see:\n\n```\nerror: post-condition does not hold\n   ┌─ ./sources/BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post == balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   =     at ./sources/BasicCoin.move:45: transfer\n   =     at ./sources/BasicCoin.move:51: transfer (spec)\n   =     at ./sources/BasicCoin.move:53: transfer (spec)\n   =     at ./sources/BasicCoin.move:54: transfer (spec)\n   =     at ./sources/BasicCoin.move:45: transfer\n   =         from = signer{0x0}\n   =         to = 0x0\n   =         amount = 1\n   =         _witness = <generic>\n```\n\nIt is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the `transfer` function.\nWhy is this so? Let's look down again: the parameters that make the postconditions not satisfied are `from = signer{0x0}` and `to = 0x0`. We should know the reason: when the account transfers money to itself, both `to` and `from` point to the same address, so the balance does not change.\n\nThere are two solutions now:\n\n**Plan A** does not modify the function definition, but changes the specification.\nIn the spec block, consider whether the two accounts for the transfer and receiving are the same address.\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures (addr_from == to && eq_post) || (addr_from != to && ne_post);\n```\n\nOr use another slightly more intuitive if syntax:\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures if (addr_from == to) eq_post else ne_post;\n```\n\nNote that `if (P) E1 else E2` is not the same as conditional execution in program logic -- it's actually a syntactic sugar equivalent to `ensures` both `P ==> E1` and `!P ==> E2`.\nAnd `p ==> q` is actually `!p || q`.\n\nThat is to say, the end of the second way of writing actually represents this logic:\n\n```rust\nensures (addr_from == to  ===>  eq_post) && (addr_from != to  ===> ne_post);\n```\n\nthat is:\n\n```rust\nensures (addr_from != to || eq_post) && (addr_from == to  || ne_post);\n```\n\nInterested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former `(addr_from == to && eq_post) || (addr_from != to && ne_post)` and the latter `(addr_from != to || eq_post) && (addr_from == to  || ne_post)` are actually exactly equivalent expressions.\n\n**Plan B** does not modify the spec, but directly adds `assert!(addr_from != to, EEQUAL_ADDR);` in the function body, and adds the definition of the error code `EEQUAL_ADDR` in front, so that the self-transfer transaction cannot be completed.\n\nObviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.\nSo plan B is a better practice.\nIt directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.\n\n### Practice\n\nCurrently, we have only completed functional verification of the `transfer` function.\nBut it doesn't say under what circumstances it will abort.\nAs an exercise, give it an appropriate `aborts_if` condition. The answer can be found in our next article.\n\n## Verify mint function\n\nThe signature of the function `mint` is as follows:\n\n```rust\npublic fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for minting the `amount` of tokens and depositing them in the address `mint_addr`.\nMore interesting is `_witness`, which is of type `CoinType`.\nBecause only the module that defines the `CoinType` can construct a value of this type, this guarantees the identity of the caller.\n\nThere is actually only one call to `deposit` in the `mint` function.\nIt is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:\n\n```rust\nspec mint {\n    let balance = global<Balance<CoinType>>(mint_addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(mint_addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(mint_addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\n## Verify the `publish_balance` function\n\nThe signature of the function `publish_balance` is as follows:\n\n```rust\npublic fun publish_balance<CoinType>(account: &signer)\n```\n\nIt publishes an empty `Balance<CoinType>` resource under `account`.\nSo if the resource already exists it should exit abnormally, and end normally the balance should be zero:\n\n```rust\nspec publish_balance {\n    let addr = signer::address_of(account);\n    aborts_if exists<Balance<CoinType>>(addr);\n\n    ensures exists<Balance<CoinType>>(addr);\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == 0;\n}\n```\n\n## Simplify redundant specifications with Schema\n\nCongratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.\nHowever, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.\n\nSchema is a means of building a specification by grouping properties.\nSemantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.\n\n### Eliminate simple repetitions\n\nAs a most obvious example, the spec blocks of `mint` and `deposit` are a little different except for the variable names (in terms, they are [alpha convertible](https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion)), and the overall structure can be said to be exactly the same.\nTo simplify them, let's create a Schema:\n\n```rust\nspec schema DepositSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\nThis Schema declares two typed variables, and some conditions about what those variables should satisfy.\nWhen other places want to use this Schema, use `include DepositSchema {addr: XX, amount: YY}` to import it.\nwhere `XX` and `YY` are expressions used to replace `addr` and `amount`.\nIf the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.\n\nWith the above Schema definition, we can now simplify the previous spec:\n\n```rust\nspec mint {\n  include DepositSchema<CoinType> {addr: mint_addr};\n}\n// ....\nspec deposit {\n    include DepositSchema<CoinType> {amount: check.value};\n}\n```\n\n### Practice\n\nIn addition to the above example, find another spec block (such as `publish_balance`), and split it into a Schema declaration and a spec block that uses the corresponding Schema.\nAs an exercise, the Schema you created might not be available in this code, so it doesn't feel like there's a benefit to it.\nBut if in the later development, there are other functions that call `publish_balance`, it will be more convenient.\n\n\n## Conclusion\n\nIn our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore \n\n* the tips and best practices; \n* a more complicated case study using the Move Prover; \n* the limitation of the current version of the Move Prover, and its future outlook; \n\nSo stay tuned!\n\nMore and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please [fill out our contact form](https://www.movebit.xyz/#contact). We’d be happy to help.\n\n## About Us\n\n[MoveBit](https://www.movebit.xyz/) is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. \n\n\n### References\n\n* [Move tutorial]( https://github.com/move-language/move/tree/main/language/documentation/tutorial/) by the Move team\n* [Starocin Move Prover tutorial]( https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/) by Xudong Wang","source":"_posts/move-prover-tutorial-part-1.md","raw":"---\ntitle: Verify Smart Contracts in Aptos with the Move Prover Pt.1\ndate: 2022-09-27 16:53:50\ntags: move prover, m\ndescription: It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts\nthumbnail: /img/icon.png\n---\n\n*Xudong Wang  & 0xyi* 09-14-2022\n\n\nIt has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?\n\nWe will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. \n\nFor this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.\n\n\n## What is the Move Prover\n\nFormal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.\nNow it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.\n\nSmart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.\n**Move Prover (MVP)** is designed to prevent bugs in smart contracts written in the Move language.\n\nIn Aptos ( and Starcoin/Sui ), Users can specify functional properties of smart contracts using the **Move Specification Language (MSL)**, and then use the Move Prover to automatically and statically inspect them.\n\nSimply put, there can be two components in a Move file:\n\n- Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.\n\n- The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.\n\nWhen we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.\n\n## Install Prover dependencies in Aptos\n\nBefore using the Move Prover, let's install some of its external dependencies.\nIt is assumed that you already have [installed Aptos CLI](https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli).\nMake sure you did \"Step 3\" and installed the dependencies of the Move Prover:\n\n```bash\n./scripts/dev_setup.sh -yp\n. ~/.profile\n```\n\nWhen the above command is executed, enter `boogie /version`, if the output is similar to \"Boogie program verifier version X.X.X\", then the installation has been successful.\n\nNote that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).\nWindows users can run it by installing [WSL](https://docs.microsoft.com/en-us/windows/wsl/install).\n\n## Prepare an example for verification in \n\n### Project creation\n\nFirst, let's create a new empty Move package:\n\n```bash\nmkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin\n```\n\nYou can see that its directory structure is as follows:\n\n```\nbasic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    `---- sources   (Directory)\n```\n\n### Module code\n\nNow create `basic_coin/sources/BasicCoin.move`.\n\n<details>\n<summary> BasicCoin.move content</summary>\n\n```rust\n/// This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin {\n    use std::error;\n    use std::signer;\n\n    /// Error codes\n    const ENOT_MODULE_OWNER: u64 = 0;\n    const EINSUFFICIENT_BALANCE: u64 = 1;\n    const EALREADY_HAS_BALANCE: u64 = 2;\n\n    struct Coin<phantom CoinType> has store {\n        value: u64\n    }\n\n    struct Balance<phantom CoinType> has key {\n        coin: Coin<CoinType>\n    }\n\n    /// Publish an empty balance resource under `account`'s address. This function must be called before\n    /// minting or transferring to the account.\n    public fun publish_balance<CoinType>(account: &signer) {\n        let empty_coin = Coin<CoinType> { value: 0 };\n        assert!(!exists<Balance<CoinType>>(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance<CoinType> { coin:  empty_coin });\n    }\n\n    /// Mint `amount` tokens to `mint_addr`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can decide the minting policy.\n    public fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance {\n        // Deposit `total_value` amount of tokens to mint_addr's balance\n        deposit(mint_addr, Coin<CoinType> { value: amount });\n    }\n\n    public fun balance_of<CoinType>(owner: address): u64 acquires Balance {\n        borrow_global<Balance<CoinType>>(owner).coin.value\n    }\n\n    /// Transfers `amount` of tokens from `from` to `to`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can  decide the transferring policy.\n    public fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance {\n        let addr_from = signer::address_of(from);\n        let check = withdraw<CoinType>(addr_from, amount);\n        deposit<CoinType>(to, check);\n    }\n\n    fun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance {\n        let balance = balance_of<CoinType>(addr);\n        assert!(balance >= amount, EINSUFFICIENT_BALANCE);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        *balance_ref = balance - amount;\n        Coin<CoinType> { value: amount }\n    }\n    \n    fun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance{\n        let balance = balance_of<CoinType>(addr);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        let Coin { value } = check;\n        *balance_ref = balance + value;\n    }\n}\n```\n\n</details>\n\nHere we assume that you have a certain grasp of the Move language, and can understand the source code of `BasicCoin.move` above and know the function of each part.\n\n### TOML configuration\n\nBasicCoin uses some facilities of the Aptos standard library, and also needs to add `aptos-framework` to the dependencies. We also need to specify what numerical address it should be replaced with. \n\nTherefore, we modify Move.toml as follows:\n\n```toml\n[package]\nname = \"BasicCoin\"\nversion = \"0.0.0\"\n\n[dependencies]\nAptosFramework = { git = \"https://github.com/aptos-labs/aptos-core.git\", subdir = \"aptos-move/framework/aptos-framework/\", rev = \"main\" }\n\n[addresses]\nBasicCoin=\"Replace_It_With_Your_Numerical_Address\"  \n\n```\n\n## The first verification code\n\nTo give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n}\n```\n\nSyntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the `balance_of` function in order to clearly see the correspondence between the definition and the specification when reading the code.\n\nSimply put, the `spec balance_of {...}` block will contain our **property specification** for the `balance_of` function.\nThere are many types of property specifications, some common examples are:\n\n- Will this function abort? Under what circumstances does it abort?\n- What conditions must be met for the parameters to call this function?\n- What is the return value of this function?\n- After the function is executed, how will the state of the virtual machine be changed?\n- What invariants does this function maintain?\n\nFor example, the Move Prover allows all possible aborts by default when we don't give any abort conditions.\nAnd in the simple snippet above, we tell Prover with the directive `aborts_if_is_strict`:\n\n> I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.\n\nNow, we run the `prove` command in the `basic_coin` directory:\n\n```bash\naptos move prove\n```\nit will call the Move Prover to check the code in the package.\nThen we can see the Prover reporting the following error message:\n\n```\nerror: abort not covered by any of the `aborts_if` clauses\n   ┌─ ./sources/BasicCoin.move:38:5\n   │\n35 │           borrow_global<Balance<CoinType>>(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of {\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     }\n   │ ╰─────^\n   │\n   =     at ./sources/BasicCoin.move:34: balance_of\n   =         owner = 0x29\n   =     at ./sources/BasicCoin.move:35: balance_of\n   =         ABORTED\n\nFAILURE proving 1 modules from package `basic_coin` in 1.794s\n{\n  \"Error\": \"Move Prover failed: exiting with verification errors\"\n}\n```\n\nProver's output tells us that it found a situation where the `balance_of` function aborts, but we don't explicitly point out the possibility of such aborts.\nLooking at the code that triggers the abort, we can see that the exception is caused by calling the built-in `borrow_global` function when the `owner` does not own a resource of type `Balance<CoinType>`.\nFollowing the guidance of the error message, we can add the following `aborts_if` condition:\n\n```rust\nspec balance_of {\n    pragma aborts_if_is_strict;\n    aborts_if !exists<Balance<CoinType>>(owner);\n}\n```\n\nAfter adding this condition, try calling Prover again and see that there are no more validation errors.\nNow we can confidently confirm that the `balance_of` function has one and only one possibility of abnormal termination, that is, the parameter `owner` does not own a resource of type `Balance<CoinType>`.\n\n## Verify withdraw function\n\nThe signature of the function `withdraw` is as follows:\n\n```rust\nfun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance\n```\n\nIts role is to withdraw the `amount` of coins from the address `addr` and return it.\n\n### Specify the abort condition for `withdraw`\n\nThere are two possibilities for `withdraw` to abort:\n\n1. No resource of type `Balance<CoinType>` in `addr`.\n2. The balance in `addr` is less than `amount`.\n\nFrom these, we can define the abort condition like this:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n}\n```\n\n- A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.\n`global<T>(addr): T` is a built-in function that returns a resource of type `T` at address `addr`.\nHere, we set balance to the number of tokens owned by addr via the let binding;\n- `exists<T>(address): bool` is a built-in function that returns true if resource `T` exists at address `addr`; otherwise returns false.\n\nThe two lines of `aborts_if` statements correspond to the two conditions mentioned above.\nIn general, if a function has multiple `aborts_if` conditions, the conditions are ORed together.\n\nAs mentioned earlier, if we don't specify any abort conditions, Prover will not impose any restrictions on aborts.\nBut once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction `pragma aborts_if_is_strict`.\nIf only some of the conditions for abnormal exit are listed, the Prover will report a validation error.\nHowever, if the `pragma aborts_if_is_partial` is defined in the spec block, this is equivalent to telling the Prover:\n\n> I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.\n\nIf you are interested, you can do such a set of experiments to verify:\n\n- When deleting any of the above two `aborts_if` conditions, Prover will report an error;\n- When all `aborts_if` conditions are deleted at the same time, Prover will not report an error;\n- When adding `pragma aborts_if_is_partial`, no matter how many `aborts_if` conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).\n\nSome readers may be curious about the order of the three statements in the spec block:\nWhy the definition of balance can be written after `aborts_if !exists<Balance<CoinType>>(addr)`.\nBecause, if the latter holds true, `balance` does not actually exist.\nWouldn't this order cause the Prover to fail?\nSimply put: no, the statements in the spec block are declarative and the order doesn't matter.\n\nFor a more detailed understanding, you can refer to the MSL documentation for more information.\n\n### Specify the functional nature of `withdraw`\n\nNext, we define functional properties.\nThe two `ensures` statements in the following spec block give us what we expect from the `withdraw` functionality:\n\n```rust\nspec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n    ensures result == Coin<CoinType> { value: amount };\n}\n```\n\nIn this code, first by using `let post` binding, define `balance_post` as the balance of `addr` after the function is executed, it should be equal to `balance - amount`. Then, `result` is a special name that represents the return value, which should be the `amount` of tokens.\n\n## Verify the `deposit` function\n\nThe signature of the function deposit is as follows:\n\n```rust\nfun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance\n```\n\nIt deposits the token funds indicated by `check` into the address `addr`. Its canonical definition is as follows:\n\n```rust\nspec deposit {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    let check_value = check.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + check_value > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + check_value;\n}\n```\n\nHere, `balance` is defined as the balance in `addr` before the function is executed, and `check_value` is defined as the amount of tokens to be deposited. It will abort in two cases:\n\n1. There is no resource of type `Balance<CoinType>` in `addr`;\n2. Or the sum of `balance` and `check_value` is greater than the maximum value of type `u64`.\n\nThe `ensures` statement is used to let the Prover make sure that in any case, the balance in `addr` can be updated correctly after the function is executed.\n\nThe syntax mentioned earlier will not be repeated here.\nAstute readers may have noticed that it is worth noting that the expression `balance + check_value > MAX_U64` is problematic in the Move program.\nBecause the addition on the left may cause an overflow exception.\nIf we want to write a similar check in the Move program, we should use an expression like `balance > MAX_U64 - check_value` to avoid the overflow problem.\n\nHowever, this expression is perfectly fine in the Move Specification Language (MSL).\nSince the spec block uses the MSL language, its type system is different from that of Move.\nIn MSL, all integers are of type `num`, which is an integer in the mathematical sense. That is, it is signed and has no size limit.\nAll built-in integer types (`u8`, `u64`, etc.) are automatically converted to type `num` when referencing data in a Move program in MSL.\nA more detailed description of the type system can be found in the MSL documentation.\n\n## Verify the `transfer` function\n\nThe signature of the function `transfer` is as follows:\n\n```rust\npublic fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for the transfer `from` the account from to the address `to`, and the transfer amount is `amount`.\n\nLet's ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:\n\n```rust\nspec transfer {\n    let addr_from = signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n```\n\nHere `from` is of type `signer`, not a direct address.\nAlthough in the program we have created a local variable called `addr_from`, we cannot directly reference it in the spec block.\nAt the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to `addr_from` again.\nThen use `let` and `let post` to define several variables, corresponding to the balances in the two addresses `addr_from` and `to` before and after the function is executed.\nFinally, use the `ensures` statement to tell Prover that the balance in `from` should be subtracted by `amount`; the balance in `to` should be increased by `amount`.\n\nAt first glance, there seems to be no problem at all. But is it really so?\nLet's see if Prover thinks this is \"the correct description of the behavior of this function\".\nAfter typing `aptos move prove` you can see:\n\n```\nerror: post-condition does not hold\n   ┌─ ./sources/BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post == balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   =     at ./sources/BasicCoin.move:45: transfer\n   =     at ./sources/BasicCoin.move:51: transfer (spec)\n   =     at ./sources/BasicCoin.move:53: transfer (spec)\n   =     at ./sources/BasicCoin.move:54: transfer (spec)\n   =     at ./sources/BasicCoin.move:45: transfer\n   =         from = signer{0x0}\n   =         to = 0x0\n   =         amount = 1\n   =         _witness = <generic>\n```\n\nIt is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the `transfer` function.\nWhy is this so? Let's look down again: the parameters that make the postconditions not satisfied are `from = signer{0x0}` and `to = 0x0`. We should know the reason: when the account transfers money to itself, both `to` and `from` point to the same address, so the balance does not change.\n\nThere are two solutions now:\n\n**Plan A** does not modify the function definition, but changes the specification.\nIn the spec block, consider whether the two accounts for the transfer and receiving are the same address.\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures (addr_from == to && eq_post) || (addr_from != to && ne_post);\n```\n\nOr use another slightly more intuitive if syntax:\n\n```rust\nlet post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures if (addr_from == to) eq_post else ne_post;\n```\n\nNote that `if (P) E1 else E2` is not the same as conditional execution in program logic -- it's actually a syntactic sugar equivalent to `ensures` both `P ==> E1` and `!P ==> E2`.\nAnd `p ==> q` is actually `!p || q`.\n\nThat is to say, the end of the second way of writing actually represents this logic:\n\n```rust\nensures (addr_from == to  ===>  eq_post) && (addr_from != to  ===> ne_post);\n```\n\nthat is:\n\n```rust\nensures (addr_from != to || eq_post) && (addr_from == to  || ne_post);\n```\n\nInterested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former `(addr_from == to && eq_post) || (addr_from != to && ne_post)` and the latter `(addr_from != to || eq_post) && (addr_from == to  || ne_post)` are actually exactly equivalent expressions.\n\n**Plan B** does not modify the spec, but directly adds `assert!(addr_from != to, EEQUAL_ADDR);` in the function body, and adds the definition of the error code `EEQUAL_ADDR` in front, so that the self-transfer transaction cannot be completed.\n\nObviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.\nSo plan B is a better practice.\nIt directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.\n\n### Practice\n\nCurrently, we have only completed functional verification of the `transfer` function.\nBut it doesn't say under what circumstances it will abort.\nAs an exercise, give it an appropriate `aborts_if` condition. The answer can be found in our next article.\n\n## Verify mint function\n\nThe signature of the function `mint` is as follows:\n\n```rust\npublic fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance\n```\n\nIt is responsible for minting the `amount` of tokens and depositing them in the address `mint_addr`.\nMore interesting is `_witness`, which is of type `CoinType`.\nBecause only the module that defines the `CoinType` can construct a value of this type, this guarantees the identity of the caller.\n\nThere is actually only one call to `deposit` in the `mint` function.\nIt is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:\n\n```rust\nspec mint {\n    let balance = global<Balance<CoinType>>(mint_addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(mint_addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(mint_addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\n## Verify the `publish_balance` function\n\nThe signature of the function `publish_balance` is as follows:\n\n```rust\npublic fun publish_balance<CoinType>(account: &signer)\n```\n\nIt publishes an empty `Balance<CoinType>` resource under `account`.\nSo if the resource already exists it should exit abnormally, and end normally the balance should be zero:\n\n```rust\nspec publish_balance {\n    let addr = signer::address_of(account);\n    aborts_if exists<Balance<CoinType>>(addr);\n\n    ensures exists<Balance<CoinType>>(addr);\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == 0;\n}\n```\n\n## Simplify redundant specifications with Schema\n\nCongratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.\nHowever, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.\n\nSchema is a means of building a specification by grouping properties.\nSemantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.\n\n### Eliminate simple repetitions\n\nAs a most obvious example, the spec blocks of `mint` and `deposit` are a little different except for the variable names (in terms, they are [alpha convertible](https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion)), and the overall structure can be said to be exactly the same.\nTo simplify them, let's create a Schema:\n\n```rust\nspec schema DepositSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n```\n\nThis Schema declares two typed variables, and some conditions about what those variables should satisfy.\nWhen other places want to use this Schema, use `include DepositSchema {addr: XX, amount: YY}` to import it.\nwhere `XX` and `YY` are expressions used to replace `addr` and `amount`.\nIf the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.\n\nWith the above Schema definition, we can now simplify the previous spec:\n\n```rust\nspec mint {\n  include DepositSchema<CoinType> {addr: mint_addr};\n}\n// ....\nspec deposit {\n    include DepositSchema<CoinType> {amount: check.value};\n}\n```\n\n### Practice\n\nIn addition to the above example, find another spec block (such as `publish_balance`), and split it into a Schema declaration and a spec block that uses the corresponding Schema.\nAs an exercise, the Schema you created might not be available in this code, so it doesn't feel like there's a benefit to it.\nBut if in the later development, there are other functions that call `publish_balance`, it will be more convenient.\n\n\n## Conclusion\n\nIn our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore \n\n* the tips and best practices; \n* a more complicated case study using the Move Prover; \n* the limitation of the current version of the Move Prover, and its future outlook; \n\nSo stay tuned!\n\nMore and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please [fill out our contact form](https://www.movebit.xyz/#contact). We’d be happy to help.\n\n## About Us\n\n[MoveBit](https://www.movebit.xyz/) is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. \n\n\n### References\n\n* [Move tutorial]( https://github.com/move-language/move/tree/main/language/documentation/tutorial/) by the Move team\n* [Starocin Move Prover tutorial]( https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/) by Xudong Wang","slug":"move-prover-tutorial-part-1","published":1,"updated":"2022-12-05T09:52:03.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbbmsdze00016b7l1vg0hzdm","content":"<p><em>Xudong Wang  &amp; 0xyi</em> 09-14-2022</p>\n<p>It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?</p>\n<p>We will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. </p>\n<p>For this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.</p>\n<h2 id=\"What-is-the-Move-Prover\"><a href=\"#What-is-the-Move-Prover\" class=\"headerlink\" title=\"What is the Move Prover\"></a>What is the Move Prover</h2><p>Formal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.<br>Now it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.</p>\n<p>Smart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.<br><strong>Move Prover (MVP)</strong> is designed to prevent bugs in smart contracts written in the Move language.</p>\n<p>In Aptos ( and Starcoin&#x2F;Sui ), Users can specify functional properties of smart contracts using the <strong>Move Specification Language (MSL)</strong>, and then use the Move Prover to automatically and statically inspect them.</p>\n<p>Simply put, there can be two components in a Move file:</p>\n<ul>\n<li><p>Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.</p>\n</li>\n<li><p>The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.</p>\n</li>\n</ul>\n<p>When we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.</p>\n<h2 id=\"Install-Prover-dependencies-in-Aptos\"><a href=\"#Install-Prover-dependencies-in-Aptos\" class=\"headerlink\" title=\"Install Prover dependencies in Aptos\"></a>Install Prover dependencies in Aptos</h2><p>Before using the Move Prover, let’s install some of its external dependencies.<br>It is assumed that you already have <a href=\"https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli\">installed Aptos CLI</a>.<br>Make sure you did “Step 3” and installed the dependencies of the Move Prover:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;scripts&#x2F;dev_setup.sh -yp\n. ~&#x2F;.profile</code></pre>\n\n<p>When the above command is executed, enter <code>boogie /version</code>, if the output is similar to “Boogie program verifier version X.X.X”, then the installation has been successful.</p>\n<p>Note that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).<br>Windows users can run it by installing <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install\">WSL</a>.</p>\n<h2 id=\"Prepare-an-example-for-verification-in\"><a href=\"#Prepare-an-example-for-verification-in\" class=\"headerlink\" title=\"Prepare an example for verification in\"></a>Prepare an example for verification in</h2><h3 id=\"Project-creation\"><a href=\"#Project-creation\" class=\"headerlink\" title=\"Project creation\"></a>Project creation</h3><p>First, let’s create a new empty Move package:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin</code></pre>\n\n<p>You can see that its directory structure is as follows:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">basic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    &#96;---- sources   (Directory)</code></pre>\n\n<h3 id=\"Module-code\"><a href=\"#Module-code\" class=\"headerlink\" title=\"Module code\"></a>Module code</h3><p>Now create <code>basic_coin/sources/BasicCoin.move</code>.</p>\n<details>\n<summary> BasicCoin.move content</summary>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;&#x2F; This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin &#123;\n    use std::error;\n    use std::signer;\n\n    &#x2F;&#x2F;&#x2F; Error codes\n    const ENOT_MODULE_OWNER: u64 &#x3D; 0;\n    const EINSUFFICIENT_BALANCE: u64 &#x3D; 1;\n    const EALREADY_HAS_BALANCE: u64 &#x3D; 2;\n\n    struct Coin&lt;phantom CoinType&gt; has store &#123;\n        value: u64\n    &#125;\n\n    struct Balance&lt;phantom CoinType&gt; has key &#123;\n        coin: Coin&lt;CoinType&gt;\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Publish an empty balance resource under &#96;account&#96;&#39;s address. This function must be called before\n    &#x2F;&#x2F;&#x2F; minting or transferring to the account.\n    public fun publish_balance&lt;CoinType&gt;(account: &amp;signer) &#123;\n        let empty_coin &#x3D; Coin&lt;CoinType&gt; &#123; value: 0 &#125;;\n        assert!(!exists&lt;Balance&lt;CoinType&gt;&gt;(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance&lt;CoinType&gt; &#123; coin:  empty_coin &#125;);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Mint &#96;amount&#96; tokens to &#96;mint_addr&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can decide the minting policy.\n    public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        &#x2F;&#x2F; Deposit &#96;total_value&#96; amount of tokens to mint_addr&#39;s balance\n        deposit(mint_addr, Coin&lt;CoinType&gt; &#123; value: amount &#125;);\n    &#125;\n\n    public fun balance_of&lt;CoinType&gt;(owner: address): u64 acquires Balance &#123;\n        borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Transfers &#96;amount&#96; of tokens from &#96;from&#96; to &#96;to&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can  decide the transferring policy.\n    public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        let addr_from &#x3D; signer::address_of(from);\n        let check &#x3D; withdraw&lt;CoinType&gt;(addr_from, amount);\n        deposit&lt;CoinType&gt;(to, check);\n    &#125;\n\n    fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance &#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        assert!(balance &gt;&#x3D; amount, EINSUFFICIENT_BALANCE);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        *balance_ref &#x3D; balance - amount;\n        Coin&lt;CoinType&gt; &#123; value: amount &#125;\n    &#125;\n    \n    fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance&#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        let Coin &#123; value &#125; &#x3D; check;\n        *balance_ref &#x3D; balance + value;\n    &#125;\n&#125;</code></pre>\n\n</details>\n\n<p>Here we assume that you have a certain grasp of the Move language, and can understand the source code of <code>BasicCoin.move</code> above and know the function of each part.</p>\n<h3 id=\"TOML-configuration\"><a href=\"#TOML-configuration\" class=\"headerlink\" title=\"TOML configuration\"></a>TOML configuration</h3><p>BasicCoin uses some facilities of the Aptos standard library, and also needs to add <code>aptos-framework</code> to the dependencies. We also need to specify what numerical address it should be replaced with. </p>\n<p>Therefore, we modify Move.toml as follows:</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\">[package]\nname &#x3D; &quot;BasicCoin&quot;\nversion &#x3D; &quot;0.0.0&quot;\n\n[dependencies]\nAptosFramework &#x3D; &#123; git &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;aptos-labs&#x2F;aptos-core.git&quot;, subdir &#x3D; &quot;aptos-move&#x2F;framework&#x2F;aptos-framework&#x2F;&quot;, rev &#x3D; &quot;main&quot; &#125;\n\n[addresses]\nBasicCoin&#x3D;&quot;Replace_It_With_Your_Numerical_Address&quot;  \n</code></pre>\n\n<h2 id=\"The-first-verification-code\"><a href=\"#The-first-verification-code\" class=\"headerlink\" title=\"The first verification code\"></a>The first verification code</h2><p>To give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n&#125;</code></pre>\n\n<p>Syntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the <code>balance_of</code> function in order to clearly see the correspondence between the definition and the specification when reading the code.</p>\n<p>Simply put, the <code>spec balance_of &#123;...&#125;</code> block will contain our <strong>property specification</strong> for the <code>balance_of</code> function.<br>There are many types of property specifications, some common examples are:</p>\n<ul>\n<li>Will this function abort? Under what circumstances does it abort?</li>\n<li>What conditions must be met for the parameters to call this function?</li>\n<li>What is the return value of this function?</li>\n<li>After the function is executed, how will the state of the virtual machine be changed?</li>\n<li>What invariants does this function maintain?</li>\n</ul>\n<p>For example, the Move Prover allows all possible aborts by default when we don’t give any abort conditions.<br>And in the simple snippet above, we tell Prover with the directive <code>aborts_if_is_strict</code>:</p>\n<blockquote>\n<p>I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.</p>\n</blockquote>\n<p>Now, we run the <code>prove</code> command in the <code>basic_coin</code> directory:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">aptos move prove</code></pre>\n<p>it will call the Move Prover to check the code in the package.<br>Then we can see the Prover reporting the following error message:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: abort not covered by any of the &#96;aborts_if&#96; clauses\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:38:5\n   │\n35 │           borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of &#123;\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     &#125;\n   │ ╰─────^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:34: balance_of\n   &#x3D;         owner &#x3D; 0x29\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:35: balance_of\n   &#x3D;         ABORTED\n\nFAILURE proving 1 modules from package &#96;basic_coin&#96; in 1.794s\n&#123;\n  &quot;Error&quot;: &quot;Move Prover failed: exiting with verification errors&quot;\n&#125;</code></pre>\n\n<p>Prover’s output tells us that it found a situation where the <code>balance_of</code> function aborts, but we don’t explicitly point out the possibility of such aborts.<br>Looking at the code that triggers the abort, we can see that the exception is caused by calling the built-in <code>borrow_global</code> function when the <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.<br>Following the guidance of the error message, we can add the following <code>aborts_if</code> condition:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(owner);\n&#125;</code></pre>\n\n<p>After adding this condition, try calling Prover again and see that there are no more validation errors.<br>Now we can confidently confirm that the <code>balance_of</code> function has one and only one possibility of abnormal termination, that is, the parameter <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.</p>\n<h2 id=\"Verify-withdraw-function\"><a href=\"#Verify-withdraw-function\" class=\"headerlink\" title=\"Verify withdraw function\"></a>Verify withdraw function</h2><p>The signature of the function <code>withdraw</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance</code></pre>\n\n<p>Its role is to withdraw the <code>amount</code> of coins from the address <code>addr</code> and return it.</p>\n<h3 id=\"Specify-the-abort-condition-for-withdraw\"><a href=\"#Specify-the-abort-condition-for-withdraw\" class=\"headerlink\" title=\"Specify the abort condition for withdraw\"></a>Specify the abort condition for <code>withdraw</code></h3><p>There are two possibilities for <code>withdraw</code> to abort:</p>\n<ol>\n<li>No resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>.</li>\n<li>The balance in <code>addr</code> is less than <code>amount</code>.</li>\n</ol>\n<p>From these, we can define the abort condition like this:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n&#125;</code></pre>\n\n<ul>\n<li>A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.<br><code>global&lt;T&gt;(addr): T</code> is a built-in function that returns a resource of type <code>T</code> at address <code>addr</code>.<br>Here, we set balance to the number of tokens owned by addr via the let binding;</li>\n<li><code>exists&lt;T&gt;(address): bool</code> is a built-in function that returns true if resource <code>T</code> exists at address <code>addr</code>; otherwise returns false.</li>\n</ul>\n<p>The two lines of <code>aborts_if</code> statements correspond to the two conditions mentioned above.<br>In general, if a function has multiple <code>aborts_if</code> conditions, the conditions are ORed together.</p>\n<p>As mentioned earlier, if we don’t specify any abort conditions, Prover will not impose any restrictions on aborts.<br>But once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction <code>pragma aborts_if_is_strict</code>.<br>If only some of the conditions for abnormal exit are listed, the Prover will report a validation error.<br>However, if the <code>pragma aborts_if_is_partial</code> is defined in the spec block, this is equivalent to telling the Prover:</p>\n<blockquote>\n<p>I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.</p>\n</blockquote>\n<p>If you are interested, you can do such a set of experiments to verify:</p>\n<ul>\n<li>When deleting any of the above two <code>aborts_if</code> conditions, Prover will report an error;</li>\n<li>When all <code>aborts_if</code> conditions are deleted at the same time, Prover will not report an error;</li>\n<li>When adding <code>pragma aborts_if_is_partial</code>, no matter how many <code>aborts_if</code> conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).</li>\n</ul>\n<p>Some readers may be curious about the order of the three statements in the spec block:<br>Why the definition of balance can be written after <code>aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr)</code>.<br>Because, if the latter holds true, <code>balance</code> does not actually exist.<br>Wouldn’t this order cause the Prover to fail?<br>Simply put: no, the statements in the spec block are declarative and the order doesn’t matter.</p>\n<p>For a more detailed understanding, you can refer to the MSL documentation for more information.</p>\n<h3 id=\"Specify-the-functional-nature-of-withdraw\"><a href=\"#Specify-the-functional-nature-of-withdraw\" class=\"headerlink\" title=\"Specify the functional nature of withdraw\"></a>Specify the functional nature of <code>withdraw</code></h3><p>Next, we define functional properties.<br>The two <code>ensures</code> statements in the following spec block give us what we expect from the <code>withdraw</code> functionality:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance - amount;\n    ensures result &#x3D;&#x3D; Coin&lt;CoinType&gt; &#123; value: amount &#125;;\n&#125;</code></pre>\n\n<p>In this code, first by using <code>let post</code> binding, define <code>balance_post</code> as the balance of <code>addr</code> after the function is executed, it should be equal to <code>balance - amount</code>. Then, <code>result</code> is a special name that represents the return value, which should be the <code>amount</code> of tokens.</p>\n<h2 id=\"Verify-the-deposit-function\"><a href=\"#Verify-the-deposit-function\" class=\"headerlink\" title=\"Verify the deposit function\"></a>Verify the <code>deposit</code> function</h2><p>The signature of the function deposit is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance</code></pre>\n\n<p>It deposits the token funds indicated by <code>check</code> into the address <code>addr</code>. Its canonical definition is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec deposit &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    let check_value &#x3D; check.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + check_value &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + check_value;\n&#125;</code></pre>\n\n<p>Here, <code>balance</code> is defined as the balance in <code>addr</code> before the function is executed, and <code>check_value</code> is defined as the amount of tokens to be deposited. It will abort in two cases:</p>\n<ol>\n<li>There is no resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>;</li>\n<li>Or the sum of <code>balance</code> and <code>check_value</code> is greater than the maximum value of type <code>u64</code>.</li>\n</ol>\n<p>The <code>ensures</code> statement is used to let the Prover make sure that in any case, the balance in <code>addr</code> can be updated correctly after the function is executed.</p>\n<p>The syntax mentioned earlier will not be repeated here.<br>Astute readers may have noticed that it is worth noting that the expression <code>balance + check_value &gt; MAX_U64</code> is problematic in the Move program.<br>Because the addition on the left may cause an overflow exception.<br>If we want to write a similar check in the Move program, we should use an expression like <code>balance &gt; MAX_U64 - check_value</code> to avoid the overflow problem.</p>\n<p>However, this expression is perfectly fine in the Move Specification Language (MSL).<br>Since the spec block uses the MSL language, its type system is different from that of Move.<br>In MSL, all integers are of type <code>num</code>, which is an integer in the mathematical sense. That is, it is signed and has no size limit.<br>All built-in integer types (<code>u8</code>, <code>u64</code>, etc.) are automatically converted to type <code>num</code> when referencing data in a Move program in MSL.<br>A more detailed description of the type system can be found in the MSL documentation.</p>\n<h2 id=\"Verify-the-transfer-function\"><a href=\"#Verify-the-transfer-function\" class=\"headerlink\" title=\"Verify the transfer function\"></a>Verify the <code>transfer</code> function</h2><p>The signature of the function <code>transfer</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for the transfer <code>from</code> the account from to the address <code>to</code>, and the transfer amount is <code>amount</code>.</p>\n<p>Let’s ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec transfer &#123;\n    let addr_from &#x3D; signer::address_of(from);\n\n    let balance_from &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let balance_to &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n    let post balance_from_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let post balance_to_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n\n    ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n    ensures balance_to_post &#x3D;&#x3D; balance_to + amount;\n&#125;</code></pre>\n\n<p>Here <code>from</code> is of type <code>signer</code>, not a direct address.<br>Although in the program we have created a local variable called <code>addr_from</code>, we cannot directly reference it in the spec block.<br>At the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to <code>addr_from</code> again.<br>Then use <code>let</code> and <code>let post</code> to define several variables, corresponding to the balances in the two addresses <code>addr_from</code> and <code>to</code> before and after the function is executed.<br>Finally, use the <code>ensures</code> statement to tell Prover that the balance in <code>from</code> should be subtracted by <code>amount</code>; the balance in <code>to</code> should be increased by <code>amount</code>.</p>\n<p>At first glance, there seems to be no problem at all. But is it really so?<br>Let’s see if Prover thinks this is “the correct description of the behavior of this function”.<br>After typing <code>aptos move prove</code> you can see:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: post-condition does not hold\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:51: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:53: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:54: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;         from &#x3D; signer&#123;0x0&#125;\n   &#x3D;         to &#x3D; 0x0\n   &#x3D;         amount &#x3D; 1\n   &#x3D;         _witness &#x3D; &lt;generic&gt;</code></pre>\n\n<p>It is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the <code>transfer</code> function.<br>Why is this so? Let’s look down again: the parameters that make the postconditions not satisfied are <code>from = signer&#123;0x0&#125;</code> and <code>to = 0x0</code>. We should know the reason: when the account transfers money to itself, both <code>to</code> and <code>from</code> point to the same address, so the balance does not change.</p>\n<p>There are two solutions now:</p>\n<p><strong>Plan A</strong> does not modify the function definition, but changes the specification.<br>In the spec block, consider whether the two accounts for the transfer and receiving are the same address.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures (addr_from &#x3D;&#x3D; to &amp;&amp; eq_post) || (addr_from !&#x3D; to &amp;&amp; ne_post);</code></pre>\n\n<p>Or use another slightly more intuitive if syntax:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures if (addr_from &#x3D;&#x3D; to) eq_post else ne_post;</code></pre>\n\n<p>Note that <code>if (P) E1 else E2</code> is not the same as conditional execution in program logic – it’s actually a syntactic sugar equivalent to <code>ensures</code> both <code>P ==&gt; E1</code> and <code>!P ==&gt; E2</code>.<br>And <code>p ==&gt; q</code> is actually <code>!p || q</code>.</p>\n<p>That is to say, the end of the second way of writing actually represents this logic:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from &#x3D;&#x3D; to  &#x3D;&#x3D;&#x3D;&gt;  eq_post) &amp;&amp; (addr_from !&#x3D; to  &#x3D;&#x3D;&#x3D;&gt; ne_post);</code></pre>\n\n<p>that is:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from !&#x3D; to || eq_post) &amp;&amp; (addr_from &#x3D;&#x3D; to  || ne_post);</code></pre>\n\n<p>Interested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former <code>(addr_from == to &amp;&amp; eq_post) || (addr_from != to &amp;&amp; ne_post)</code> and the latter <code>(addr_from != to || eq_post) &amp;&amp; (addr_from == to  || ne_post)</code> are actually exactly equivalent expressions.</p>\n<p><strong>Plan B</strong> does not modify the spec, but directly adds <code>assert!(addr_from != to, EEQUAL_ADDR);</code> in the function body, and adds the definition of the error code <code>EEQUAL_ADDR</code> in front, so that the self-transfer transaction cannot be completed.</p>\n<p>Obviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.<br>So plan B is a better practice.<br>It directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.</p>\n<h3 id=\"Practice\"><a href=\"#Practice\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>Currently, we have only completed functional verification of the <code>transfer</code> function.<br>But it doesn’t say under what circumstances it will abort.<br>As an exercise, give it an appropriate <code>aborts_if</code> condition. The answer can be found in our next article.</p>\n<h2 id=\"Verify-mint-function\"><a href=\"#Verify-mint-function\" class=\"headerlink\" title=\"Verify mint function\"></a>Verify mint function</h2><p>The signature of the function <code>mint</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for minting the <code>amount</code> of tokens and depositing them in the address <code>mint_addr</code>.<br>More interesting is <code>_witness</code>, which is of type <code>CoinType</code>.<br>Because only the module that defines the <code>CoinType</code> can construct a value of this type, this guarantees the identity of the caller.</p>\n<p>There is actually only one call to <code>deposit</code> in the <code>mint</code> function.<br>It is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(mint_addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<h2 id=\"Verify-the-publish-balance-function\"><a href=\"#Verify-the-publish-balance-function\" class=\"headerlink\" title=\"Verify the publish_balance function\"></a>Verify the <code>publish_balance</code> function</h2><p>The signature of the function <code>publish_balance</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun publish_balance&lt;CoinType&gt;(account: &amp;signer)</code></pre>\n\n<p>It publishes an empty <code>Balance&lt;CoinType&gt;</code> resource under <code>account</code>.<br>So if the resource already exists it should exit abnormally, and end normally the balance should be zero:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec publish_balance &#123;\n    let addr &#x3D; signer::address_of(account);\n    aborts_if exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n\n    ensures exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; 0;\n&#125;</code></pre>\n\n<h2 id=\"Simplify-redundant-specifications-with-Schema\"><a href=\"#Simplify-redundant-specifications-with-Schema\" class=\"headerlink\" title=\"Simplify redundant specifications with Schema\"></a>Simplify redundant specifications with Schema</h2><p>Congratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.<br>However, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.</p>\n<p>Schema is a means of building a specification by grouping properties.<br>Semantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.</p>\n<h3 id=\"Eliminate-simple-repetitions\"><a href=\"#Eliminate-simple-repetitions\" class=\"headerlink\" title=\"Eliminate simple repetitions\"></a>Eliminate simple repetitions</h3><p>As a most obvious example, the spec blocks of <code>mint</code> and <code>deposit</code> are a little different except for the variable names (in terms, they are <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion\">alpha convertible</a>), and the overall structure can be said to be exactly the same.<br>To simplify them, let’s create a Schema:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec schema DepositSchema&lt;CoinType&gt; &#123;\n    addr: address;\n    amount: u64;\n\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<p>This Schema declares two typed variables, and some conditions about what those variables should satisfy.<br>When other places want to use this Schema, use <code>include DepositSchema &#123;addr: XX, amount: YY&#125;</code> to import it.<br>where <code>XX</code> and <code>YY</code> are expressions used to replace <code>addr</code> and <code>amount</code>.<br>If the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.</p>\n<p>With the above Schema definition, we can now simplify the previous spec:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n  include DepositSchema&lt;CoinType&gt; &#123;addr: mint_addr&#125;;\n&#125;\n&#x2F;&#x2F; ....\nspec deposit &#123;\n    include DepositSchema&lt;CoinType&gt; &#123;amount: check.value&#125;;\n&#125;</code></pre>\n\n<h3 id=\"Practice-1\"><a href=\"#Practice-1\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>In addition to the above example, find another spec block (such as <code>publish_balance</code>), and split it into a Schema declaration and a spec block that uses the corresponding Schema.<br>As an exercise, the Schema you created might not be available in this code, so it doesn’t feel like there’s a benefit to it.<br>But if in the later development, there are other functions that call <code>publish_balance</code>, it will be more convenient.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>In our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore </p>\n<ul>\n<li>the tips and best practices; </li>\n<li>a more complicated case study using the Move Prover; </li>\n<li>the limitation of the current version of the Move Prover, and its future outlook;</li>\n</ul>\n<p>So stay tuned!</p>\n<p>More and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please <a href=\"https://www.movebit.xyz/#contact\">fill out our contact form</a>. We’d be happy to help.</p>\n<h2 id=\"About-Us\"><a href=\"#About-Us\" class=\"headerlink\" title=\"About Us\"></a>About Us</h2><p><a href=\"https://www.movebit.xyz/\">MoveBit</a> is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. </p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><a href=\"https://github.com/move-language/move/tree/main/language/documentation/tutorial/\">Move tutorial</a> by the Move team</li>\n<li><a href=\"https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/\">Starocin Move Prover tutorial</a> by Xudong Wang</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><em>Xudong Wang  &amp; 0xyi</em> 09-14-2022</p>\n<p>It has been widely acclaimed that the Move Prover makes it very simple to formally verify Move contracts, offering very strong safety guarantees.  How does it work? Does it provide the ultimate safety guarantee for smart contracts?</p>\n<p>We will write an article series on how to verify smart contracts with the Move Prover in Aptos, what are the tips and best practices, a more complicated case study using the Move Prover, and what are the current limitation and its future outlook. </p>\n<p>For this part, we will first give a tutorial on how to verify smart contracts with the Move Prover in Aptos.</p>\n<h2 id=\"What-is-the-Move-Prover\"><a href=\"#What-is-the-Move-Prover\" class=\"headerlink\" title=\"What is the Move Prover\"></a>What is the Move Prover</h2><p>Formal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.<br>Now it has certain applications in the fields of operating systems, compilers, and other fields that require high correctness.</p>\n<p>Smart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.<br><strong>Move Prover (MVP)</strong> is designed to prevent bugs in smart contracts written in the Move language.</p>\n<p>In Aptos ( and Starcoin&#x2F;Sui ), Users can specify functional properties of smart contracts using the <strong>Move Specification Language (MSL)</strong>, and then use the Move Prover to automatically and statically inspect them.</p>\n<p>Simply put, there can be two components in a Move file:</p>\n<ul>\n<li><p>Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, and functions.</p>\n</li>\n<li><p>The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function.</p>\n</li>\n</ul>\n<p>When we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and giving other users confidence in the properties of the program that has been verified.</p>\n<h2 id=\"Install-Prover-dependencies-in-Aptos\"><a href=\"#Install-Prover-dependencies-in-Aptos\" class=\"headerlink\" title=\"Install Prover dependencies in Aptos\"></a>Install Prover dependencies in Aptos</h2><p>Before using the Move Prover, let’s install some of its external dependencies.<br>It is assumed that you already have <a href=\"https://aptos.dev/cli-tools/aptos-cli-tool/install-aptos-cli\">installed Aptos CLI</a>.<br>Make sure you did “Step 3” and installed the dependencies of the Move Prover:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;scripts&#x2F;dev_setup.sh -yp\n. ~&#x2F;.profile</code></pre>\n\n<p>When the above command is executed, enter <code>boogie /version</code>, if the output is similar to “Boogie program verifier version X.X.X”, then the installation has been successful.</p>\n<p>Note that currently the Move Prover can only run under UNIX-based operating systems (such as Linux, and macOS).<br>Windows users can run it by installing <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install\">WSL</a>.</p>\n<h2 id=\"Prepare-an-example-for-verification-in\"><a href=\"#Prepare-an-example-for-verification-in\" class=\"headerlink\" title=\"Prepare an example for verification in\"></a>Prepare an example for verification in</h2><h3 id=\"Project-creation\"><a href=\"#Project-creation\" class=\"headerlink\" title=\"Project creation\"></a>Project creation</h3><p>First, let’s create a new empty Move package:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir basic_coin\ncd basic_coin\naptos move init --name BasicCoin</code></pre>\n\n<p>You can see that its directory structure is as follows:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">basic_coin\n    |\n    |---- Move.toml (text file)\n    |\n    &#96;---- sources   (Directory)</code></pre>\n\n<h3 id=\"Module-code\"><a href=\"#Module-code\" class=\"headerlink\" title=\"Module code\"></a>Module code</h3><p>Now create <code>basic_coin/sources/BasicCoin.move</code>.</p>\n<details>\n<summary> BasicCoin.move content</summary>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F;&#x2F; This module defines a minimal and generic Coin and Balance.\nmodule BasicCoin::basic_coin &#123;\n    use std::error;\n    use std::signer;\n\n    &#x2F;&#x2F;&#x2F; Error codes\n    const ENOT_MODULE_OWNER: u64 &#x3D; 0;\n    const EINSUFFICIENT_BALANCE: u64 &#x3D; 1;\n    const EALREADY_HAS_BALANCE: u64 &#x3D; 2;\n\n    struct Coin&lt;phantom CoinType&gt; has store &#123;\n        value: u64\n    &#125;\n\n    struct Balance&lt;phantom CoinType&gt; has key &#123;\n        coin: Coin&lt;CoinType&gt;\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Publish an empty balance resource under &#96;account&#96;&#39;s address. This function must be called before\n    &#x2F;&#x2F;&#x2F; minting or transferring to the account.\n    public fun publish_balance&lt;CoinType&gt;(account: &amp;signer) &#123;\n        let empty_coin &#x3D; Coin&lt;CoinType&gt; &#123; value: 0 &#125;;\n        assert!(!exists&lt;Balance&lt;CoinType&gt;&gt;(signer::address_of(account)), error::already_exists(EALREADY_HAS_BALANCE));\n        move_to(account, Balance&lt;CoinType&gt; &#123; coin:  empty_coin &#125;);\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Mint &#96;amount&#96; tokens to &#96;mint_addr&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can decide the minting policy.\n    public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        &#x2F;&#x2F; Deposit &#96;total_value&#96; amount of tokens to mint_addr&#39;s balance\n        deposit(mint_addr, Coin&lt;CoinType&gt; &#123; value: amount &#125;);\n    &#125;\n\n    public fun balance_of&lt;CoinType&gt;(owner: address): u64 acquires Balance &#123;\n        borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n    &#125;\n\n    &#x2F;&#x2F;&#x2F; Transfers &#96;amount&#96; of tokens from &#96;from&#96; to &#96;to&#96;. This method requires a witness with &#96;CoinType&#96; so that the\n    &#x2F;&#x2F;&#x2F; module that owns &#96;CoinType&#96; can  decide the transferring policy.\n    public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance &#123;\n        let addr_from &#x3D; signer::address_of(from);\n        let check &#x3D; withdraw&lt;CoinType&gt;(addr_from, amount);\n        deposit&lt;CoinType&gt;(to, check);\n    &#125;\n\n    fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance &#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        assert!(balance &gt;&#x3D; amount, EINSUFFICIENT_BALANCE);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        *balance_ref &#x3D; balance - amount;\n        Coin&lt;CoinType&gt; &#123; value: amount &#125;\n    &#125;\n    \n    fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance&#123;\n        let balance &#x3D; balance_of&lt;CoinType&gt;(addr);\n        let balance_ref &#x3D; &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n        let Coin &#123; value &#125; &#x3D; check;\n        *balance_ref &#x3D; balance + value;\n    &#125;\n&#125;</code></pre>\n\n</details>\n\n<p>Here we assume that you have a certain grasp of the Move language, and can understand the source code of <code>BasicCoin.move</code> above and know the function of each part.</p>\n<h3 id=\"TOML-configuration\"><a href=\"#TOML-configuration\" class=\"headerlink\" title=\"TOML configuration\"></a>TOML configuration</h3><p>BasicCoin uses some facilities of the Aptos standard library, and also needs to add <code>aptos-framework</code> to the dependencies. We also need to specify what numerical address it should be replaced with. </p>\n<p>Therefore, we modify Move.toml as follows:</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\">[package]\nname &#x3D; &quot;BasicCoin&quot;\nversion &#x3D; &quot;0.0.0&quot;\n\n[dependencies]\nAptosFramework &#x3D; &#123; git &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;aptos-labs&#x2F;aptos-core.git&quot;, subdir &#x3D; &quot;aptos-move&#x2F;framework&#x2F;aptos-framework&#x2F;&quot;, rev &#x3D; &quot;main&quot; &#125;\n\n[addresses]\nBasicCoin&#x3D;&quot;Replace_It_With_Your_Numerical_Address&quot;  \n</code></pre>\n\n<h2 id=\"The-first-verification-code\"><a href=\"#The-first-verification-code\" class=\"headerlink\" title=\"The first verification code\"></a>The first verification code</h2><p>To give us a first impression of the use of the Move Prover, add the following code snippet to BasicCoin.move:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n&#125;</code></pre>\n\n<p>Syntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the <code>balance_of</code> function in order to clearly see the correspondence between the definition and the specification when reading the code.</p>\n<p>Simply put, the <code>spec balance_of &#123;...&#125;</code> block will contain our <strong>property specification</strong> for the <code>balance_of</code> function.<br>There are many types of property specifications, some common examples are:</p>\n<ul>\n<li>Will this function abort? Under what circumstances does it abort?</li>\n<li>What conditions must be met for the parameters to call this function?</li>\n<li>What is the return value of this function?</li>\n<li>After the function is executed, how will the state of the virtual machine be changed?</li>\n<li>What invariants does this function maintain?</li>\n</ul>\n<p>For example, the Move Prover allows all possible aborts by default when we don’t give any abort conditions.<br>And in the simple snippet above, we tell Prover with the directive <code>aborts_if_is_strict</code>:</p>\n<blockquote>\n<p>I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.</p>\n</blockquote>\n<p>Now, we run the <code>prove</code> command in the <code>basic_coin</code> directory:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">aptos move prove</code></pre>\n<p>it will call the Move Prover to check the code in the package.<br>Then we can see the Prover reporting the following error message:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: abort not covered by any of the &#96;aborts_if&#96; clauses\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:38:5\n   │\n35 │           borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value\n   │           ------------- abort happened here with execution failure\n   ·\n38 │ ╭     spec balance_of &#123;\n39 │ │       pragma aborts_if_is_strict;\n40 │ │     &#125;\n   │ ╰─────^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:34: balance_of\n   &#x3D;         owner &#x3D; 0x29\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:35: balance_of\n   &#x3D;         ABORTED\n\nFAILURE proving 1 modules from package &#96;basic_coin&#96; in 1.794s\n&#123;\n  &quot;Error&quot;: &quot;Move Prover failed: exiting with verification errors&quot;\n&#125;</code></pre>\n\n<p>Prover’s output tells us that it found a situation where the <code>balance_of</code> function aborts, but we don’t explicitly point out the possibility of such aborts.<br>Looking at the code that triggers the abort, we can see that the exception is caused by calling the built-in <code>borrow_global</code> function when the <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.<br>Following the guidance of the error message, we can add the following <code>aborts_if</code> condition:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec balance_of &#123;\n    pragma aborts_if_is_strict;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(owner);\n&#125;</code></pre>\n\n<p>After adding this condition, try calling Prover again and see that there are no more validation errors.<br>Now we can confidently confirm that the <code>balance_of</code> function has one and only one possibility of abnormal termination, that is, the parameter <code>owner</code> does not own a resource of type <code>Balance&lt;CoinType&gt;</code>.</p>\n<h2 id=\"Verify-withdraw-function\"><a href=\"#Verify-withdraw-function\" class=\"headerlink\" title=\"Verify withdraw function\"></a>Verify withdraw function</h2><p>The signature of the function <code>withdraw</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance</code></pre>\n\n<p>Its role is to withdraw the <code>amount</code> of coins from the address <code>addr</code> and return it.</p>\n<h3 id=\"Specify-the-abort-condition-for-withdraw\"><a href=\"#Specify-the-abort-condition-for-withdraw\" class=\"headerlink\" title=\"Specify the abort condition for withdraw\"></a>Specify the abort condition for <code>withdraw</code></h3><p>There are two possibilities for <code>withdraw</code> to abort:</p>\n<ol>\n<li>No resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>.</li>\n<li>The balance in <code>addr</code> is less than <code>amount</code>.</li>\n</ol>\n<p>From these, we can define the abort condition like this:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n&#125;</code></pre>\n\n<ul>\n<li>A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.<br><code>global&lt;T&gt;(addr): T</code> is a built-in function that returns a resource of type <code>T</code> at address <code>addr</code>.<br>Here, we set balance to the number of tokens owned by addr via the let binding;</li>\n<li><code>exists&lt;T&gt;(address): bool</code> is a built-in function that returns true if resource <code>T</code> exists at address <code>addr</code>; otherwise returns false.</li>\n</ul>\n<p>The two lines of <code>aborts_if</code> statements correspond to the two conditions mentioned above.<br>In general, if a function has multiple <code>aborts_if</code> conditions, the conditions are ORed together.</p>\n<p>As mentioned earlier, if we don’t specify any abort conditions, Prover will not impose any restrictions on aborts.<br>But once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction <code>pragma aborts_if_is_strict</code>.<br>If only some of the conditions for abnormal exit are listed, the Prover will report a validation error.<br>However, if the <code>pragma aborts_if_is_partial</code> is defined in the spec block, this is equivalent to telling the Prover:</p>\n<blockquote>\n<p>I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.</p>\n</blockquote>\n<p>If you are interested, you can do such a set of experiments to verify:</p>\n<ul>\n<li>When deleting any of the above two <code>aborts_if</code> conditions, Prover will report an error;</li>\n<li>When all <code>aborts_if</code> conditions are deleted at the same time, Prover will not report an error;</li>\n<li>When adding <code>pragma aborts_if_is_partial</code>, no matter how many <code>aborts_if</code> conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).</li>\n</ul>\n<p>Some readers may be curious about the order of the three statements in the spec block:<br>Why the definition of balance can be written after <code>aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr)</code>.<br>Because, if the latter holds true, <code>balance</code> does not actually exist.<br>Wouldn’t this order cause the Prover to fail?<br>Simply put: no, the statements in the spec block are declarative and the order doesn’t matter.</p>\n<p>For a more detailed understanding, you can refer to the MSL documentation for more information.</p>\n<h3 id=\"Specify-the-functional-nature-of-withdraw\"><a href=\"#Specify-the-functional-nature-of-withdraw\" class=\"headerlink\" title=\"Specify the functional nature of withdraw\"></a>Specify the functional nature of <code>withdraw</code></h3><p>Next, we define functional properties.<br>The two <code>ensures</code> statements in the following spec block give us what we expect from the <code>withdraw</code> functionality:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec withdraw &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance &lt; amount;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance - amount;\n    ensures result &#x3D;&#x3D; Coin&lt;CoinType&gt; &#123; value: amount &#125;;\n&#125;</code></pre>\n\n<p>In this code, first by using <code>let post</code> binding, define <code>balance_post</code> as the balance of <code>addr</code> after the function is executed, it should be equal to <code>balance - amount</code>. Then, <code>result</code> is a special name that represents the return value, which should be the <code>amount</code> of tokens.</p>\n<h2 id=\"Verify-the-deposit-function\"><a href=\"#Verify-the-deposit-function\" class=\"headerlink\" title=\"Verify the deposit function\"></a>Verify the <code>deposit</code> function</h2><p>The signature of the function deposit is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance</code></pre>\n\n<p>It deposits the token funds indicated by <code>check</code> into the address <code>addr</code>. Its canonical definition is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec deposit &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    let check_value &#x3D; check.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + check_value &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + check_value;\n&#125;</code></pre>\n\n<p>Here, <code>balance</code> is defined as the balance in <code>addr</code> before the function is executed, and <code>check_value</code> is defined as the amount of tokens to be deposited. It will abort in two cases:</p>\n<ol>\n<li>There is no resource of type <code>Balance&lt;CoinType&gt;</code> in <code>addr</code>;</li>\n<li>Or the sum of <code>balance</code> and <code>check_value</code> is greater than the maximum value of type <code>u64</code>.</li>\n</ol>\n<p>The <code>ensures</code> statement is used to let the Prover make sure that in any case, the balance in <code>addr</code> can be updated correctly after the function is executed.</p>\n<p>The syntax mentioned earlier will not be repeated here.<br>Astute readers may have noticed that it is worth noting that the expression <code>balance + check_value &gt; MAX_U64</code> is problematic in the Move program.<br>Because the addition on the left may cause an overflow exception.<br>If we want to write a similar check in the Move program, we should use an expression like <code>balance &gt; MAX_U64 - check_value</code> to avoid the overflow problem.</p>\n<p>However, this expression is perfectly fine in the Move Specification Language (MSL).<br>Since the spec block uses the MSL language, its type system is different from that of Move.<br>In MSL, all integers are of type <code>num</code>, which is an integer in the mathematical sense. That is, it is signed and has no size limit.<br>All built-in integer types (<code>u8</code>, <code>u64</code>, etc.) are automatically converted to type <code>num</code> when referencing data in a Move program in MSL.<br>A more detailed description of the type system can be found in the MSL documentation.</p>\n<h2 id=\"Verify-the-transfer-function\"><a href=\"#Verify-the-transfer-function\" class=\"headerlink\" title=\"Verify the transfer function\"></a>Verify the <code>transfer</code> function</h2><p>The signature of the function <code>transfer</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for the transfer <code>from</code> the account from to the address <code>to</code>, and the transfer amount is <code>amount</code>.</p>\n<p>Let’s ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec transfer &#123;\n    let addr_from &#x3D; signer::address_of(from);\n\n    let balance_from &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let balance_to &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n    let post balance_from_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;\n    let post balance_to_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;\n\n    ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n    ensures balance_to_post &#x3D;&#x3D; balance_to + amount;\n&#125;</code></pre>\n\n<p>Here <code>from</code> is of type <code>signer</code>, not a direct address.<br>Although in the program we have created a local variable called <code>addr_from</code>, we cannot directly reference it in the spec block.<br>At the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to <code>addr_from</code> again.<br>Then use <code>let</code> and <code>let post</code> to define several variables, corresponding to the balances in the two addresses <code>addr_from</code> and <code>to</code> before and after the function is executed.<br>Finally, use the <code>ensures</code> statement to tell Prover that the balance in <code>from</code> should be subtracted by <code>amount</code>; the balance in <code>to</code> should be increased by <code>amount</code>.</p>\n<p>At first glance, there seems to be no problem at all. But is it really so?<br>Let’s see if Prover thinks this is “the correct description of the behavior of this function”.<br>After typing <code>aptos move prove</code> you can see:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error: post-condition does not hold\n   ┌─ .&#x2F;sources&#x2F;BasicCoin.move:58:9\n   │\n58 │         ensures balance_from_post &#x3D;&#x3D; balance_from - amount;\n   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   │\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:51: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:53: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:54: transfer (spec)\n   &#x3D;     at .&#x2F;sources&#x2F;BasicCoin.move:45: transfer\n   &#x3D;         from &#x3D; signer&#123;0x0&#125;\n   &#x3D;         to &#x3D; 0x0\n   &#x3D;         amount &#x3D; 1\n   &#x3D;         _witness &#x3D; &lt;generic&gt;</code></pre>\n\n<p>It is somewhat out of our expectations. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the <code>transfer</code> function.<br>Why is this so? Let’s look down again: the parameters that make the postconditions not satisfied are <code>from = signer&#123;0x0&#125;</code> and <code>to = 0x0</code>. We should know the reason: when the account transfers money to itself, both <code>to</code> and <code>from</code> point to the same address, so the balance does not change.</p>\n<p>There are two solutions now:</p>\n<p><strong>Plan A</strong> does not modify the function definition, but changes the specification.<br>In the spec block, consider whether the two accounts for the transfer and receiving are the same address.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures (addr_from &#x3D;&#x3D; to &amp;&amp; eq_post) || (addr_from !&#x3D; to &amp;&amp; ne_post);</code></pre>\n\n<p>Or use another slightly more intuitive if syntax:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let post eq_post &#x3D; balance_to &#x3D;&#x3D; balance_to_post;\nlet post ne_post &#x3D; balance_from_post &#x3D;&#x3D; balance_from - amount\n                &amp;&amp; balance_to_post   &#x3D;&#x3D; balance_to   + amount;\nensures if (addr_from &#x3D;&#x3D; to) eq_post else ne_post;</code></pre>\n\n<p>Note that <code>if (P) E1 else E2</code> is not the same as conditional execution in program logic – it’s actually a syntactic sugar equivalent to <code>ensures</code> both <code>P ==&gt; E1</code> and <code>!P ==&gt; E2</code>.<br>And <code>p ==&gt; q</code> is actually <code>!p || q</code>.</p>\n<p>That is to say, the end of the second way of writing actually represents this logic:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from &#x3D;&#x3D; to  &#x3D;&#x3D;&#x3D;&gt;  eq_post) &amp;&amp; (addr_from !&#x3D; to  &#x3D;&#x3D;&#x3D;&gt; ne_post);</code></pre>\n\n<p>that is:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">ensures (addr_from !&#x3D; to || eq_post) &amp;&amp; (addr_from &#x3D;&#x3D; to  || ne_post);</code></pre>\n\n<p>Interested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former <code>(addr_from == to &amp;&amp; eq_post) || (addr_from != to &amp;&amp; ne_post)</code> and the latter <code>(addr_from != to || eq_post) &amp;&amp; (addr_from == to  || ne_post)</code> are actually exactly equivalent expressions.</p>\n<p><strong>Plan B</strong> does not modify the spec, but directly adds <code>assert!(addr_from != to, EEQUAL_ADDR);</code> in the function body, and adds the definition of the error code <code>EEQUAL_ADDR</code> in front, so that the self-transfer transaction cannot be completed.</p>\n<p>Obviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.<br>So plan B is a better practice.<br>It directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise.</p>\n<h3 id=\"Practice\"><a href=\"#Practice\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>Currently, we have only completed functional verification of the <code>transfer</code> function.<br>But it doesn’t say under what circumstances it will abort.<br>As an exercise, give it an appropriate <code>aborts_if</code> condition. The answer can be found in our next article.</p>\n<h2 id=\"Verify-mint-function\"><a href=\"#Verify-mint-function\" class=\"headerlink\" title=\"Verify mint function\"></a>Verify mint function</h2><p>The signature of the function <code>mint</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun mint&lt;CoinType: drop&gt;(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance</code></pre>\n\n<p>It is responsible for minting the <code>amount</code> of tokens and depositing them in the address <code>mint_addr</code>.<br>More interesting is <code>_witness</code>, which is of type <code>CoinType</code>.<br>Because only the module that defines the <code>CoinType</code> can construct a value of this type, this guarantees the identity of the caller.</p>\n<p>There is actually only one call to <code>deposit</code> in the <code>mint</code> function.<br>It is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(mint_addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(mint_addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<h2 id=\"Verify-the-publish-balance-function\"><a href=\"#Verify-the-publish-balance-function\" class=\"headerlink\" title=\"Verify the publish_balance function\"></a>Verify the <code>publish_balance</code> function</h2><p>The signature of the function <code>publish_balance</code> is as follows:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">public fun publish_balance&lt;CoinType&gt;(account: &amp;signer)</code></pre>\n\n<p>It publishes an empty <code>Balance&lt;CoinType&gt;</code> resource under <code>account</code>.<br>So if the resource already exists it should exit abnormally, and end normally the balance should be zero:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec publish_balance &#123;\n    let addr &#x3D; signer::address_of(account);\n    aborts_if exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n\n    ensures exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; 0;\n&#125;</code></pre>\n\n<h2 id=\"Simplify-redundant-specifications-with-Schema\"><a href=\"#Simplify-redundant-specifications-with-Schema\" class=\"headerlink\" title=\"Simplify redundant specifications with Schema\"></a>Simplify redundant specifications with Schema</h2><p>Congratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.<br>However, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit.</p>\n<p>Schema is a means of building a specification by grouping properties.<br>Semantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules.</p>\n<h3 id=\"Eliminate-simple-repetitions\"><a href=\"#Eliminate-simple-repetitions\" class=\"headerlink\" title=\"Eliminate simple repetitions\"></a>Eliminate simple repetitions</h3><p>As a most obvious example, the spec blocks of <code>mint</code> and <code>deposit</code> are a little different except for the variable names (in terms, they are <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion\">alpha convertible</a>), and the overall structure can be said to be exactly the same.<br>To simplify them, let’s create a Schema:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec schema DepositSchema&lt;CoinType&gt; &#123;\n    addr: address;\n    amount: u64;\n\n    let balance &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n\n    aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);\n    aborts_if balance + amount &gt; MAX_U64;\n\n    let post balance_post &#x3D; global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;\n    ensures balance_post &#x3D;&#x3D; balance + amount;\n&#125;</code></pre>\n\n<p>This Schema declares two typed variables, and some conditions about what those variables should satisfy.<br>When other places want to use this Schema, use <code>include DepositSchema &#123;addr: XX, amount: YY&#125;</code> to import it.<br>where <code>XX</code> and <code>YY</code> are expressions used to replace <code>addr</code> and <code>amount</code>.<br>If the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it.</p>\n<p>With the above Schema definition, we can now simplify the previous spec:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">spec mint &#123;\n  include DepositSchema&lt;CoinType&gt; &#123;addr: mint_addr&#125;;\n&#125;\n&#x2F;&#x2F; ....\nspec deposit &#123;\n    include DepositSchema&lt;CoinType&gt; &#123;amount: check.value&#125;;\n&#125;</code></pre>\n\n<h3 id=\"Practice-1\"><a href=\"#Practice-1\" class=\"headerlink\" title=\"Practice\"></a>Practice</h3><p>In addition to the above example, find another spec block (such as <code>publish_balance</code>), and split it into a Schema declaration and a spec block that uses the corresponding Schema.<br>As an exercise, the Schema you created might not be available in this code, so it doesn’t feel like there’s a benefit to it.<br>But if in the later development, there are other functions that call <code>publish_balance</code>, it will be more convenient.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>In our article so far, we’ve shown you how the Move Prover works and it could potentially provide the ultimate safety guarantee for smart contracts. In the upcoming series, we will explore </p>\n<ul>\n<li>the tips and best practices; </li>\n<li>a more complicated case study using the Move Prover; </li>\n<li>the limitation of the current version of the Move Prover, and its future outlook;</li>\n</ul>\n<p>So stay tuned!</p>\n<p>More and more developers are developing or deploying smart contracts on Move Ecosystem,  it is recommended to ship the Move contracts with a comprehensive security assessment using the Move Prover and other industry-leading audit methodology. If you need help evaluating Move smart contracts for vulnerabilities and certifying their behavior.  Please <a href=\"https://www.movebit.xyz/#contact\">fill out our contact form</a>. We’d be happy to help.</p>\n<h2 id=\"About-Us\"><a href=\"#About-Us\" class=\"headerlink\" title=\"About Us\"></a>About Us</h2><p><a href=\"https://www.movebit.xyz/\">MoveBit</a> is a security audit company for the Move ecosystem. Our team is comprised of security leaders from academia and enterprise, with 10 years of cybersecurity experience, and has presented security research papers at top international security academic conferences such as NDSS and CS. </p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><a href=\"https://github.com/move-language/move/tree/main/language/documentation/tutorial/\">Move tutorial</a> by the Move team</li>\n<li><a href=\"https://cookbook.starcoin.org/docs/move/move-prover/mvp-tutorial/\">Starocin Move Prover tutorial</a> by Xudong Wang</li>\n</ul>\n"},{"title":"MoveBit Launches the First Move CTF Security Competition Sponsored by Mysten Labs","date":"2022-10-18T11:42:30.000Z","description":"The Move ecosystem is booming, and with it comes a need for Move-specific security expertise.","thumbnail":"/img/icon.png","_content":"\nThe Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.\n \nThe Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. \n \nMoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.\n\n![MoveCTF](../img/movectf.jpeg)\n \nMoveCTF's first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.\n \nThe top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.\n \nRegistration for the MoveCTF competition is now open. For more information, please visit this link:  https://movectf.movebit.xyz/\n \n## About MoveBit\nMoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.\n\n![MoveBit](../img/movebit_logo.png)\n\n\n## About Mysten Labs\n \nMysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.\n\n![MoveBit](../img/sui_logo.png)\n\n\nSui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.\n\n","source":"_posts/movectf.md","raw":"---\ntitle: MoveBit Launches the First Move CTF Security Competition Sponsored by Mysten Labs\ndate: 2022-10-18 19:42:30\ntags:\ndescription: The Move ecosystem is booming, and with it comes a need for Move-specific security expertise.\nthumbnail: /img/icon.png\n---\n\nThe Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.\n \nThe Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. \n \nMoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.\n\n![MoveCTF](../img/movectf.jpeg)\n \nMoveCTF's first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.\n \nThe top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.\n \nRegistration for the MoveCTF competition is now open. For more information, please visit this link:  https://movectf.movebit.xyz/\n \n## About MoveBit\nMoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.\n\n![MoveBit](../img/movebit_logo.png)\n\n\n## About Mysten Labs\n \nMysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.\n\n![MoveBit](../img/sui_logo.png)\n\n\nSui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.\n\n","slug":"movectf","published":1,"updated":"2022-12-05T09:52:03.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbbmsdzh00026b7lerp2232e","content":"<p>The Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.</p>\n<p>The Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. </p>\n<p>MoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.</p>\n<p><img src=\"/../img/movectf.jpeg\" alt=\"MoveCTF\"></p>\n<p>MoveCTF’s first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.</p>\n<p>The top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.</p>\n<p>Registration for the MoveCTF competition is now open. For more information, please visit this link:  <a href=\"https://movectf.movebit.xyz/\">https://movectf.movebit.xyz/</a></p>\n<h2 id=\"About-MoveBit\"><a href=\"#About-MoveBit\" class=\"headerlink\" title=\"About MoveBit\"></a>About MoveBit</h2><p>MoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.</p>\n<p><img src=\"/../img/movebit_logo.png\" alt=\"MoveBit\"></p>\n<h2 id=\"About-Mysten-Labs\"><a href=\"#About-Mysten-Labs\" class=\"headerlink\" title=\"About Mysten Labs\"></a>About Mysten Labs</h2><p>Mysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.</p>\n<p><img src=\"/../img/sui_logo.png\" alt=\"MoveBit\"></p>\n<p>Sui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>The Move ecosystem is booming, and with it comes a need for Move-specific security expertise. Though Move is a secure and safe language by design, Move developers still need a place to learn and practice writing secure Move smart contracts.</p>\n<p>The Move community is thus organizing a flagship Move security competition to attract more security professionals and developers interested in the Move language and the Move ecosystem. </p>\n<p>MoveBit is collaborating with many Move ecosystem projects to organize the first ever Move ecosystem CTF (Capture The Flag) security competition: MoveCTF. Mysten Labs (Sui) will be a supporter and sole sponsor of the competition.</p>\n<p><img src=\"/../img/movectf.jpeg\" alt=\"MoveCTF\"></p>\n<p>MoveCTF’s first Move security competition will be held online. The competition will take place from 6pm on November 5 to 6pm on November 7 (PST), for a total of 48 hours. This MoveCTF competition will set four security challenges related to Move language, with a range of difficulty levels. Participants will earn points for completing each challenge. The top four fastest participants for each challenge will be rewarded with additional points.</p>\n<p>The top three winners ranked by total points will be awarded 1000 USD, 500 USD, and 300 USD respectively, sponsored by Mysten Labs (Sui). In addition, MoveCTF partner Mynft will mint a mystery NFT for each of the three winners on Suia. Mynft will also mint a Move Hacker NFT for each participant who completes at least one Move security challenge.</p>\n<p>Registration for the MoveCTF competition is now open. For more information, please visit this link:  <a href=\"https://movectf.movebit.xyz/\">https://movectf.movebit.xyz/</a></p>\n<h2 id=\"About-MoveBit\"><a href=\"#About-MoveBit\" class=\"headerlink\" title=\"About MoveBit\"></a>About MoveBit</h2><p>MoveBit is a security audit company for the Move ecosystem with a vision to make Move’s ecosystem the most secure Web3 destination. The MoveBit team is composed of academic security experts and corporate security leaders with 10 years of security experience. The team was one of the earliest contributors to the Move ecosystem, and works with Move developers to formulate the standards for secure Move applications.</p>\n<p><img src=\"/../img/movebit_logo.png\" alt=\"MoveBit\"></p>\n<h2 id=\"About-Mysten-Labs\"><a href=\"#About-Mysten-Labs\" class=\"headerlink\" title=\"About Mysten Labs\"></a>About Mysten Labs</h2><p>Mysten Labs develops tools that make Web3 secure, reliable, and ready for mass adoption. It creates foundational infrastructure to accelerate the adoption of Web3. The company gathers the brightest minds to create infrastructure and tools for a decentralized future for everyone.</p>\n<p><img src=\"/../img/sui_logo.png\" alt=\"MoveBit\"></p>\n<p>Sui by Mysten Labs is a next-generation smart contract platform with high throughput and low latency, an asset-oriented programming model powered by Move. It is designed from the ground up to enable creators and developers to build Web3 applications that could cater to billions of users.</p>\n"},{"title":"The First MoveCTF Summary","date":"2022-11-10T10:00:00.000Z","description":"MoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition","thumbnail":"/img/icon.png","_content":"\nMoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.\n\nBy the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.\n\nEach challenge was completed as follows.\n* checkin 305 solves \n* simple game 22 solves\n* move lock 37 solves\n* flash loan 41 solves\n\n![alt rank](../img/post3_1.png)\n\nThe top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.\n\nIn addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.\n\n![alt rank](../img/post3_2.png)\n\n![alt rank](../img/post3_3.png)\n\nThanks to all the participants and partners, let's look forward to the next Move CTF!\n\nMoveCTF official website: \n[http://movectf.movebit.xyz/](http://movectf.movebit.xyz/)\n\nMoveBit official website: \n[https://www.movebit.xyz/](https://www.movebit.xyz/)\n","source":"_posts/the-first-movectf-summary.md","raw":"---\ntitle: The First MoveCTF Summary\ndate: 2022-11-10 18:00:00\ntags:\ndescription: MoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition\nthumbnail: /img/icon.png\n---\n\nMoveCTF  (Nov 5 — Nov 7 / 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.\n\nBy the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.\n\nEach challenge was completed as follows.\n* checkin 305 solves \n* simple game 22 solves\n* move lock 37 solves\n* flash loan 41 solves\n\n![alt rank](../img/post3_1.png)\n\nThe top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.\n\nIn addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.\n\n![alt rank](../img/post3_2.png)\n\n![alt rank](../img/post3_3.png)\n\nThanks to all the participants and partners, let's look forward to the next Move CTF!\n\nMoveCTF official website: \n[http://movectf.movebit.xyz/](http://movectf.movebit.xyz/)\n\nMoveBit official website: \n[https://www.movebit.xyz/](https://www.movebit.xyz/)\n","slug":"the-first-movectf-summary","published":1,"updated":"2022-12-05T09:52:03.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbbmsdzl00046b7l4r3e1nhq","content":"<p>MoveCTF  (Nov 5 — Nov 7 &#x2F; 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.</p>\n<p>By the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.</p>\n<p>Each challenge was completed as follows.</p>\n<ul>\n<li>checkin 305 solves </li>\n<li>simple game 22 solves</li>\n<li>move lock 37 solves</li>\n<li>flash loan 41 solves</li>\n</ul>\n<p><img src=\"/../img/post3_1.png\" alt=\"alt rank\"></p>\n<p>The top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.</p>\n<p>In addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.</p>\n<p><img src=\"/../img/post3_2.png\" alt=\"alt rank\"></p>\n<p><img src=\"/../img/post3_3.png\" alt=\"alt rank\"></p>\n<p>Thanks to all the participants and partners, let’s look forward to the next Move CTF!</p>\n<p>MoveCTF official website:<br><a href=\"http://movectf.movebit.xyz/\">http://movectf.movebit.xyz/</a></p>\n<p>MoveBit official website:<br><a href=\"https://www.movebit.xyz/\">https://www.movebit.xyz/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>MoveCTF  (Nov 5 — Nov 7 &#x2F; 2022), the first Move CTF (Capture The Flag) security competition, exclusively sponsored by Sui Network development company Mysten Labs, concluded successfully. The competition was organized by MoveBit, ChainFlag, OtterSec and co-organized by Mynft and SuiWorld DAO.</p>\n<p>By the end of the competition (November 7, 2022 at 6:00 PST), there were 1,280 registered competitors from 25 countries and regions worldwide. The competition had four challenges: checkin, simple game, flash loan, and move lock. A total of 18 people solved all four challenges.</p>\n<p>Each challenge was completed as follows.</p>\n<ul>\n<li>checkin 305 solves </li>\n<li>simple game 22 solves</li>\n<li>move lock 37 solves</li>\n<li>flash loan 41 solves</li>\n</ul>\n<p><img src=\"/../img/post3_1.png\" alt=\"alt rank\"></p>\n<p>The top three winners were neo, Ekipa Remontowa, and Slss. Congrats to these three winners, who will receive an exclusive prize sponsored by Sui Network and a special NFT. The remaining participants who completed at least one challenge will receive a Sui net-based POAP NFT.</p>\n<p>In addition, the MoveCTF was well received by Move language learners, and we will soon open four challenges for the Move community to learn and use.</p>\n<p><img src=\"/../img/post3_2.png\" alt=\"alt rank\"></p>\n<p><img src=\"/../img/post3_3.png\" alt=\"alt rank\"></p>\n<p>Thanks to all the participants and partners, let’s look forward to the next Move CTF!</p>\n<p>MoveCTF official website:<br><a href=\"http://movectf.movebit.xyz/\">http://movectf.movebit.xyz/</a></p>\n<p>MoveBit official website:<br><a href=\"https://www.movebit.xyz/\">https://www.movebit.xyz/</a></p>\n"},{"title":"Sui Concept and Testnet","date":"2022-12-30T08:53:50.000Z","description":"MoveBit will show you how to run and interact with Sui local testnet","thumbnail":"/img/icon.png","_content":"We can learn Sui concepts from here:\n[https://docs.sui.io/learn/how-sui-works](https://docs.sui.io/learn/how-sui-works)\n\n# SUI CODE ARCHITECTURE\nThe latest version of the code  is `devnet-0.17.0`\n\n```jsx\ngit clone https://github.com/MystenLabs/sui.git\n```\n\n```bash\n.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp\n```\n\nAs we can see, the structure of the code is similar to Aptos.\n\nDifferent functions are organized in different packages in `sui/crates/ folder`.The most parts are those:\n\n```bash\n├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n```\n\n## cartes/sui\n\nLike Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in `crates/src/main.rc —> fn main()`. Our entire code analysis process starts with this entry.\n\n![Untitled](../img/123.png)\n\n## other packages\n\n- sui-faucet - sui faucet related service.\n- sui-node - node related\n- sui-core - authority server and Sui Gateway\n- sui-types - coins, gas, and other object types\n- sui-network - networking interfaces\n\n\n# Build Sui and run local testnet\n\nThe Sui repository includes two primary branches, `devnet` and `main`.\n\n- The `devnet` branch includes the latest stable build of Sui. Choose the `devnet` branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the `main` branch. To submit a pull request (PR), you should push commits to your fork of the `main` branch.\n- The `main` branch includes the most recent changes and updates. Use the `main` branch if you want to contribute to the Sui project. The `main` branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.\n\n> *The previous* `git clone` *command syncs with the* `devnet` *branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don't need to interact with our Devnet, you should switch to* `main` *branch.*\n> \n\n## **Build**\n\nCause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.\n\n```bash\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch devnet sui\n```\n\nThis will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can't compile, then change the system.\n\nI have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.\n\nIt took about an hour to compile this.\n\n![Untitled](../img/1234.png)\n\n> For more detail : [https://docs.sui.io/build/install](https://docs.sui.io/build/install)\n> \n\nAfter we compiled we can see the executable file in `~/.carge/bin/sui`. And the we can use it to run local testnet.\n\n![Untitled](../img/12345.png)\n\n## genesis\n\nTo create the configuration files and objects for a local Sui network, run the `genesis` command. Genesis creates the network configuration files in the `~/.sui/sui_config` folder. \n\n```bash\n#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in \"/Users/safeer/.sui/sui_config/network.yaml\".\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in \"/Users/safeer/.sui/sui_config/sui.keystore\".\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in \"/Users/safeer/.sui/sui_config/client.yaml\".\n```\n\nThis includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.\n\nThe network that genesis creates includes four validators and five user accounts that contain five coin objects each.\n\n![Untitled](../img/123456.png)\n\n## Start the local network\n\nRun the following command to start the local Sui network with default configuration( `~/.sui/sui_config/network.yaml`).\n\n```bash\nsui start\n```\n\n![Untitled](../img/23.jpeg)\n\nWhen you start the network, Sui generates an `authorities_db directory` that stores validator data, and a `consensus_db` directory that stores consensus data.\n\n![Untitled](../img/24.png)\n\n# Interact with Sui local network\n\n## sui client\n\nwe can use Sui CLI to interact with Sui net\n\n```bash\n#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~/.sui/sui_config directory\nsui console \n```\n\n![Untitled](../img/25.png)\n\nSome example:\n\n```bash\n#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100\n```\n\n![Untitled](../img/26.png)\n\n![Untitled](../img/27.png)\n\n![Untitled](../img/28.png)\n\n# Debug Sui with vscode\n\nIn the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.\n\nSteps(on mac):\n\n1. install vscode and plug-in (rust-analyzer,CodeLLDB)\n2. open the sui folder\n3. open the target file\n\ncreate new launch.json file(will be automatically generated  ).\n\n![Untitled](../img/30.png)\n\nadd args:\n\n![Untitled](../img/31.png)\n\nStart to debug:\n\n![Untitled](../img/33.png)\n\n**About MoveBit**\n\n**MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.**\n\nTwitter: https://twitter.com/MoveBit_  \nMedium: https://movebit.medium.com/\nGithub: https://github.com/movebit\nDiscord: https://discord.com/invite/7wM8VU9Gyj\n","source":"_posts/Sui Concept and Testnet.md","raw":"---\ntitle: Sui Concept and Testnet\ndate: 2022-12-30 16:53:50\ntags: \ndescription: MoveBit will show you how to run and interact with Sui local testnet\nthumbnail: /img/icon.png\n---\nWe can learn Sui concepts from here:\n[https://docs.sui.io/learn/how-sui-works](https://docs.sui.io/learn/how-sui-works)\n\n# SUI CODE ARCHITECTURE\nThe latest version of the code  is `devnet-0.17.0`\n\n```jsx\ngit clone https://github.com/MystenLabs/sui.git\n```\n\n```bash\n.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp\n```\n\nAs we can see, the structure of the code is similar to Aptos.\n\nDifferent functions are organized in different packages in `sui/crates/ folder`.The most parts are those:\n\n```bash\n├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n```\n\n## cartes/sui\n\nLike Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in `crates/src/main.rc —> fn main()`. Our entire code analysis process starts with this entry.\n\n![Untitled](../img/123.png)\n\n## other packages\n\n- sui-faucet - sui faucet related service.\n- sui-node - node related\n- sui-core - authority server and Sui Gateway\n- sui-types - coins, gas, and other object types\n- sui-network - networking interfaces\n\n\n# Build Sui and run local testnet\n\nThe Sui repository includes two primary branches, `devnet` and `main`.\n\n- The `devnet` branch includes the latest stable build of Sui. Choose the `devnet` branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the `main` branch. To submit a pull request (PR), you should push commits to your fork of the `main` branch.\n- The `main` branch includes the most recent changes and updates. Use the `main` branch if you want to contribute to the Sui project. The `main` branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.\n\n> *The previous* `git clone` *command syncs with the* `devnet` *branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don't need to interact with our Devnet, you should switch to* `main` *branch.*\n> \n\n## **Build**\n\nCause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.\n\n```bash\ncargo install --locked --git https://github.com/MystenLabs/sui.git --branch devnet sui\n```\n\nThis will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can't compile, then change the system.\n\nI have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.\n\nIt took about an hour to compile this.\n\n![Untitled](../img/1234.png)\n\n> For more detail : [https://docs.sui.io/build/install](https://docs.sui.io/build/install)\n> \n\nAfter we compiled we can see the executable file in `~/.carge/bin/sui`. And the we can use it to run local testnet.\n\n![Untitled](../img/12345.png)\n\n## genesis\n\nTo create the configuration files and objects for a local Sui network, run the `genesis` command. Genesis creates the network configuration files in the `~/.sui/sui_config` folder. \n\n```bash\n#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in \"/Users/safeer/.sui/sui_config/network.yaml\".\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in \"/Users/safeer/.sui/sui_config/sui.keystore\".\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in \"/Users/safeer/.sui/sui_config/client.yaml\".\n```\n\nThis includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.\n\nThe network that genesis creates includes four validators and five user accounts that contain five coin objects each.\n\n![Untitled](../img/123456.png)\n\n## Start the local network\n\nRun the following command to start the local Sui network with default configuration( `~/.sui/sui_config/network.yaml`).\n\n```bash\nsui start\n```\n\n![Untitled](../img/23.jpeg)\n\nWhen you start the network, Sui generates an `authorities_db directory` that stores validator data, and a `consensus_db` directory that stores consensus data.\n\n![Untitled](../img/24.png)\n\n# Interact with Sui local network\n\n## sui client\n\nwe can use Sui CLI to interact with Sui net\n\n```bash\n#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~/.sui/sui_config directory\nsui console \n```\n\n![Untitled](../img/25.png)\n\nSome example:\n\n```bash\n#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100\n```\n\n![Untitled](../img/26.png)\n\n![Untitled](../img/27.png)\n\n![Untitled](../img/28.png)\n\n# Debug Sui with vscode\n\nIn the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.\n\nSteps(on mac):\n\n1. install vscode and plug-in (rust-analyzer,CodeLLDB)\n2. open the sui folder\n3. open the target file\n\ncreate new launch.json file(will be automatically generated  ).\n\n![Untitled](../img/30.png)\n\nadd args:\n\n![Untitled](../img/31.png)\n\nStart to debug:\n\n![Untitled](../img/33.png)\n\n**About MoveBit**\n\n**MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.**\n\nTwitter: https://twitter.com/MoveBit_  \nMedium: https://movebit.medium.com/\nGithub: https://github.com/movebit\nDiscord: https://discord.com/invite/7wM8VU9Gyj\n","slug":"Sui Concept and Testnet","published":1,"updated":"2022-12-30T07:23:59.236Z","_id":"clca67fe20000jjqq2ytb76v7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>We can learn Sui concepts from here:<br><a href=\"https://docs.sui.io/learn/how-sui-works\">https://docs.sui.io/learn/how-sui-works</a></p>\n<h1 id=\"SUI-CODE-ARCHITECTURE\"><a href=\"#SUI-CODE-ARCHITECTURE\" class=\"headerlink\" title=\"SUI CODE ARCHITECTURE\"></a>SUI CODE ARCHITECTURE</h1><p>The latest version of the code  is <code>devnet-0.17.0</code></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">git clone https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp</code></pre>\n\n<p>As we can see, the structure of the code is similar to Aptos.</p>\n<p>Different functions are organized in different packages in <code>sui/crates/ folder</code>.The most parts are those:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node</code></pre>\n\n<h2 id=\"cartes-x2F-sui\"><a href=\"#cartes-x2F-sui\" class=\"headerlink\" title=\"cartes&#x2F;sui\"></a>cartes&#x2F;sui</h2><p>Like Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in <code>crates/src/main.rc —&gt; fn main()</code>. Our entire code analysis process starts with this entry.</p>\n<p><img src=\"/../img/123.png\" alt=\"Untitled\"></p>\n<h2 id=\"other-packages\"><a href=\"#other-packages\" class=\"headerlink\" title=\"other packages\"></a>other packages</h2><ul>\n<li>sui-faucet - sui faucet related service.</li>\n<li>sui-node - node related</li>\n<li>sui-core - authority server and Sui Gateway</li>\n<li>sui-types - coins, gas, and other object types</li>\n<li>sui-network - networking interfaces</li>\n</ul>\n<h1 id=\"Build-Sui-and-run-local-testnet\"><a href=\"#Build-Sui-and-run-local-testnet\" class=\"headerlink\" title=\"Build Sui and run local testnet\"></a>Build Sui and run local testnet</h1><p>The Sui repository includes two primary branches, <code>devnet</code> and <code>main</code>.</p>\n<ul>\n<li>The <code>devnet</code> branch includes the latest stable build of Sui. Choose the <code>devnet</code> branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the <code>main</code> branch. To submit a pull request (PR), you should push commits to your fork of the <code>main</code> branch.</li>\n<li>The <code>main</code> branch includes the most recent changes and updates. Use the <code>main</code> branch if you want to contribute to the Sui project. The <code>main</code> branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.</li>\n</ul>\n<blockquote>\n<p><em>The previous</em> <code>git clone</code> <em>command syncs with the</em> <code>devnet</code> <em>branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don’t need to interact with our Devnet, you should switch to</em> <code>main</code> <em>branch.</em></p>\n</blockquote>\n<h2 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a><strong>Build</strong></h2><p>Cause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cargo install --locked --git https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git --branch devnet sui</code></pre>\n\n<p>This will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can’t compile, then change the system.</p>\n<p>I have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.</p>\n<p>It took about an hour to compile this.</p>\n<p><img src=\"/../img/1234.png\" alt=\"Untitled\"></p>\n<blockquote>\n<p>For more detail : <a href=\"https://docs.sui.io/build/install\">https://docs.sui.io/build/install</a></p>\n</blockquote>\n<p>After we compiled we can see the executable file in <code>~/.carge/bin/sui</code>. And the we can use it to run local testnet.</p>\n<p><img src=\"/../img/12345.png\" alt=\"Untitled\"></p>\n<h2 id=\"genesis\"><a href=\"#genesis\" class=\"headerlink\" title=\"genesis\"></a>genesis</h2><p>To create the configuration files and objects for a local Sui network, run the <code>genesis</code> command. Genesis creates the network configuration files in the <code>~/.sui/sui_config</code> folder. </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;network.yaml&quot;.\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;sui.keystore&quot;.\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;client.yaml&quot;.</code></pre>\n\n<p>This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.</p>\n<p>The network that genesis creates includes four validators and five user accounts that contain five coin objects each.</p>\n<p><img src=\"/../img/123456.png\" alt=\"Untitled\"></p>\n<h2 id=\"Start-the-local-network\"><a href=\"#Start-the-local-network\" class=\"headerlink\" title=\"Start the local network\"></a>Start the local network</h2><p>Run the following command to start the local Sui network with default configuration( <code>~/.sui/sui_config/network.yaml</code>).</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sui start</code></pre>\n\n<p><img src=\"/../img/23.jpeg\" alt=\"Untitled\"></p>\n<p>When you start the network, Sui generates an <code>authorities_db directory</code> that stores validator data, and a <code>consensus_db</code> directory that stores consensus data.</p>\n<p><img src=\"/../img/24.png\" alt=\"Untitled\"></p>\n<h1 id=\"Interact-with-Sui-local-network\"><a href=\"#Interact-with-Sui-local-network\" class=\"headerlink\" title=\"Interact with Sui local network\"></a>Interact with Sui local network</h1><h2 id=\"sui-client\"><a href=\"#sui-client\" class=\"headerlink\" title=\"sui client\"></a>sui client</h2><p>we can use Sui CLI to interact with Sui net</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~&#x2F;.sui&#x2F;sui_config directory\nsui console </code></pre>\n\n<p><img src=\"/../img/25.png\" alt=\"Untitled\"></p>\n<p>Some example:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100</code></pre>\n\n<p><img src=\"/../img/26.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/27.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/28.png\" alt=\"Untitled\"></p>\n<h1 id=\"Debug-Sui-with-vscode\"><a href=\"#Debug-Sui-with-vscode\" class=\"headerlink\" title=\"Debug Sui with vscode\"></a>Debug Sui with vscode</h1><p>In the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.</p>\n<p>Steps(on mac):</p>\n<ol>\n<li>install vscode and plug-in (rust-analyzer,CodeLLDB)</li>\n<li>open the sui folder</li>\n<li>open the target file</li>\n</ol>\n<p>create new launch.json file(will be automatically generated  ).</p>\n<p><img src=\"/../img/30.png\" alt=\"Untitled\"></p>\n<p>add args:</p>\n<p><img src=\"/../img/31.png\" alt=\"Untitled\"></p>\n<p>Start to debug:</p>\n<p><img src=\"/../img/33.png\" alt=\"Untitled\"></p>\n<p><strong>About MoveBit</strong></p>\n<p><strong>MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.</strong></p>\n<p>Twitter: <a href=\"https://twitter.com/MoveBit\">https://twitter.com/MoveBit</a>_<br>Medium: <a href=\"https://movebit.medium.com/\">https://movebit.medium.com/</a><br>Github: <a href=\"https://github.com/movebit\">https://github.com/movebit</a><br>Discord: <a href=\"https://discord.com/invite/7wM8VU9Gyj\">https://discord.com/invite/7wM8VU9Gyj</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>We can learn Sui concepts from here:<br><a href=\"https://docs.sui.io/learn/how-sui-works\">https://docs.sui.io/learn/how-sui-works</a></p>\n<h1 id=\"SUI-CODE-ARCHITECTURE\"><a href=\"#SUI-CODE-ARCHITECTURE\" class=\"headerlink\" title=\"SUI CODE ARCHITECTURE\"></a>SUI CODE ARCHITECTURE</h1><p>The latest version of the code  is <code>devnet-0.17.0</code></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">git clone https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.\n├── CODE_OF_CONDUCT.MD\n├── CONTRIBUTING.md\n├── Cargo.lock\n├── Cargo.toml\n├── DEVX_ROADMAP.md\n├── ISSUES.md\n├── LICENSE\n├── LICENSE-docs\n├── README.md\n├── RELEASES.md\n├── SECURITY.md\n├── apps\n│   ├── core\n│   ├── explorer\n│   └── wallet\n├── crates\n│   ├── component\n│   ├── mysten-metrics\n│   ├── mysten-network\n│   ├── mysten-util-mem\n│   ├── mysten-util-mem-derive\n│   ├── prometheus-closure-metric\n│   ├── rccheck\n│   ├── sui\n│   ├── sui-adapter\n│   ├── sui-adapter-transactional-tests\n│   ├── sui-benchmark\n│   ├── sui-cluster-test\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-cost\n│   ├── sui-cost-tables\n│   ├── sui-faucet\n│   ├── sui-framework\n│   ├── sui-framework-build\n│   ├── sui-indexer\n│   ├── sui-json\n│   ├── sui-json-rpc\n│   ├── sui-json-rpc-types\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node\n│   ├── sui-open-rpc\n│   ├── sui-open-rpc-macros\n│   ├── sui-rosetta\n│   ├── sui-sdk\n│   ├── sui-simulator\n│   ├── sui-source-validation\n│   ├── sui-storage\n│   ├── sui-swarm\n│   ├── sui-telemetry\n│   ├── sui-test-validator\n│   ├── sui-tool\n│   ├── sui-transaction-builder\n│   ├── sui-transactional-test-runner\n│   ├── sui-types\n│   ├── sui-verifier\n│   ├── sui-verifier-transactional-tests\n│   ├── telemetry-subscribers\n│   ├── test-utils\n│   ├── typed-store\n│   ├── typed-store-derive\n│   ├── workspace-hack\n│   └── x\n├── dapps\n│   └── README.md\n├── deny.toml\n├── doc\n│   ├── book\n│   ├── code-examples\n│   ├── locals\n│   ├── paper\n│   ├── src\n│   ├── static\n│   ├── template\n│   ├── tips\n│   └── utils\n├── docker\n│   ├── fullnode\n│   ├── sui-node\n│   └── sui-tools\n├── narwhal\n│   ├── CONTRIBUTING.md\n│   ├── Docker\n│   ├── README.md\n│   ├── benchmark\n│   ├── config\n│   ├── consensus\n│   ├── crypto\n│   ├── dag\n│   ├── deny.toml\n│   ├── examples\n│   ├── executor\n│   ├── network\n│   ├── node\n│   ├── primary\n│   ├── scripts\n│   ├── storage\n│   ├── test-utils\n│   ├── types\n│   └── worker\n├── package.json\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n├── rust-toolchain\n├── rustfmt.toml\n├── scripts\n│   ├── bench_sweep.py\n│   ├── changed-files.sh\n│   ├── dependency.py\n│   ├── simtest\n│   ├── update_fastcrypto.sh\n│   └── update_narwhal.sh\n├── sdk\n│   ├── bcs\n│   ├── typescript\n│   └── wallet-adapter\n├── sui_programmability\n│   └── examples\n└── target\n    ├── CACHEDIR.TAG\n    ├── debug\n    └── tmp</code></pre>\n\n<p>As we can see, the structure of the code is similar to Aptos.</p>\n<p>Different functions are organized in different packages in <code>sui/crates/ folder</code>.The most parts are those:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── crates\n│   ├── sui\n│   ├── sui-config\n│   ├── sui-core\n│   ├── sui-faucet\n│   ├── sui-keys\n│   ├── sui-macros\n│   ├── sui-network\n│   ├── sui-node</code></pre>\n\n<h2 id=\"cartes-x2F-sui\"><a href=\"#cartes-x2F-sui\" class=\"headerlink\" title=\"cartes&#x2F;sui\"></a>cartes&#x2F;sui</h2><p>Like Aptos, the Sui is a CLI tool. we can use it to create a testnet node or interact with sui network. The endpoint of code is in <code>crates/src/main.rc —&gt; fn main()</code>. Our entire code analysis process starts with this entry.</p>\n<p><img src=\"/../img/123.png\" alt=\"Untitled\"></p>\n<h2 id=\"other-packages\"><a href=\"#other-packages\" class=\"headerlink\" title=\"other packages\"></a>other packages</h2><ul>\n<li>sui-faucet - sui faucet related service.</li>\n<li>sui-node - node related</li>\n<li>sui-core - authority server and Sui Gateway</li>\n<li>sui-types - coins, gas, and other object types</li>\n<li>sui-network - networking interfaces</li>\n</ul>\n<h1 id=\"Build-Sui-and-run-local-testnet\"><a href=\"#Build-Sui-and-run-local-testnet\" class=\"headerlink\" title=\"Build Sui and run local testnet\"></a>Build Sui and run local testnet</h1><p>The Sui repository includes two primary branches, <code>devnet</code> and <code>main</code>.</p>\n<ul>\n<li>The <code>devnet</code> branch includes the latest stable build of Sui. Choose the <code>devnet</code> branch if you want to build or test on Sui. If you encounter an issue or find a bug, it may already be fixed in the <code>main</code> branch. To submit a pull request (PR), you should push commits to your fork of the <code>main</code> branch.</li>\n<li>The <code>main</code> branch includes the most recent changes and updates. Use the <code>main</code> branch if you want to contribute to the Sui project. The <code>main</code> branch may include unreleased changes, or introduce changes that cause issues in apps created using an earlier version.</li>\n</ul>\n<blockquote>\n<p><em>The previous</em> <code>git clone</code> <em>command syncs with the</em> <code>devnet</code> <em>branch, which makes sure the source code is compatible with our Devnet. If you want to run a network locally using the latest version and don’t need to interact with our Devnet, you should switch to</em> <code>main</code> <em>branch.</em></p>\n</blockquote>\n<h2 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a><strong>Build</strong></h2><p>Cause the development team did not provide a compiled version,so we have to build Sui by ourself. We can use this command to build.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cargo install --locked --git https:&#x2F;&#x2F;github.com&#x2F;MystenLabs&#x2F;sui.git --branch devnet sui</code></pre>\n\n<p>This will take a long time and may fail with an error.If there is any error causing the failure.That is probably due to environmental problems(the version of the compilation tool is too low).Please update all the tools required and retry.If you still can’t compile, then change the system.</p>\n<p>I have been unable to compile successfully using macos 10.14.1 before, and I successed after I changed it to 12.6.</p>\n<p>It took about an hour to compile this.</p>\n<p><img src=\"/../img/1234.png\" alt=\"Untitled\"></p>\n<blockquote>\n<p>For more detail : <a href=\"https://docs.sui.io/build/install\">https://docs.sui.io/build/install</a></p>\n</blockquote>\n<p>After we compiled we can see the executable file in <code>~/.carge/bin/sui</code>. And the we can use it to run local testnet.</p>\n<p><img src=\"/../img/12345.png\" alt=\"Untitled\"></p>\n<h2 id=\"genesis\"><a href=\"#genesis\" class=\"headerlink\" title=\"genesis\"></a>genesis</h2><p>To create the configuration files and objects for a local Sui network, run the <code>genesis</code> command. Genesis creates the network configuration files in the <code>~/.sui/sui_config</code> folder. </p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#genesis \nsui genesis\n\n#output\n2022-12-06T08:54:58.103638Z  INFO sui_config::genesis_config: Creating accounts and gas objects...\n2022-12-06T08:54:58.190260Z  INFO sui::sui_commands: Network genesis completed.\n2022-12-06T08:54:58.193319Z  INFO sui::sui_commands: Network config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;network.yaml&quot;.\n2022-12-06T08:54:58.193344Z  INFO sui::sui_commands: Client keystore is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;sui.keystore&quot;.\n2022-12-06T08:54:58.198162Z  INFO sui::sui_commands: Client config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;client.yaml&quot;.</code></pre>\n\n<p>This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.</p>\n<p>The network that genesis creates includes four validators and five user accounts that contain five coin objects each.</p>\n<p><img src=\"/../img/123456.png\" alt=\"Untitled\"></p>\n<h2 id=\"Start-the-local-network\"><a href=\"#Start-the-local-network\" class=\"headerlink\" title=\"Start the local network\"></a>Start the local network</h2><p>Run the following command to start the local Sui network with default configuration( <code>~/.sui/sui_config/network.yaml</code>).</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sui start</code></pre>\n\n<p><img src=\"/../img/23.jpeg\" alt=\"Untitled\"></p>\n<p>When you start the network, Sui generates an <code>authorities_db directory</code> that stores validator data, and a <code>consensus_db</code> directory that stores consensus data.</p>\n<p><img src=\"/../img/24.png\" alt=\"Untitled\"></p>\n<h1 id=\"Interact-with-Sui-local-network\"><a href=\"#Interact-with-Sui-local-network\" class=\"headerlink\" title=\"Interact with Sui local network\"></a>Interact with Sui local network</h1><h2 id=\"sui-client\"><a href=\"#sui-client\" class=\"headerlink\" title=\"sui client\"></a>sui client</h2><p>we can use Sui CLI to interact with Sui net</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#use -h to show help of sui cli\nsui -h   \n\n# use subcommand help\nsui client -h\n\n# use interactive shell\n#The console command looks for the client configuration file client.yaml in the ~&#x2F;.sui&#x2F;sui_config directory\nsui console </code></pre>\n\n<p><img src=\"/../img/25.png\" alt=\"Untitled\"></p>\n<p>Some example:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#the list of account addresses available on the platform\nsui client addresses\n\n#Sui sets a default address to use for commands. It uses the active address for commands that require an address.\nsui client active-address\n\n#You can call the objects command with or without specifying an address. Sui uses the active address if you do not specify one.\nsui client objects\n\n#create a new address\nsui client new-address ed25519\n\n# send a trabsfer\nsui client transfer --to 0x49450a4a3cac01a44be9e82fe1b29df5a24bd244 --object-id 0xcc054f9b68501541c4a5355920fb896b1765a889 --gas-budget 100</code></pre>\n\n<p><img src=\"/../img/26.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/27.png\" alt=\"Untitled\"></p>\n<p><img src=\"/../img/28.png\" alt=\"Untitled\"></p>\n<h1 id=\"Debug-Sui-with-vscode\"><a href=\"#Debug-Sui-with-vscode\" class=\"headerlink\" title=\"Debug Sui with vscode\"></a>Debug Sui with vscode</h1><p>In the process of analyzing code, debugging is an essential step.It can help us understand the logic and flow during code execution. It can also help us find bugs in the code.</p>\n<p>Steps(on mac):</p>\n<ol>\n<li>install vscode and plug-in (rust-analyzer,CodeLLDB)</li>\n<li>open the sui folder</li>\n<li>open the target file</li>\n</ol>\n<p>create new launch.json file(will be automatically generated  ).</p>\n<p><img src=\"/../img/30.png\" alt=\"Untitled\"></p>\n<p>add args:</p>\n<p><img src=\"/../img/31.png\" alt=\"Untitled\"></p>\n<p>Start to debug:</p>\n<p><img src=\"/../img/33.png\" alt=\"Untitled\"></p>\n<p><strong>About MoveBit</strong></p>\n<p><strong>MoveBit is a blockchain security company focused on the Move Ecosystem by pioneering the use of cutting-edge Formal Verification. The team consists of security professionals from academia and enterprise with 10 years of security experience. they were one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications and make the Move ecosystem the most secure Web3 destination.</strong></p>\n<p>Twitter: <a href=\"https://twitter.com/MoveBit\">https://twitter.com/MoveBit</a>_<br>Medium: <a href=\"https://movebit.medium.com/\">https://movebit.medium.com/</a><br>Github: <a href=\"https://github.com/movebit\">https://github.com/movebit</a><br>Discord: <a href=\"https://discord.com/invite/7wM8VU9Gyj\">https://discord.com/invite/7wM8VU9Gyj</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clbbmsdze00016b7l1vg0hzdm","tag_id":"clbbmsdzj00036b7lbd5jgea5","_id":"clbbmsdzp00056b7lbhh54o2w"}],"Tag":[{"name":"move prover, m","_id":"clbbmsdzj00036b7lbd5jgea5"}]}}