<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="MoveBit, move lang, Move Contract Audit, Aptos smart contract audit, Sui smart contract audit, move Cybersecurity Auditor, Move Smart Contract Audit Service" />
  <meta name="author" content="MoveBit" />
  <meta name="description" content="MoveBit is a security audit company for the Move ecosystem with a vision to make the Move ecosystem the most secure Web3 destination. The MoveBit team is comprised of security leaders from academia and enterprise with 10 years of security experience and is the first blockchain security company to leverage formal verification in the Move ecosystem. The team was one of the earliest contributors to the Move ecosystem, working with Move developers to set the standard for secure Move applications." />
  
  <meta property="twitter:type" content="article">
  <meta property="twitter:site" content="MoveBit">
  <meta property="twitter:card" content="summary_large_image" />
  <meta property="twitter:creator" content="MoveBit">
  
    <meta name="twitter:title" content="Bootstrap of Sui local testnet | MoveBit" />
    <meta name="twitter:description" content="MoveBit will show you how to run and interact with Sui local testnet" />
    <meta name="twitter:image" content="http://blog.movebit.xyz/img/icon.png" />
  

  
  <title>
    
      Bootstrap of Sui local testnet 
      
      
    
  </title>

  
    <link rel="apple-touch-icon" href="/img/icon.png">
    <link rel="icon" href="/img/icon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat|Roboto:400,400italic,600|Roboto+Mono" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">


  

  
    
<link rel="stylesheet" href="/css/post.css">

  

  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="MoveBit" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <a target="_blank" rel="noopener" href="https://movebit.xyz/">MoveBit</a>
</div>


      <p class="links">
  
    <a title="archives" target="" href="/archives/">
      <i class="iconfont icon-bookmark"></i>
    </a>
  
    <a title="github" target="_blank" href="https://github.com/movebit">
      <i class="iconfont icon-github"></i>
    </a>
  
    <a title="email" target="" href="mailto:contact@movebit.xyz">
      <i class="iconfont icon-envelope"></i>
    </a>
  
    <a title="twitter" target="" href="https://twitter.com/movebit_">
      <i class="iconfont icon-twitter"></i>
    </a>
  
    <a title="rss" target="_blank" href="/atom.xml">
      <i class="iconfont icon-rss"></i>
    </a>
  
    <a title="wechat" target="" href="">
      <i class="iconfont icon-wechat"></i>
    </a>
  
    <a title="weibo" target="" href="">
      <i class="iconfont icon-weibo"></i>
    </a>
  
    <a title="rss" target="_blank" href="/atom.xml">
      <i class="iconfont icon-rss"></i>
    </a>
  
  
    <a title="discord" target="_blank" href="https://discord.gg/7wM8VU9Gyj">
      <img style="position: relative; top: 2px;" src="/img/discord.png" />
    </a>
  
</p>


      <div class="main">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>

<div class="post">
  <h3 class="date">
    Jan 03, 2023
  </h3>
  <h1>
    Bootstrap of Sui local testnet
  </h1>
  <div class="content markdown-body">
    <p><img src="/../img/20230103/111.png" alt="Untitled"><br>Since the code of sui is updated very quickly and we do not need to connect to devnet, so we select the main branch to analyze.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">branch main
commit db5a090d56c8f1f065474f26a12e97dc0ee33e12</code></pre>
<p><img src="/../img/20230103/300.png" alt="Untitled"></p>
<h1 id="Sui-package"><a href="#Sui-package" class="headerlink" title="Sui package"></a>Sui package</h1><p>The Sui package is in <code>sui/crates/sui</code> folder. It will be compiled into the sui command line tool. The files structure of this package is as follows:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  sui git:(main) tree
.
├── Cargo.toml
├── build.rs
├── genesis.md
├── offline_signing.md
├── src
│   ├── client_commands.rs
│   ├── config
│   │   └── mod.rs
│   ├── console.rs
│   ├── genesis_ceremony.rs
│   ├── keytool.rs
│   ├── lib.rs
│   ├── main.rs
│   ├── shell.rs
│   ├── sui_commands.rs
│   ├── sui_move
│   │   ├── build.rs
│   │   ├── coverage.rs
│   │   ├── disassemble.rs
│   │   ├── mod.rs
│   │   ├── new.rs
│   │   ├── prove.rs
│   │   ├── sui-natives.bpl
│   │   └── unit_test.rs
│   └── unit_tests
│       ├── cli_tests.rs
│       ├── data
│       │   ├── dummy_modules_publish
│       │   │   ├── Move.toml
│       │   │   └── sources
│       │   │       └── trusted_coin.move
│       │   └── move_call_args_linter
│       │       ├── Move.toml
│       │       └── sources
│       │           └── object_basics.move
│       ├── keytool_tests.rs
│       └── shell_tests.rs
└── tests
    ├── full_node_tests.rs
    ├── move_test_code
    │   ├── Move.toml
    │   └── sources
    │       └── shared_objects_version.move
    ├── quorum_driver_tests.rs
    ├── readme.rs
    ├── reconfiguration_tests.rs
    ├── shared_objects_tests.rs
    ├── shared_objects_version_tests.rs
    ├── simulator_tests.rs
    └── transaction_orchestrator_tests.rs

12 directories, 38 files</code></pre>

<h1 id="sui-genesis"><a href="#sui-genesis" class="headerlink" title="sui genesis"></a>sui genesis</h1><p>To create the configuration files and objects for a local Sui network, run the <code>genesis</code> command. </p>
<p>Genesis creates the network configuration files in the ~&#x2F;.sui&#x2F;sui_config folder. This includes a YAML file for fullnode, network, client, and each validator. It also creates a sui.keystore that stores client key pairs.</p>
<p>Let’s first look at how this command works.</p>
<blockquote>
<p>Entrance：<code>sui/crates/sui/src/main.rs —&gt; fn main()</code></p>
</blockquote>
<p>When we execute this command, we first parse the input parameters and then call <code>cmd.execute()</code>. This method will judge the input parameters and execute different codes for different commands.</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;main.rs
async fn main() &#123;
    #[cfg(windows)]
    colored::control::set_virtual_terminal(true).unwrap();

    let bin_name &#x3D; env!(&quot;CARGO_BIN_NAME&quot;);
    let cmd: SuiCommand &#x3D; SuiCommand::parse();
    ...
    exit_main!(cmd.execute().await);
&#125;</code></pre>

<p>If we use <code>sui genesis</code>.The <code>execute()</code> will match <code>SuiCommand::Genesis</code> .And the will call <code>genesis()</code>.</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs
impl SuiCommand &#123;
    pub async fn execute(self) -&gt; Result&lt;(), anyhow::Error&gt; &#123;
        match self &#123;
            ...
            SuiCommand::Genesis &#123;
                working_dir,
                force,
                from_config,
                write_config,
            &#125; &#x3D;&gt; genesis(from_config, write_config, working_dir, force).await,
		      ...   
			&#125;
    &#125;
&#125;</code></pre>

<p>This method mainly does 3 things:</p>
<ol>
<li>read config from disk</li>
<li>create some objects with those config value</li>
<li>store important objects(Nodeconfig,genesis_conf &amp; network_config) to disk</li>
</ol>
<h2 id="Read-config"><a href="#Read-config" class="headerlink" title="Read config"></a>Read config</h2><p>If we do not provide the config dir,It will create it with default parameter. </p>
<p>some default parameter:</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;ib.rs
const SUI_DIR: &amp;str &#x3D; &quot;.sui&quot;;
const SUI_CONFIG_DIR: &amp;str &#x3D; &quot;sui_config&quot;;
pub const SUI_NETWORK_CONFIG: &amp;str &#x3D; &quot;network.yaml&quot;;
pub const SUI_FULLNODE_CONFIG: &amp;str &#x3D; &quot;fullnode.yaml&quot;;
pub const SUI_CLIENT_CONFIG: &amp;str &#x3D; &quot;client.yaml&quot;;
pub const SUI_KEYSTORE_FILENAME: &amp;str &#x3D; &quot;sui.keystore&quot;;
pub const SUI_GATEWAY_CONFIG: &amp;str &#x3D; &quot;gateway.yaml&quot;;
pub const SUI_GENESIS_FILENAME: &amp;str &#x3D; &quot;genesis.blob&quot;;
pub const SUI_DEV_NET_URL: &amp;str &#x3D; &quot;https:&#x2F;&#x2F;fullnode.devnet.sui.io:443&quot;;

pub const AUTHORITIES_DB_NAME: &amp;str &#x3D; &quot;authorities_db&quot;;
pub const CONSENSUS_DB_NAME: &amp;str &#x3D; &quot;consensus_db&quot;;
pub const FULL_NODE_DB_PATH: &amp;str &#x3D; &quot;full_node_db&quot;;

const DEFAULT_STAKE: StakeUnit &#x3D; 100000000000000;
const DEFAULT_GAS_PRICE: u64 &#x3D; 1;
const DEFAULT_COMMISSION_RATE: u64 &#x3D; 0;

&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;genesis_config.rs
const DEFAULT_GAS_AMOUNT: u64 &#x3D; 100000000000000;
const DEFAULT_NUMBER_OF_AUTHORITIES: usize &#x3D; 4;
const DEFAULT_NUMBER_OF_ACCOUNT: usize &#x3D; 5;
const DEFAULT_NUMBER_OF_OBJECT_PER_ACCOUNT: usize &#x3D; 5;</code></pre>

<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui-commands.rs
async fn genesis(
    from_config: Option&lt;PathBuf&gt;,
    write_config: Option&lt;PathBuf&gt;,
    working_dir: Option&lt;PathBuf&gt;,
    force: bool,
) -&gt; Result&lt;(), anyhow::Error&gt; &#123;
    let sui_config_dir &#x3D; &amp;match working_dir &#123;
        &#x2F;&#x2F; if a directory is specified, it must exist (it
        &#x2F;&#x2F; will not be created)
        Some(v) &#x3D;&gt; v,
        &#x2F;&#x2F; create default Sui config dir if not specified
        &#x2F;&#x2F; on the command line and if it does not exist
        &#x2F;&#x2F; yet
        None &#x3D;&gt; &#123;
            let config_path &#x3D; sui_config_dir()?;
            fs::create_dir_all(&amp;config_path)?;
            config_path
        &#125;
    &#125;;

     ...
		let client_path &#x3D; sui_config_dir.join(SUI_CLIENT_CONFIG);
    let keystore_path &#x3D; sui_config_dir.join(SUI_KEYSTORE_FILENAME);
    ...
		let network_path &#x3D; sui_config_dir.join(SUI_NETWORK_CONFIG);
    let genesis_path &#x3D; sui_config_dir.join(SUI_GENESIS_FILENAME);

    let mut genesis_conf &#x3D; match from_config &#123;
        Some(path) &#x3D;&gt; PersistedConfig::read(&amp;path)?,
        None &#x3D;&gt; &#123;
            if keystore_path.exists() &#123;
                let existing_keys &#x3D; FileBasedKeystore::new(&amp;keystore_path)?.addresses();
                GenesisConfig::for_local_testing_with_addresses(existing_keys)
            &#125; else &#123;
                GenesisConfig::for_local_testing()
            &#125;
        &#125;
    &#125;;
...</code></pre>

<p><img src="/../img/20230103/301.png" alt="Untitled"></p>
<h2 id="create-objects"><a href="#create-objects" class="headerlink" title="create objects"></a>create objects</h2><p>Generate some important objects according the given configuration files or default configuration parameters.</p>
<ul>
<li>network_config</li>
<li>genesis_config</li>
<li>Client_config</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;genesis()

let mut network_config &#x3D; if let Some(validators) &#x3D; validator_info &#123;
        ConfigBuilder::new(sui_config_dir)
            .initial_accounts_config(genesis_conf)
            .with_validators(validators)
            .build()
    &#125; else &#123;
        ConfigBuilder::new(sui_config_dir)
            .committee_size(NonZeroUsize::new(genesis_conf.committee_size).unwrap())
            .initial_accounts_config(genesis_conf)
						&#x2F;&#x2F;will finally call build_with-calidators() in sui-config&#x2F;src&#x2F;builder.rs
						&#x2F;&#x2F;to genesis NetworkConfig&#123;&#125; and Nodeconfig
            .build()
    &#125;;
</code></pre>

<p><img src="/../img/20230103/308.png" alt="Untitled"></p>
<h2 id="store-objects"><a href="#store-objects" class="headerlink" title="store objects"></a>store objects</h2><p>After all objects are generated, the <code>network_config , genesis, validator,keystore and client_config</code>  will be written to disk.</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">
  let mut keystore &#x3D; FileBasedKeystore::new(&amp;keystore_path)?;
  for key in &amp;network_config.account_keys &#123;
      keystore.add_key(SuiKeyPair::Ed25519SuiKeyPair(key.copy()))?;
  &#125;
&#x2F;&#x2F;Take out the latest one in the keystore as active_address
  let active_address &#x3D; keystore.addresses().pop();

  network_config.genesis.save(&amp;genesis_path)?;
  for validator in &amp;mut network_config.validator_configs &#123;
      validator.genesis &#x3D; sui_config::node::Genesis::new_from_file(&amp;genesis_path);
  &#125;

  info!(&quot;Network genesis completed.&quot;);
  network_config.save(&amp;network_path)?;
  info!(&quot;Network config file is stored in &#123;:?&#125;.&quot;, network_path);

  info!(&quot;Client keystore is stored in &#123;:?&#125;.&quot;, keystore_path);

  let mut fullnode_config &#x3D; network_config.generate_fullnode_config();
  fullnode_config.json_rpc_address &#x3D; sui_config::node::default_json_rpc_address();
  fullnode_config.save(sui_config_dir.join(SUI_FULLNODE_CONFIG))?;

  for (i, validator) in network_config
      .into_validator_configs()
      .into_iter()
      .enumerate()
  &#123;
      let path &#x3D; sui_config_dir.join(format!(&quot;validator-config-&#123;&#125;.yaml&quot;, i));
      validator.save(path)?;
  &#125;

  let mut client_config &#x3D; if client_path.exists() &#123;
      PersistedConfig::read(&amp;client_path)?
  &#125; else &#123;
      SuiClientConfig::new(keystore.into())
  &#125;;
...
  client_config.save(&amp;client_path)?;
  info!(&quot;Client config file is stored in &#123;:?&#125;.&quot;, client_path);

  Ok(())</code></pre>

<p>We can get the detail from the output log.</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">2022-12-13T08:12:04.072712Z  INFO sui_config::genesis_config: Creating accounts and gas objects...
2022-12-13T08:16:33.039813Z  INFO sui::sui_commands: Network genesis completed.
2022-12-13T08:16:33.069233Z  INFO sui::sui_commands: Network config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;network.yaml&quot;.
2022-12-13T08:16:33.069286Z  INFO sui::sui_commands: Client keystore is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;sui.keystore&quot;.
2022-12-13T08:18:02.582274Z  INFO sui::sui_commands: Client config file is stored in &quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;client.yaml&quot;</code></pre>

<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">➜  sui_config tree
.
├── client.yaml
├── fullnode.yaml
├── genesis.blob
├── network.yaml
├── sui.keystore
├── validator-config-0.yaml
├── validator-config-1.yaml
├── validator-config-2.yaml
└── validator-config-3.yaml</code></pre>


<h1 id="sui-start"><a href="#sui-start" class="headerlink" title="sui start"></a>sui start</h1><p>Run <code>sui start</code> to start the local Sui network with default location for configuration.</p>
<p>This command looks for the Sui network configuration file <code>network.yaml</code> in the <code>~/.sui/sui_config</code> directory. If there is no configuration in this directory, it will call genesis() to genesis the default configuration first.</p>
<p>The sui node is divided into validator and full node:</p>
<ul>
<li>validator: validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected Full nodes that then service the queries from clients.</li>
<li>full node:Sui Full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each Full node stores and services the queries for the blockchain state and history.</li>
</ul>
<p>It will do those things:</p>
<ol>
<li>read configuration from disk(will call  genesis() to auto genesis if path is none)</li>
<li>build swarm with network_config(by default the swarm will contain 4 validators )</li>
<li>call swarm.launch() to start 4 validators.</li>
<li>run health Check service.</li>
</ol>
<h2 id="read-configuration"><a href="#read-configuration" class="headerlink" title="read configuration"></a>read configuration</h2><p>Before we used <code>sui genesis</code> to generate configuration files and perform storage persistence management.Here we will take it out, and then use these configuration files to generate <code>network_config</code> objects.</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute()
SuiCommand::Start &#123;
                config,
                no_full_node,
            &#125; &#x3D;&gt; &#123;
              ... 
							let network_config: NetworkConfig &#x3D; PersistedConfig::read(&amp;network_config_path)
                    .map_err(|err| &#123;
                        err.context(format!(
                            &quot;Cannot open Sui network config file at &#123;:?&#125;&quot;,
                            network_config_path
                        ))
                    &#125;)?;

&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-config&#x2F;src&#x2F;lib.rs
fn load&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Self, anyhow::Error&gt; &#123;
        let path &#x3D; path.as_ref();
        trace!(&quot;Reading config from &#123;&#125;&quot;, path.display());
        let reader &#x3D; fs::File::open(path)
            .with_context(|| format!(&quot;Unable to load config from &#123;&#125;&quot;, path.display()))?;
        Ok(serde_yaml::from_reader(reader)?)
    &#125;</code></pre>

<p><img src="/../img/20230103/302.png" alt="Untitled"></p>
<h2 id="build-swarm"><a href="#build-swarm" class="headerlink" title="build swarm"></a>build swarm</h2><p>Swarm is a handle to an in-memory Sui network.It contain a network_config and validators.</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;swarm.rs
&#x2F;&#x2F;&#x2F; A handle to an in-memory Sui Network.
#[derive(Debug)]
pub struct Swarm &#123;
    dir: SwarmDirectory,
    network_config: NetworkConfig,
    validators: HashMap&lt;SuiAddress, Node&gt;,
    fullnodes: HashMap&lt;SuiAddress, Node&gt;,
&#125;</code></pre>

<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute() 
let mut swarm &#x3D; if no_full_node &#123;
                    Swarm::builder()
                &#125; else &#123;
                    Swarm::builder()
                        .with_fullnode_rpc_addr(sui_config::node::default_json_rpc_address())
                &#125;
                .from_network_config(sui_config_dir()?, network_config);</code></pre>

<p><img src="/../img/20230103/303.png" alt="Untitled"></p>
<h2 id="run-validators"><a href="#run-validators" class="headerlink" title="run validators"></a>run validators</h2><p>After we build the swarm, we can use it to run each validator.</p>
<p>The whole process is:</p>
<p><code>//node.spawn()--&gt;Container::spawn()--&gt;SuiNode::start()</code></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui&#x2F;src&#x2F;sui_commands.rs--&gt;execute() 

swarm.launch().await?;

&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;swarm.rs
&#x2F;&#x2F;&#x2F; Start all of the Validators associated with this Swarm
    pub async fn launch(&amp;mut self) -&gt; Result&lt;()&gt; &#123;
        let start_handles &#x3D; self
            .nodes_iter_mut()
            .map(|node| node.spawn())
            .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;

        try_join_all(start_handles).await?;

        Ok(())
    &#125;

&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;node.rs

&#x2F;&#x2F;&#x2F; Start this Node, returning a handle that will resolve when the node has completed starting
    &#x2F;&#x2F;&#x2F; up.
    pub fn spawn(&amp;mut self) -&gt; Result&lt;tokio::sync::oneshot::Receiver&lt;()&gt;&gt; &#123;
        trace!(name &#x3D;% self.name(), &quot;starting in-memory node&quot;);
        let (startup_receiver, node_handle) &#x3D;
            Container::spawn(self.config.clone(), self.runtime_type);
        self.thread &#x3D; Some(node_handle);
        Ok(startup_receiver)
    &#125;

&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;container.rs--&gt;spawn()

runtime.block_on(async move &#123;
                let prometheus_registry &#x3D; metrics::start_prometheus_server(config.metrics_address);
                info!(
                    &quot;Started Prometheus HTTP endpoint. To query metrics use\n\tcurl -s http:&#x2F;&#x2F;&#123;&#125;&#x2F;metrics&quot;,
                    config.metrics_address
                );
                let _server &#x3D; SuiNode::start(&amp;config, prometheus_registry).await.unwrap();
                &#x2F;&#x2F; Notify that we&#39;ve successfully started the node
                let _ &#x3D; startup_sender.send(());
                &#x2F;&#x2F; run until canceled
                cancel_reciever.map(|_| ()).await;</code></pre>

<h3 id="SuiNode"><a href="#SuiNode" class="headerlink" title="SuiNode"></a>SuiNode</h3><p>Suinode is the smallest unit of node management and is a very important object.It contains almost all the functions that a node needs to implement. The focus of our follow-up analysis is here.</p>
<p>The main members of it are:</p>
<ul>
<li>config</li>
<li>checkpoint_store</li>
<li>_batch_subsystem_handle</li>
<li>_execute_driver_handle</li>
<li>state</li>
<li>active</li>
<li>_p2p_network</li>
<li>_discovery</li>
<li>_state_sync</li>
<li>sim_node</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">
&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-node&#x2F;src&#x2F;lib.rs

pub struct SuiNode &#123;
    config: NodeConfig,
    checkpoint_store: Arc&lt;CheckpointStore&gt;,
    validator_server_info: Option&lt;ValidatorServerInfo&gt;,
    _json_rpc_service: Option&lt;ServerHandle&gt;,
    _batch_subsystem_handle: tokio::task::JoinHandle&lt;()&gt;,
    _post_processing_subsystem_handle: Option&lt;tokio::task::JoinHandle&lt;Result&lt;()&gt;&gt;&gt;,
    _gossip_handle: Option&lt;tokio::task::JoinHandle&lt;()&gt;&gt;,
    _execute_driver_handle: tokio::task::JoinHandle&lt;()&gt;,
    state: Arc&lt;AuthorityState&gt;,
    active: Arc&lt;ActiveAuthority&lt;NetworkAuthorityClient&gt;&gt;,
    transaction_orchestrator: Option&lt;Arc&lt;TransactiondOrchestrator&lt;NetworkAuthorityClient&gt;&gt;&gt;,
    _prometheus_registry: Registry,

    _p2p_network: anemo::Network,
    _discovery: discovery::Handle,
    _state_sync: state_sync::Handle,

    reconfig_channel: (
        tokio::sync::mpsc::Sender&lt;EpochId&gt;,
        tokio::sync::mpsc::Receiver&lt;EpochId&gt;,
    ),

    #[cfg(msim)]
    sim_node: sui_simulator::runtime::NodeHandle,
&#125;
</code></pre>

<p>Now let’s analyze the detailed steps in the node startup process:</p>
<ol>
<li>Judging whether it is fullnode or validator</li>
<li>Initialize DB(committee_store,checkpoint_store,state_sync_store,index_store,event_store)</li>
<li>create p2p network(discovery_handle,state_sync_handle)</li>
<li>create transaction_streamer (if it’s fullNode)</li>
<li>create node_sync_store</li>
<li>create handles(batch_subsystem_handle,post_processing_subsystem_handle,execute_driver_handle)</li>
<li>create json_rpc_service</li>
<li>finish start up</li>
</ol>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">
&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-node&#x2F;src&#x2F;lib.rs
pub async fn start(config: &amp;NodeConfig, prometheus_registry: Registry) -&gt; Result&lt;SuiNode&gt; &#123;
        ...
        let store &#x3D;
            Arc::new(AuthorityStore::open(&amp;config.db_path().join(&quot;store&quot;), None, genesis).await?);
        let committee_store &#x3D; Arc::new(CommitteeStore::new(
            config.db_path().join(&quot;epochs&quot;),
            &amp;committee,
            None,
        ));
        let checkpoint_store &#x3D; CheckpointStore::new(&amp;config.db_path().join(&quot;checkpoints&quot;));

        let state_sync_store &#x3D; RocksDbStore::new(
            store.clone(),
            committee_store.clone(),
            checkpoint_store.clone(),
        );

        let index_store &#x3D; if is_validator &#123;
            None
        &#125; else &#123;
            Some(Arc::new(IndexStore::open_tables_read_write(
                config.db_path().join(&quot;indexes&quot;),
                None,
                None,
            )))
        &#125;;

        let event_store &#x3D; if config.enable_event_processing &#123;
            let path &#x3D; config.db_path().join(&quot;events.db&quot;);
            let db &#x3D; SqlEventStore::new_from_file(&amp;path).await?;
            db.initialize().await?;
            Some(Arc::new(EventStoreType::SqlEventStore(db)))
        &#125; else &#123;
            None
        &#125;;

        let (p2p_network, discovery_handle, state_sync_handle) &#x3D;
            Self::create_p2p_network(config, state_sync_store, &amp;prometheus_registry)?;

       ...
        let node_sync_store &#x3D; Arc::new(NodeSyncStore::open_tables_read_write(
            config.db_path().join(&quot;node_sync_db&quot;),
            None,
            None,
        ));

        ...

        let batch_subsystem_handle &#x3D; &#123;
            &#x2F;&#x2F; Start batch system so that this node can be followed
            let batch_state &#x3D; state.clone();
            spawn_monitored_task!(async move &#123;
                batch_state
                    .run_batch_service(1000, Duration::from_secs(1))
                    .await
            &#125;)
        &#125;;

        let post_processing_subsystem_handle &#x3D;
            if index_store.is_some() || config.enable_event_processing &#123;
                let indexing_state &#x3D; state.clone();
                Some(spawn_monitored_task!(async move &#123;
                    indexing_state
                        .run_tx_post_processing_process()
                        .await
                        .map_err(Into::into)
                &#125;))
            &#125; else &#123;
                None
            &#125;;

        
        let execute_driver_handle &#x3D; active_authority.clone().spawn_execute_process().await;
				...
        let json_rpc_service &#x3D; build_server(
            state.clone(),
            &amp;transaction_orchestrator.clone(),
            config,
            &amp;prometheus_registry,
        )
        .await?;

			 ...

        info!(&quot;SuiNode started!&quot;);

        Ok(node)</code></pre>

<p><img src="/../img/20230103/304.png" alt="Untitled"></p>
<p>We can get more info from the debug output.(here we only focus on the startup information of one node: 0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a).</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Launching: &#x2F;Users&#x2F;safeer&#x2F;sui&#x2F;target&#x2F;debug&#x2F;sui start
Launched process 80154
2022-12-14T08:59:58.765242Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use
	curl -s http:&#x2F;&#x2F;127.0.0.1:52424&#x2F;metrics
2022-12-14T08:59:58.765242Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_swarm::memory::container: Started Prometheus HTTP endpoint. To query metrics use
2022-12-14T09:00:12.433291Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: Initializing sui-node listening on &#x2F;ip4&#x2F;127.0.0.1&#x2F;tcp&#x2F;52420&#x2F;http node&#x3D;k#8c26601d82aac59fade53f345f8fe84239d69652142a7fdc7724f729a1716a07e16b07a91e5afd49ee45d5cc6f5f3a9e0d152797d9251f2be21811a764a2dea2539c3b7541d52bf2e78b4d256bd94daa193f0c2234ec76276b80c6f0fedf4274
2022-12-14T09:00:12.435263Z  WARN node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: mysten_metrics: init_metrics registry overwritten
2022-12-14T09:13:51.573049Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Created&#x2F;opened SQLite EventStore on disk db_path&#x3D;&quot;&#x2F;Users&#x2F;safeer&#x2F;.sui&#x2F;sui_config&#x2F;authorities_db&#x2F;2727618050&#x2F;events.db&quot;
2022-12-14T09:13:56.940186Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: SQLite events table is initialized with query &quot;CREATE TABLE IF NOT EXISTS events(timestamp INTEGER NOT NULL, seq_num INTEGER, event_num INTEGER, tx_digest BLOB, event_type INTEGER, package_id BLOB, module_name TEXT, function TEXT, object_type TEXT, object_id BLOB, fields TEXT, move_event_name TEXT, contents BLOB, sender BLOB, recipient TEXT);&quot;
2022-12-14T09:14:05.392089Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;seq_num&quot;
2022-12-14T09:14:10.311911Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;event_num&quot;
2022-12-14T09:14:13.542209Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;timestamp&quot;
2022-12-14T09:14:17.262100Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;tx_digest&quot;
2022-12-14T09:14:20.959975Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;event_type&quot;
2022-12-14T09:14:26.008174Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;package_id&quot;
2022-12-14T09:14:30.079815Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;module_name&quot;
2022-12-14T09:14:36.559934Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;sender&quot;
2022-12-14T09:14:36.567273Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;recipient&quot;
2022-12-14T09:14:36.574490Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;object_id&quot;
2022-12-14T09:14:36.582455Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;object_type&quot;
2022-12-14T09:14:36.589734Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_storage::event_store::sql: Index is ready column&#x3D;&quot;move_event_name&quot;
2022-12-14T09:14:36.598456Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: P2p network started on 127.0.0.1:52422
2022-12-14T09:14:43.930692Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active: respawn_node_sync_process epoch&#x3D;0
2022-12-14T09:14:43.931350Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active: spawning node sync task
2022-12-14T09:14:46.921729Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: acl&#x3D;Const(&quot;*&quot;)
2022-12-14T09:14:46.922716Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: Sui JSON-RPC server listening on 0.0.0.0:9000 local_addr&#x3D;0.0.0.0:9000
2022-12-14T09:14:46.922772Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_json_rpc: Available JSON-RPC methods : [&quot;sui_moveCall&quot;, &quot;sui_getCoinMetadata&quot;, &quot;sui_publish&quot;, &quot;sui_getObjectsOwnedByAddress&quot;, &quot;sui_payAllSui&quot;, &quot;sui_transferObject&quot;, &quot;sui_unsubscribeEvent&quot;, &quot;sui_executeTransaction&quot;, &quot;sui_mergeCoins&quot;, &quot;sui_subscribeTransaction&quot;, &quot;sui_getEvents&quot;, &quot;sui_getObject&quot;, &quot;sui_getTransactionsInRange&quot;, &quot;sui_getObjectsOwnedByObject&quot;, &quot;sui_executeTransactionSerializedSig&quot;, &quot;sui_subscribeEvent&quot;, &quot;sui_paySui&quot;, &quot;sui_getRawObject&quot;, &quot;sui_splitCoin&quot;, &quot;sui_getNormalizedMoveFunction&quot;, &quot;sui_getTransaction&quot;, &quot;sui_getTotalTransactionNumber&quot;, &quot;sui_pay&quot;, &quot;sui_getTransactionAuthSigners&quot;, &quot;sui_getMoveFunctionArgTypes&quot;, &quot;sui_transferSui&quot;, &quot;sui_batchTransaction&quot;, &quot;sui_unsubscribeTransaction&quot;, &quot;sui_dryRunTransaction&quot;, &quot;sui_splitCoinEqual&quot;, &quot;sui_getNormalizedMoveModule&quot;, &quot;sui_getNormalizedMoveModulesByPackage&quot;, &quot;sui_tryGetPastObject&quot;, &quot;rpc.discover&quot;, &quot;sui_getTransactions&quot;, &quot;sui_getCommitteeInfo&quot;, &quot;sui_getNormalizedMoveStruct&quot;]
2022-12-14T09:14:58.627411Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_node: SuiNode started!
2022-12-14T09:15:08.957227Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;:connection-manager&#123;peer&#x3D;82a014fa&#125;: anemo::network::connection_manager: ConnectionManager started
2022-12-14T09:15:08.957369Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_network::discovery: Discovery started
2022-12-14T09:15:08.957515Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_network::state_sync: State-Synchronizer started
2022-12-14T09:15:08.960911Z  INFO node&#123;name&#x3D;0x0f0711008959ccb02d47f2fb22c102bb60bcbe9a&#125;: sui_core::authority_active::execution_driver: Starting pending certificates execution process.</code></pre>

<h2 id="health-check"><a href="#health-check" class="headerlink" title="health check"></a>health check</h2><p>After starting the nodes,Performing a health check service to check that status of the node(Check every 5 seconds).</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">
&#x2F;&#x2F;&#x2F;&#x2F;sui&#x2F;crates&#x2F;sui-swarm&#x2F;src&#x2F;memory&#x2F;node.rs--&gt;spawn()

&#x2F;&#x2F;&#x2F; Perform a health check on this Node by:
    &#x2F;&#x2F;&#x2F; * Checking that the node is running
    &#x2F;&#x2F;&#x2F; * Calling the Node&#39;s gRPC Health service if it&#39;s a validator.
    pub async fn health_check(&amp;self, is_validator: bool) -&gt; Result&lt;(), HealthCheckError&gt; &#123;
        let thread &#x3D; self.thread.as_ref().ok_or(HealthCheckError::NotRunning)?;
        if !thread.is_alive() &#123;
            return Err(HealthCheckError::NotRunning);
        &#125;

        if is_validator &#123;
            let channel &#x3D; mysten_network::client::connect(self.config.network_address())
                .await
                .map_err(|err| anyhow!(err.to_string()))
                .map_err(HealthCheckError::Failure)
                .tap_err(|e| error!(&quot;error connecting to &#123;&#125;: &#123;e&#125;&quot;, self.name()))?;

            let mut client &#x3D; tonic_health::proto::health_client::HealthClient::new(channel);
            client
                .check(tonic_health::proto::HealthCheckRequest::default())
                .await
                .map_err(|e| HealthCheckError::Failure(e.into()))
                .tap_err(|e| error!(&quot;error performing health check on &#123;&#125;: &#123;e&#125;&quot;, self.name()))?;
        &#125;

        Ok(())
    &#125;</code></pre>

<h1 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a><strong>Summarize</strong></h1><p>We analyzed the startup process of the node in this page. </p>
<ul>
<li>reading the configuration file</li>
<li>generating objects according to the configuration file</li>
<li>open services during the node startup process</li>
</ul>
<p>In the following articles, we will analyze each part in detail, the most important of which is to analyze the various services opened during the node startup process(SuiNode object).</p>

  </div>
  
    
      <a id="older" class="blog-nav" href="/post/Sui%20Concept%20and%20Testnet.html">OLDER&nbsp;&gt;</a>
      
        
            
</div>
        <div class="footer">
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://www.movebit.xyz">Copyright © MoveBit 2022</a>
        
    </div>
  
    <div class="footer-more">
      
        
        
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-box">
        <div class="search-title">
          <!-- <span class="search-icon-input">
            <a href="javascript: void(0)">
              <i class="iconfont icon-search"></i>
            </a>
          </span> -->
          
            <input type="text" class="search-input" id="search-input" placeholder="$ grep...">
          
          <span class="search-close-icon" id="search-close-icon">
            <a href="javascript: void(0)">
              <i class="iconfont icon-close"></i>
            </a>
          </span>
        </div>
        <div class="search-result" id="search-result"></div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    // inputArea.onclick = function() {
    //   getSearchFile()
    //   this.onclick = null
    // }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        inputArea.focus()
        getSearchFile()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'><span></ul>";
      // $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='/" + data_url + "' class='search-result-title'><h2>" + orig_data_title + "</h2></a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<h3 class=\"search-result-abstract\">" + match_content + "...</h3>"
                }
                str += "<hr></li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/leedom92/hexo-theme-leedom#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




    </div>
  </body>
</html>
